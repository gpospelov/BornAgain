# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

import _libBornAgainFit

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainFit.delete_SwigPyIterator

    def value(self):
        r"""value(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainFit.SwigPyIterator_value(self)

    def incr(self, n=1):
        r"""incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _libBornAgainFit.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        r"""decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _libBornAgainFit.SwigPyIterator_decr(self, n)

    def distance(self, x):
        r"""distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _libBornAgainFit.SwigPyIterator_distance(self, x)

    def equal(self, x):
        r"""equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _libBornAgainFit.SwigPyIterator_equal(self, x)

    def copy(self):
        r"""copy(SwigPyIterator self) -> SwigPyIterator"""
        return _libBornAgainFit.SwigPyIterator_copy(self)

    def next(self):
        r"""next(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainFit.SwigPyIterator_next(self)

    def __next__(self):
        r"""__next__(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainFit.SwigPyIterator___next__(self)

    def previous(self):
        r"""previous(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainFit.SwigPyIterator_previous(self)

    def advance(self, n):
        r"""advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainFit.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        r"""__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _libBornAgainFit.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        r"""__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _libBornAgainFit.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        r"""__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainFit.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        r"""__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainFit.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        r"""__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainFit.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        r"""
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _libBornAgainFit.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _libBornAgainFit:
_libBornAgainFit.SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _libBornAgainFit.SHARED_PTR_DISOWN

class vdouble1d_t(object):
    r"""Proxy of C++ std::vector< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vdouble1d_t self) -> SwigPyIterator"""
        return _libBornAgainFit.vdouble1d_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vdouble1d_t self) -> bool"""
        return _libBornAgainFit.vdouble1d_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vdouble1d_t self) -> bool"""
        return _libBornAgainFit.vdouble1d_t___bool__(self)

    def __len__(self):
        r"""__len__(vdouble1d_t self) -> std::vector< double >::size_type"""
        return _libBornAgainFit.vdouble1d_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> vdouble1d_t"""
        return _libBornAgainFit.vdouble1d_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, vdouble1d_t v)
        """
        return _libBornAgainFit.vdouble1d_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _libBornAgainFit.vdouble1d_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vdouble1d_t self, std::vector< double >::difference_type i)
        __delitem__(vdouble1d_t self, PySliceObject * slice)
        """
        return _libBornAgainFit.vdouble1d_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vdouble1d_t self, PySliceObject * slice) -> vdouble1d_t
        __getitem__(vdouble1d_t self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _libBornAgainFit.vdouble1d_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vdouble1d_t self, PySliceObject * slice, vdouble1d_t v)
        __setitem__(vdouble1d_t self, PySliceObject * slice)
        __setitem__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _libBornAgainFit.vdouble1d_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vdouble1d_t self) -> std::vector< double >::value_type"""
        return _libBornAgainFit.vdouble1d_t_pop(self)

    def append(self, x):
        r"""append(vdouble1d_t self, std::vector< double >::value_type const & x)"""
        return _libBornAgainFit.vdouble1d_t_append(self, x)

    def empty(self):
        r"""empty(vdouble1d_t self) -> bool"""
        return _libBornAgainFit.vdouble1d_t_empty(self)

    def size(self):
        r"""size(vdouble1d_t self) -> std::vector< double >::size_type"""
        return _libBornAgainFit.vdouble1d_t_size(self)

    def swap(self, v):
        r"""swap(vdouble1d_t self, vdouble1d_t v)"""
        return _libBornAgainFit.vdouble1d_t_swap(self, v)

    def begin(self):
        r"""begin(vdouble1d_t self) -> std::vector< double >::iterator"""
        return _libBornAgainFit.vdouble1d_t_begin(self)

    def end(self):
        r"""end(vdouble1d_t self) -> std::vector< double >::iterator"""
        return _libBornAgainFit.vdouble1d_t_end(self)

    def rbegin(self):
        r"""rbegin(vdouble1d_t self) -> std::vector< double >::reverse_iterator"""
        return _libBornAgainFit.vdouble1d_t_rbegin(self)

    def rend(self):
        r"""rend(vdouble1d_t self) -> std::vector< double >::reverse_iterator"""
        return _libBornAgainFit.vdouble1d_t_rend(self)

    def clear(self):
        r"""clear(vdouble1d_t self)"""
        return _libBornAgainFit.vdouble1d_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vdouble1d_t self) -> std::vector< double >::allocator_type"""
        return _libBornAgainFit.vdouble1d_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vdouble1d_t self)"""
        return _libBornAgainFit.vdouble1d_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vdouble1d_t self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(vdouble1d_t self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _libBornAgainFit.vdouble1d_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vdouble1d_t self) -> vdouble1d_t
        __init__(vdouble1d_t self, vdouble1d_t other) -> vdouble1d_t
        __init__(vdouble1d_t self, std::vector< double >::size_type size) -> vdouble1d_t
        __init__(vdouble1d_t self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> vdouble1d_t
        """
        _libBornAgainFit.vdouble1d_t_swiginit(self, _libBornAgainFit.new_vdouble1d_t(*args))

    def push_back(self, x):
        r"""push_back(vdouble1d_t self, std::vector< double >::value_type const & x)"""
        return _libBornAgainFit.vdouble1d_t_push_back(self, x)

    def front(self):
        r"""front(vdouble1d_t self) -> std::vector< double >::value_type const &"""
        return _libBornAgainFit.vdouble1d_t_front(self)

    def back(self):
        r"""back(vdouble1d_t self) -> std::vector< double >::value_type const &"""
        return _libBornAgainFit.vdouble1d_t_back(self)

    def assign(self, n, x):
        r"""assign(vdouble1d_t self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _libBornAgainFit.vdouble1d_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vdouble1d_t self, std::vector< double >::size_type new_size)
        resize(vdouble1d_t self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _libBornAgainFit.vdouble1d_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vdouble1d_t self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(vdouble1d_t self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _libBornAgainFit.vdouble1d_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vdouble1d_t self, std::vector< double >::size_type n)"""
        return _libBornAgainFit.vdouble1d_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vdouble1d_t self) -> std::vector< double >::size_type"""
        return _libBornAgainFit.vdouble1d_t_capacity(self)
    __swig_destroy__ = _libBornAgainFit.delete_vdouble1d_t

# Register vdouble1d_t in _libBornAgainFit:
_libBornAgainFit.vdouble1d_t_swigregister(vdouble1d_t)

class vdouble2d_t(object):
    r"""Proxy of C++ std::vector< std::vector< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vdouble2d_t self) -> SwigPyIterator"""
        return _libBornAgainFit.vdouble2d_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vdouble2d_t self) -> bool"""
        return _libBornAgainFit.vdouble2d_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vdouble2d_t self) -> bool"""
        return _libBornAgainFit.vdouble2d_t___bool__(self)

    def __len__(self):
        r"""__len__(vdouble2d_t self) -> std::vector< std::vector< double > >::size_type"""
        return _libBornAgainFit.vdouble2d_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j) -> vdouble2d_t"""
        return _libBornAgainFit.vdouble2d_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)
        __setslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j, vdouble2d_t v)
        """
        return _libBornAgainFit.vdouble2d_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)"""
        return _libBornAgainFit.vdouble2d_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i)
        __delitem__(vdouble2d_t self, PySliceObject * slice)
        """
        return _libBornAgainFit.vdouble2d_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vdouble2d_t self, PySliceObject * slice) -> vdouble2d_t
        __getitem__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i) -> vdouble1d_t
        """
        return _libBornAgainFit.vdouble2d_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vdouble2d_t self, PySliceObject * slice, vdouble2d_t v)
        __setitem__(vdouble2d_t self, PySliceObject * slice)
        __setitem__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, vdouble1d_t x)
        """
        return _libBornAgainFit.vdouble2d_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vdouble2d_t self) -> vdouble1d_t"""
        return _libBornAgainFit.vdouble2d_t_pop(self)

    def append(self, x):
        r"""append(vdouble2d_t self, vdouble1d_t x)"""
        return _libBornAgainFit.vdouble2d_t_append(self, x)

    def empty(self):
        r"""empty(vdouble2d_t self) -> bool"""
        return _libBornAgainFit.vdouble2d_t_empty(self)

    def size(self):
        r"""size(vdouble2d_t self) -> std::vector< std::vector< double > >::size_type"""
        return _libBornAgainFit.vdouble2d_t_size(self)

    def swap(self, v):
        r"""swap(vdouble2d_t self, vdouble2d_t v)"""
        return _libBornAgainFit.vdouble2d_t_swap(self, v)

    def begin(self):
        r"""begin(vdouble2d_t self) -> std::vector< std::vector< double > >::iterator"""
        return _libBornAgainFit.vdouble2d_t_begin(self)

    def end(self):
        r"""end(vdouble2d_t self) -> std::vector< std::vector< double > >::iterator"""
        return _libBornAgainFit.vdouble2d_t_end(self)

    def rbegin(self):
        r"""rbegin(vdouble2d_t self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _libBornAgainFit.vdouble2d_t_rbegin(self)

    def rend(self):
        r"""rend(vdouble2d_t self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _libBornAgainFit.vdouble2d_t_rend(self)

    def clear(self):
        r"""clear(vdouble2d_t self)"""
        return _libBornAgainFit.vdouble2d_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vdouble2d_t self) -> std::vector< std::vector< double > >::allocator_type"""
        return _libBornAgainFit.vdouble2d_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vdouble2d_t self)"""
        return _libBornAgainFit.vdouble2d_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vdouble2d_t self, std::vector< std::vector< double > >::iterator pos) -> std::vector< std::vector< double > >::iterator
        erase(vdouble2d_t self, std::vector< std::vector< double > >::iterator first, std::vector< std::vector< double > >::iterator last) -> std::vector< std::vector< double > >::iterator
        """
        return _libBornAgainFit.vdouble2d_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vdouble2d_t self) -> vdouble2d_t
        __init__(vdouble2d_t self, vdouble2d_t other) -> vdouble2d_t
        __init__(vdouble2d_t self, std::vector< std::vector< double > >::size_type size) -> vdouble2d_t
        __init__(vdouble2d_t self, std::vector< std::vector< double > >::size_type size, vdouble1d_t value) -> vdouble2d_t
        """
        _libBornAgainFit.vdouble2d_t_swiginit(self, _libBornAgainFit.new_vdouble2d_t(*args))

    def push_back(self, x):
        r"""push_back(vdouble2d_t self, vdouble1d_t x)"""
        return _libBornAgainFit.vdouble2d_t_push_back(self, x)

    def front(self):
        r"""front(vdouble2d_t self) -> vdouble1d_t"""
        return _libBornAgainFit.vdouble2d_t_front(self)

    def back(self):
        r"""back(vdouble2d_t self) -> vdouble1d_t"""
        return _libBornAgainFit.vdouble2d_t_back(self)

    def assign(self, n, x):
        r"""assign(vdouble2d_t self, std::vector< std::vector< double > >::size_type n, vdouble1d_t x)"""
        return _libBornAgainFit.vdouble2d_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vdouble2d_t self, std::vector< std::vector< double > >::size_type new_size)
        resize(vdouble2d_t self, std::vector< std::vector< double > >::size_type new_size, vdouble1d_t x)
        """
        return _libBornAgainFit.vdouble2d_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vdouble2d_t self, std::vector< std::vector< double > >::iterator pos, vdouble1d_t x) -> std::vector< std::vector< double > >::iterator
        insert(vdouble2d_t self, std::vector< std::vector< double > >::iterator pos, std::vector< std::vector< double > >::size_type n, vdouble1d_t x)
        """
        return _libBornAgainFit.vdouble2d_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vdouble2d_t self, std::vector< std::vector< double > >::size_type n)"""
        return _libBornAgainFit.vdouble2d_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vdouble2d_t self) -> std::vector< std::vector< double > >::size_type"""
        return _libBornAgainFit.vdouble2d_t_capacity(self)
    __swig_destroy__ = _libBornAgainFit.delete_vdouble2d_t

# Register vdouble2d_t in _libBornAgainFit:
_libBornAgainFit.vdouble2d_t_swigregister(vdouble2d_t)

class vector_integer_t(object):
    r"""Proxy of C++ std::vector< int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_integer_t self) -> SwigPyIterator"""
        return _libBornAgainFit.vector_integer_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_integer_t self) -> bool"""
        return _libBornAgainFit.vector_integer_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_integer_t self) -> bool"""
        return _libBornAgainFit.vector_integer_t___bool__(self)

    def __len__(self):
        r"""__len__(vector_integer_t self) -> std::vector< int >::size_type"""
        return _libBornAgainFit.vector_integer_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> vector_integer_t"""
        return _libBornAgainFit.vector_integer_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        __setslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, vector_integer_t v)
        """
        return _libBornAgainFit.vector_integer_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _libBornAgainFit.vector_integer_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_integer_t self, std::vector< int >::difference_type i)
        __delitem__(vector_integer_t self, PySliceObject * slice)
        """
        return _libBornAgainFit.vector_integer_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_integer_t self, PySliceObject * slice) -> vector_integer_t
        __getitem__(vector_integer_t self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _libBornAgainFit.vector_integer_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_integer_t self, PySliceObject * slice, vector_integer_t v)
        __setitem__(vector_integer_t self, PySliceObject * slice)
        __setitem__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _libBornAgainFit.vector_integer_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_integer_t self) -> std::vector< int >::value_type"""
        return _libBornAgainFit.vector_integer_t_pop(self)

    def append(self, x):
        r"""append(vector_integer_t self, std::vector< int >::value_type const & x)"""
        return _libBornAgainFit.vector_integer_t_append(self, x)

    def empty(self):
        r"""empty(vector_integer_t self) -> bool"""
        return _libBornAgainFit.vector_integer_t_empty(self)

    def size(self):
        r"""size(vector_integer_t self) -> std::vector< int >::size_type"""
        return _libBornAgainFit.vector_integer_t_size(self)

    def swap(self, v):
        r"""swap(vector_integer_t self, vector_integer_t v)"""
        return _libBornAgainFit.vector_integer_t_swap(self, v)

    def begin(self):
        r"""begin(vector_integer_t self) -> std::vector< int >::iterator"""
        return _libBornAgainFit.vector_integer_t_begin(self)

    def end(self):
        r"""end(vector_integer_t self) -> std::vector< int >::iterator"""
        return _libBornAgainFit.vector_integer_t_end(self)

    def rbegin(self):
        r"""rbegin(vector_integer_t self) -> std::vector< int >::reverse_iterator"""
        return _libBornAgainFit.vector_integer_t_rbegin(self)

    def rend(self):
        r"""rend(vector_integer_t self) -> std::vector< int >::reverse_iterator"""
        return _libBornAgainFit.vector_integer_t_rend(self)

    def clear(self):
        r"""clear(vector_integer_t self)"""
        return _libBornAgainFit.vector_integer_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_integer_t self) -> std::vector< int >::allocator_type"""
        return _libBornAgainFit.vector_integer_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_integer_t self)"""
        return _libBornAgainFit.vector_integer_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_integer_t self, std::vector< int >::iterator pos) -> std::vector< int >::iterator
        erase(vector_integer_t self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator
        """
        return _libBornAgainFit.vector_integer_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_integer_t self) -> vector_integer_t
        __init__(vector_integer_t self, vector_integer_t other) -> vector_integer_t
        __init__(vector_integer_t self, std::vector< int >::size_type size) -> vector_integer_t
        __init__(vector_integer_t self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> vector_integer_t
        """
        _libBornAgainFit.vector_integer_t_swiginit(self, _libBornAgainFit.new_vector_integer_t(*args))

    def push_back(self, x):
        r"""push_back(vector_integer_t self, std::vector< int >::value_type const & x)"""
        return _libBornAgainFit.vector_integer_t_push_back(self, x)

    def front(self):
        r"""front(vector_integer_t self) -> std::vector< int >::value_type const &"""
        return _libBornAgainFit.vector_integer_t_front(self)

    def back(self):
        r"""back(vector_integer_t self) -> std::vector< int >::value_type const &"""
        return _libBornAgainFit.vector_integer_t_back(self)

    def assign(self, n, x):
        r"""assign(vector_integer_t self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)"""
        return _libBornAgainFit.vector_integer_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_integer_t self, std::vector< int >::size_type new_size)
        resize(vector_integer_t self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)
        """
        return _libBornAgainFit.vector_integer_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_integer_t self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator
        insert(vector_integer_t self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)
        """
        return _libBornAgainFit.vector_integer_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_integer_t self, std::vector< int >::size_type n)"""
        return _libBornAgainFit.vector_integer_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_integer_t self) -> std::vector< int >::size_type"""
        return _libBornAgainFit.vector_integer_t_capacity(self)
    __swig_destroy__ = _libBornAgainFit.delete_vector_integer_t

# Register vector_integer_t in _libBornAgainFit:
_libBornAgainFit.vector_integer_t_swigregister(vector_integer_t)

class vector_longinteger_t(object):
    r"""Proxy of C++ std::vector< unsigned long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_longinteger_t self) -> SwigPyIterator"""
        return _libBornAgainFit.vector_longinteger_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_longinteger_t self) -> bool"""
        return _libBornAgainFit.vector_longinteger_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_longinteger_t self) -> bool"""
        return _libBornAgainFit.vector_longinteger_t___bool__(self)

    def __len__(self):
        r"""__len__(vector_longinteger_t self) -> std::vector< unsigned long >::size_type"""
        return _libBornAgainFit.vector_longinteger_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j) -> vector_longinteger_t"""
        return _libBornAgainFit.vector_longinteger_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)
        __setslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j, vector_longinteger_t v)
        """
        return _libBornAgainFit.vector_longinteger_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)"""
        return _libBornAgainFit.vector_longinteger_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i)
        __delitem__(vector_longinteger_t self, PySliceObject * slice)
        """
        return _libBornAgainFit.vector_longinteger_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_longinteger_t self, PySliceObject * slice) -> vector_longinteger_t
        __getitem__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i) -> std::vector< unsigned long >::value_type const &
        """
        return _libBornAgainFit.vector_longinteger_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_longinteger_t self, PySliceObject * slice, vector_longinteger_t v)
        __setitem__(vector_longinteger_t self, PySliceObject * slice)
        __setitem__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::value_type const & x)
        """
        return _libBornAgainFit.vector_longinteger_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_longinteger_t self) -> std::vector< unsigned long >::value_type"""
        return _libBornAgainFit.vector_longinteger_t_pop(self)

    def append(self, x):
        r"""append(vector_longinteger_t self, std::vector< unsigned long >::value_type const & x)"""
        return _libBornAgainFit.vector_longinteger_t_append(self, x)

    def empty(self):
        r"""empty(vector_longinteger_t self) -> bool"""
        return _libBornAgainFit.vector_longinteger_t_empty(self)

    def size(self):
        r"""size(vector_longinteger_t self) -> std::vector< unsigned long >::size_type"""
        return _libBornAgainFit.vector_longinteger_t_size(self)

    def swap(self, v):
        r"""swap(vector_longinteger_t self, vector_longinteger_t v)"""
        return _libBornAgainFit.vector_longinteger_t_swap(self, v)

    def begin(self):
        r"""begin(vector_longinteger_t self) -> std::vector< unsigned long >::iterator"""
        return _libBornAgainFit.vector_longinteger_t_begin(self)

    def end(self):
        r"""end(vector_longinteger_t self) -> std::vector< unsigned long >::iterator"""
        return _libBornAgainFit.vector_longinteger_t_end(self)

    def rbegin(self):
        r"""rbegin(vector_longinteger_t self) -> std::vector< unsigned long >::reverse_iterator"""
        return _libBornAgainFit.vector_longinteger_t_rbegin(self)

    def rend(self):
        r"""rend(vector_longinteger_t self) -> std::vector< unsigned long >::reverse_iterator"""
        return _libBornAgainFit.vector_longinteger_t_rend(self)

    def clear(self):
        r"""clear(vector_longinteger_t self)"""
        return _libBornAgainFit.vector_longinteger_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_longinteger_t self) -> std::vector< unsigned long >::allocator_type"""
        return _libBornAgainFit.vector_longinteger_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_longinteger_t self)"""
        return _libBornAgainFit.vector_longinteger_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_longinteger_t self, std::vector< unsigned long >::iterator pos) -> std::vector< unsigned long >::iterator
        erase(vector_longinteger_t self, std::vector< unsigned long >::iterator first, std::vector< unsigned long >::iterator last) -> std::vector< unsigned long >::iterator
        """
        return _libBornAgainFit.vector_longinteger_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_longinteger_t self) -> vector_longinteger_t
        __init__(vector_longinteger_t self, vector_longinteger_t other) -> vector_longinteger_t
        __init__(vector_longinteger_t self, std::vector< unsigned long >::size_type size) -> vector_longinteger_t
        __init__(vector_longinteger_t self, std::vector< unsigned long >::size_type size, std::vector< unsigned long >::value_type const & value) -> vector_longinteger_t
        """
        _libBornAgainFit.vector_longinteger_t_swiginit(self, _libBornAgainFit.new_vector_longinteger_t(*args))

    def push_back(self, x):
        r"""push_back(vector_longinteger_t self, std::vector< unsigned long >::value_type const & x)"""
        return _libBornAgainFit.vector_longinteger_t_push_back(self, x)

    def front(self):
        r"""front(vector_longinteger_t self) -> std::vector< unsigned long >::value_type const &"""
        return _libBornAgainFit.vector_longinteger_t_front(self)

    def back(self):
        r"""back(vector_longinteger_t self) -> std::vector< unsigned long >::value_type const &"""
        return _libBornAgainFit.vector_longinteger_t_back(self)

    def assign(self, n, x):
        r"""assign(vector_longinteger_t self, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)"""
        return _libBornAgainFit.vector_longinteger_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_longinteger_t self, std::vector< unsigned long >::size_type new_size)
        resize(vector_longinteger_t self, std::vector< unsigned long >::size_type new_size, std::vector< unsigned long >::value_type const & x)
        """
        return _libBornAgainFit.vector_longinteger_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_longinteger_t self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::value_type const & x) -> std::vector< unsigned long >::iterator
        insert(vector_longinteger_t self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)
        """
        return _libBornAgainFit.vector_longinteger_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_longinteger_t self, std::vector< unsigned long >::size_type n)"""
        return _libBornAgainFit.vector_longinteger_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_longinteger_t self) -> std::vector< unsigned long >::size_type"""
        return _libBornAgainFit.vector_longinteger_t_capacity(self)
    __swig_destroy__ = _libBornAgainFit.delete_vector_longinteger_t

# Register vector_longinteger_t in _libBornAgainFit:
_libBornAgainFit.vector_longinteger_t_swigregister(vector_longinteger_t)

class vector_complex_t(object):
    r"""Proxy of C++ std::vector< std::complex< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_complex_t self) -> SwigPyIterator"""
        return _libBornAgainFit.vector_complex_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_complex_t self) -> bool"""
        return _libBornAgainFit.vector_complex_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_complex_t self) -> bool"""
        return _libBornAgainFit.vector_complex_t___bool__(self)

    def __len__(self):
        r"""__len__(vector_complex_t self) -> std::vector< std::complex< double > >::size_type"""
        return _libBornAgainFit.vector_complex_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j) -> vector_complex_t"""
        return _libBornAgainFit.vector_complex_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j)
        __setslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j, vector_complex_t v)
        """
        return _libBornAgainFit.vector_complex_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j)"""
        return _libBornAgainFit.vector_complex_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i)
        __delitem__(vector_complex_t self, PySliceObject * slice)
        """
        return _libBornAgainFit.vector_complex_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_complex_t self, PySliceObject * slice) -> vector_complex_t
        __getitem__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i) -> std::vector< std::complex< double > >::value_type const &
        """
        return _libBornAgainFit.vector_complex_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_complex_t self, PySliceObject * slice, vector_complex_t v)
        __setitem__(vector_complex_t self, PySliceObject * slice)
        __setitem__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::value_type const & x)
        """
        return _libBornAgainFit.vector_complex_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_complex_t self) -> std::vector< std::complex< double > >::value_type"""
        return _libBornAgainFit.vector_complex_t_pop(self)

    def append(self, x):
        r"""append(vector_complex_t self, std::vector< std::complex< double > >::value_type const & x)"""
        return _libBornAgainFit.vector_complex_t_append(self, x)

    def empty(self):
        r"""empty(vector_complex_t self) -> bool"""
        return _libBornAgainFit.vector_complex_t_empty(self)

    def size(self):
        r"""size(vector_complex_t self) -> std::vector< std::complex< double > >::size_type"""
        return _libBornAgainFit.vector_complex_t_size(self)

    def swap(self, v):
        r"""swap(vector_complex_t self, vector_complex_t v)"""
        return _libBornAgainFit.vector_complex_t_swap(self, v)

    def begin(self):
        r"""begin(vector_complex_t self) -> std::vector< std::complex< double > >::iterator"""
        return _libBornAgainFit.vector_complex_t_begin(self)

    def end(self):
        r"""end(vector_complex_t self) -> std::vector< std::complex< double > >::iterator"""
        return _libBornAgainFit.vector_complex_t_end(self)

    def rbegin(self):
        r"""rbegin(vector_complex_t self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _libBornAgainFit.vector_complex_t_rbegin(self)

    def rend(self):
        r"""rend(vector_complex_t self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _libBornAgainFit.vector_complex_t_rend(self)

    def clear(self):
        r"""clear(vector_complex_t self)"""
        return _libBornAgainFit.vector_complex_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_complex_t self) -> std::vector< std::complex< double > >::allocator_type"""
        return _libBornAgainFit.vector_complex_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_complex_t self)"""
        return _libBornAgainFit.vector_complex_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_complex_t self, std::vector< std::complex< double > >::iterator pos) -> std::vector< std::complex< double > >::iterator
        erase(vector_complex_t self, std::vector< std::complex< double > >::iterator first, std::vector< std::complex< double > >::iterator last) -> std::vector< std::complex< double > >::iterator
        """
        return _libBornAgainFit.vector_complex_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_complex_t self) -> vector_complex_t
        __init__(vector_complex_t self, vector_complex_t other) -> vector_complex_t
        __init__(vector_complex_t self, std::vector< std::complex< double > >::size_type size) -> vector_complex_t
        __init__(vector_complex_t self, std::vector< std::complex< double > >::size_type size, std::vector< std::complex< double > >::value_type const & value) -> vector_complex_t
        """
        _libBornAgainFit.vector_complex_t_swiginit(self, _libBornAgainFit.new_vector_complex_t(*args))

    def push_back(self, x):
        r"""push_back(vector_complex_t self, std::vector< std::complex< double > >::value_type const & x)"""
        return _libBornAgainFit.vector_complex_t_push_back(self, x)

    def front(self):
        r"""front(vector_complex_t self) -> std::vector< std::complex< double > >::value_type const &"""
        return _libBornAgainFit.vector_complex_t_front(self)

    def back(self):
        r"""back(vector_complex_t self) -> std::vector< std::complex< double > >::value_type const &"""
        return _libBornAgainFit.vector_complex_t_back(self)

    def assign(self, n, x):
        r"""assign(vector_complex_t self, std::vector< std::complex< double > >::size_type n, std::vector< std::complex< double > >::value_type const & x)"""
        return _libBornAgainFit.vector_complex_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_complex_t self, std::vector< std::complex< double > >::size_type new_size)
        resize(vector_complex_t self, std::vector< std::complex< double > >::size_type new_size, std::vector< std::complex< double > >::value_type const & x)
        """
        return _libBornAgainFit.vector_complex_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_complex_t self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::value_type const & x) -> std::vector< std::complex< double > >::iterator
        insert(vector_complex_t self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::size_type n, std::vector< std::complex< double > >::value_type const & x)
        """
        return _libBornAgainFit.vector_complex_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_complex_t self, std::vector< std::complex< double > >::size_type n)"""
        return _libBornAgainFit.vector_complex_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_complex_t self) -> std::vector< std::complex< double > >::size_type"""
        return _libBornAgainFit.vector_complex_t_capacity(self)
    __swig_destroy__ = _libBornAgainFit.delete_vector_complex_t

# Register vector_complex_t in _libBornAgainFit:
_libBornAgainFit.vector_complex_t_swigregister(vector_complex_t)

class vector_string_t(object):
    r"""Proxy of C++ std::vector< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_string_t self) -> SwigPyIterator"""
        return _libBornAgainFit.vector_string_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_string_t self) -> bool"""
        return _libBornAgainFit.vector_string_t___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_string_t self) -> bool"""
        return _libBornAgainFit.vector_string_t___bool__(self)

    def __len__(self):
        r"""__len__(vector_string_t self) -> std::vector< std::string >::size_type"""
        return _libBornAgainFit.vector_string_t___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> vector_string_t"""
        return _libBornAgainFit.vector_string_t___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        __setslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, vector_string_t v)
        """
        return _libBornAgainFit.vector_string_t___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _libBornAgainFit.vector_string_t___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_string_t self, std::vector< std::string >::difference_type i)
        __delitem__(vector_string_t self, PySliceObject * slice)
        """
        return _libBornAgainFit.vector_string_t___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_string_t self, PySliceObject * slice) -> vector_string_t
        __getitem__(vector_string_t self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _libBornAgainFit.vector_string_t___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_string_t self, PySliceObject * slice, vector_string_t v)
        __setitem__(vector_string_t self, PySliceObject * slice)
        __setitem__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _libBornAgainFit.vector_string_t___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_string_t self) -> std::vector< std::string >::value_type"""
        return _libBornAgainFit.vector_string_t_pop(self)

    def append(self, x):
        r"""append(vector_string_t self, std::vector< std::string >::value_type const & x)"""
        return _libBornAgainFit.vector_string_t_append(self, x)

    def empty(self):
        r"""empty(vector_string_t self) -> bool"""
        return _libBornAgainFit.vector_string_t_empty(self)

    def size(self):
        r"""size(vector_string_t self) -> std::vector< std::string >::size_type"""
        return _libBornAgainFit.vector_string_t_size(self)

    def swap(self, v):
        r"""swap(vector_string_t self, vector_string_t v)"""
        return _libBornAgainFit.vector_string_t_swap(self, v)

    def begin(self):
        r"""begin(vector_string_t self) -> std::vector< std::string >::iterator"""
        return _libBornAgainFit.vector_string_t_begin(self)

    def end(self):
        r"""end(vector_string_t self) -> std::vector< std::string >::iterator"""
        return _libBornAgainFit.vector_string_t_end(self)

    def rbegin(self):
        r"""rbegin(vector_string_t self) -> std::vector< std::string >::reverse_iterator"""
        return _libBornAgainFit.vector_string_t_rbegin(self)

    def rend(self):
        r"""rend(vector_string_t self) -> std::vector< std::string >::reverse_iterator"""
        return _libBornAgainFit.vector_string_t_rend(self)

    def clear(self):
        r"""clear(vector_string_t self)"""
        return _libBornAgainFit.vector_string_t_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_string_t self) -> std::vector< std::string >::allocator_type"""
        return _libBornAgainFit.vector_string_t_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_string_t self)"""
        return _libBornAgainFit.vector_string_t_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_string_t self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(vector_string_t self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _libBornAgainFit.vector_string_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_string_t self) -> vector_string_t
        __init__(vector_string_t self, vector_string_t other) -> vector_string_t
        __init__(vector_string_t self, std::vector< std::string >::size_type size) -> vector_string_t
        __init__(vector_string_t self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> vector_string_t
        """
        _libBornAgainFit.vector_string_t_swiginit(self, _libBornAgainFit.new_vector_string_t(*args))

    def push_back(self, x):
        r"""push_back(vector_string_t self, std::vector< std::string >::value_type const & x)"""
        return _libBornAgainFit.vector_string_t_push_back(self, x)

    def front(self):
        r"""front(vector_string_t self) -> std::vector< std::string >::value_type const &"""
        return _libBornAgainFit.vector_string_t_front(self)

    def back(self):
        r"""back(vector_string_t self) -> std::vector< std::string >::value_type const &"""
        return _libBornAgainFit.vector_string_t_back(self)

    def assign(self, n, x):
        r"""assign(vector_string_t self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _libBornAgainFit.vector_string_t_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_string_t self, std::vector< std::string >::size_type new_size)
        resize(vector_string_t self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _libBornAgainFit.vector_string_t_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_string_t self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(vector_string_t self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)
        """
        return _libBornAgainFit.vector_string_t_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_string_t self, std::vector< std::string >::size_type n)"""
        return _libBornAgainFit.vector_string_t_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_string_t self) -> std::vector< std::string >::size_type"""
        return _libBornAgainFit.vector_string_t_capacity(self)
    __swig_destroy__ = _libBornAgainFit.delete_vector_string_t

# Register vector_string_t in _libBornAgainFit:
_libBornAgainFit.vector_string_t_swigregister(vector_string_t)

class RealLimits(object):
    r"""


    Limits for a real fit parameter.

    C++ includes: RealLimits.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(RealLimits self) -> RealLimits
        RealLimits::RealLimits()

        """
        _libBornAgainFit.RealLimits_swiginit(self, _libBornAgainFit.new_RealLimits())

    def hasLowerLimit(self):
        r"""
        hasLowerLimit(RealLimits self) -> bool
        bool RealLimits::hasLowerLimit() const

        if has lower limit 

        """
        return _libBornAgainFit.RealLimits_hasLowerLimit(self)

    def lowerLimit(self):
        r"""
        lowerLimit(RealLimits self) -> double
        double RealLimits::lowerLimit() const

        Returns lower limit. 

        """
        return _libBornAgainFit.RealLimits_lowerLimit(self)

    def setLowerLimit(self, value):
        r"""
        setLowerLimit(RealLimits self, double value)
        void RealLimits::setLowerLimit(double value)

        Sets lower limit. 

        """
        return _libBornAgainFit.RealLimits_setLowerLimit(self, value)

    def removeLowerLimit(self):
        r"""
        removeLowerLimit(RealLimits self)
        void RealLimits::removeLowerLimit()

        remove lower limit 

        """
        return _libBornAgainFit.RealLimits_removeLowerLimit(self)

    def hasUpperLimit(self):
        r"""
        hasUpperLimit(RealLimits self) -> bool
        bool RealLimits::hasUpperLimit() const

        if has upper limit 

        """
        return _libBornAgainFit.RealLimits_hasUpperLimit(self)

    def upperLimit(self):
        r"""
        upperLimit(RealLimits self) -> double
        double RealLimits::upperLimit() const

        Returns upper limit. 

        """
        return _libBornAgainFit.RealLimits_upperLimit(self)

    def setUpperLimit(self, value):
        r"""
        setUpperLimit(RealLimits self, double value)
        void RealLimits::setUpperLimit(double value)

        Sets upper limit. 

        """
        return _libBornAgainFit.RealLimits_setUpperLimit(self, value)

    def removeUpperLimit(self):
        r"""
        removeUpperLimit(RealLimits self)
        void RealLimits::removeUpperLimit()

        remove upper limit 

        """
        return _libBornAgainFit.RealLimits_removeUpperLimit(self)

    def hasLowerAndUpperLimits(self):
        r"""
        hasLowerAndUpperLimits(RealLimits self) -> bool
        bool RealLimits::hasLowerAndUpperLimits() const

        if has lower and upper limit 

        """
        return _libBornAgainFit.RealLimits_hasLowerAndUpperLimits(self)

    def setLimits(self, xmin, xmax):
        r"""
        setLimits(RealLimits self, double xmin, double xmax)
        void RealLimits::setLimits(double xmin, double xmax)

        Sets lower and upper limits. 

        """
        return _libBornAgainFit.RealLimits_setLimits(self, xmin, xmax)

    def removeLimits(self):
        r"""
        removeLimits(RealLimits self)
        void RealLimits::removeLimits()

        remove limits 

        """
        return _libBornAgainFit.RealLimits_removeLimits(self)

    def isInRange(self, value):
        r"""
        isInRange(RealLimits self, double value) -> bool
        bool RealLimits::isInRange(double value) const

        returns true if proposed value is in limits range 

        """
        return _libBornAgainFit.RealLimits_isInRange(self, value)

    @staticmethod
    def lowerLimited(bound_value):
        r"""lowerLimited(double bound_value) -> RealLimits"""
        return _libBornAgainFit.RealLimits_lowerLimited(bound_value)

    @staticmethod
    def positive():
        r"""positive() -> RealLimits"""
        return _libBornAgainFit.RealLimits_positive()

    @staticmethod
    def nonnegative():
        r"""nonnegative() -> RealLimits"""
        return _libBornAgainFit.RealLimits_nonnegative()

    @staticmethod
    def upperLimited(bound_value):
        r"""upperLimited(double bound_value) -> RealLimits"""
        return _libBornAgainFit.RealLimits_upperLimited(bound_value)

    @staticmethod
    def limited(left_bound_value, right_bound_value):
        r"""limited(double left_bound_value, double right_bound_value) -> RealLimits"""
        return _libBornAgainFit.RealLimits_limited(left_bound_value, right_bound_value)

    @staticmethod
    def limitless():
        r"""limitless() -> RealLimits"""
        return _libBornAgainFit.RealLimits_limitless()

    def toString(self):
        r"""
        toString(RealLimits self) -> std::string
        std::string RealLimits::toString() const

        """
        return _libBornAgainFit.RealLimits_toString(self)

    def __eq__(self, other):
        r"""__eq__(RealLimits self, RealLimits other) -> bool"""
        return _libBornAgainFit.RealLimits___eq__(self, other)

    def __ne__(self, other):
        r"""__ne__(RealLimits self, RealLimits other) -> bool"""
        return _libBornAgainFit.RealLimits___ne__(self, other)

    def isLimitless(self):
        r"""
        isLimitless(RealLimits self) -> bool
        bool RealLimits::isLimitless() const

        """
        return _libBornAgainFit.RealLimits_isLimitless(self)

    def isPositive(self):
        r"""
        isPositive(RealLimits self) -> bool
        bool RealLimits::isPositive() const

        """
        return _libBornAgainFit.RealLimits_isPositive(self)

    def isNonnegative(self):
        r"""
        isNonnegative(RealLimits self) -> bool
        bool RealLimits::isNonnegative() const

        """
        return _libBornAgainFit.RealLimits_isNonnegative(self)

    def isLowerLimited(self):
        r"""
        isLowerLimited(RealLimits self) -> bool
        bool RealLimits::isLowerLimited() const

        """
        return _libBornAgainFit.RealLimits_isLowerLimited(self)

    def isUpperLimited(self):
        r"""
        isUpperLimited(RealLimits self) -> bool
        bool RealLimits::isUpperLimited() const

        """
        return _libBornAgainFit.RealLimits_isUpperLimited(self)

    def isLimited(self):
        r"""
        isLimited(RealLimits self) -> bool
        bool RealLimits::isLimited() const

        """
        return _libBornAgainFit.RealLimits_isLimited(self)
    __swig_destroy__ = _libBornAgainFit.delete_RealLimits

# Register RealLimits in _libBornAgainFit:
_libBornAgainFit.RealLimits_swigregister(RealLimits)

def RealLimits_lowerLimited(bound_value):
    r"""RealLimits_lowerLimited(double bound_value) -> RealLimits"""
    return _libBornAgainFit.RealLimits_lowerLimited(bound_value)

def RealLimits_positive():
    r"""RealLimits_positive() -> RealLimits"""
    return _libBornAgainFit.RealLimits_positive()

def RealLimits_nonnegative():
    r"""RealLimits_nonnegative() -> RealLimits"""
    return _libBornAgainFit.RealLimits_nonnegative()

def RealLimits_upperLimited(bound_value):
    r"""RealLimits_upperLimited(double bound_value) -> RealLimits"""
    return _libBornAgainFit.RealLimits_upperLimited(bound_value)

def RealLimits_limited(left_bound_value, right_bound_value):
    r"""RealLimits_limited(double left_bound_value, double right_bound_value) -> RealLimits"""
    return _libBornAgainFit.RealLimits_limited(left_bound_value, right_bound_value)

def RealLimits_limitless():
    r"""RealLimits_limitless() -> RealLimits"""
    return _libBornAgainFit.RealLimits_limitless()

class AttLimits(object):
    r"""


    Attributes and limits of a fit parameter, and coupling between these properties.

    C++ includes: AttLimits.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(AttLimits self) -> AttLimits
        AttLimits::AttLimits()

        """
        _libBornAgainFit.AttLimits_swiginit(self, _libBornAgainFit.new_AttLimits())

    @staticmethod
    def limitless():
        r"""limitless() -> AttLimits"""
        return _libBornAgainFit.AttLimits_limitless()

    @staticmethod
    def lowerLimited(bound_value):
        r"""lowerLimited(double bound_value) -> AttLimits"""
        return _libBornAgainFit.AttLimits_lowerLimited(bound_value)

    @staticmethod
    def positive():
        r"""positive() -> AttLimits"""
        return _libBornAgainFit.AttLimits_positive()

    @staticmethod
    def nonnegative():
        r"""nonnegative() -> AttLimits"""
        return _libBornAgainFit.AttLimits_nonnegative()

    @staticmethod
    def upperLimited(bound_value):
        r"""upperLimited(double bound_value) -> AttLimits"""
        return _libBornAgainFit.AttLimits_upperLimited(bound_value)

    @staticmethod
    def limited(left_bound_value, right_bound_value):
        r"""limited(double left_bound_value, double right_bound_value) -> AttLimits"""
        return _libBornAgainFit.AttLimits_limited(left_bound_value, right_bound_value)

    @staticmethod
    def fixed():
        r"""fixed() -> AttLimits"""
        return _libBornAgainFit.AttLimits_fixed()

    def isFixed(self):
        r"""
        isFixed(AttLimits self) -> bool
        bool AttLimits::isFixed() const

        """
        return _libBornAgainFit.AttLimits_isFixed(self)

    def isLimited(self):
        r"""
        isLimited(AttLimits self) -> bool
        bool AttLimits::isLimited() const

        """
        return _libBornAgainFit.AttLimits_isLimited(self)

    def isUpperLimited(self):
        r"""
        isUpperLimited(AttLimits self) -> bool
        bool AttLimits::isUpperLimited() const

        """
        return _libBornAgainFit.AttLimits_isUpperLimited(self)

    def isLowerLimited(self):
        r"""
        isLowerLimited(AttLimits self) -> bool
        bool AttLimits::isLowerLimited() const

        """
        return _libBornAgainFit.AttLimits_isLowerLimited(self)

    def isLimitless(self):
        r"""
        isLimitless(AttLimits self) -> bool
        bool AttLimits::isLimitless() const

        """
        return _libBornAgainFit.AttLimits_isLimitless(self)

    def lowerLimit(self):
        r"""
        lowerLimit(AttLimits self) -> double
        double AttLimits::lowerLimit() const

        """
        return _libBornAgainFit.AttLimits_lowerLimit(self)

    def upperLimit(self):
        r"""
        upperLimit(AttLimits self) -> double
        double AttLimits::upperLimit() const

        """
        return _libBornAgainFit.AttLimits_upperLimit(self)

    def setFixed(self, isFixed):
        r"""
        setFixed(AttLimits self, bool isFixed)
        void AttLimits::setFixed(bool isFixed)

        """
        return _libBornAgainFit.AttLimits_setFixed(self, isFixed)

    def __eq__(self, other):
        r"""__eq__(AttLimits self, AttLimits other) -> bool"""
        return _libBornAgainFit.AttLimits___eq__(self, other)

    def __ne__(self, other):
        r"""__ne__(AttLimits self, AttLimits other) -> bool"""
        return _libBornAgainFit.AttLimits___ne__(self, other)

    def toString(self):
        r"""
        toString(AttLimits self) -> std::string
        std::string AttLimits::toString() const

        """
        return _libBornAgainFit.AttLimits_toString(self)
    __swig_destroy__ = _libBornAgainFit.delete_AttLimits

# Register AttLimits in _libBornAgainFit:
_libBornAgainFit.AttLimits_swigregister(AttLimits)

def AttLimits_limitless():
    r"""AttLimits_limitless() -> AttLimits"""
    return _libBornAgainFit.AttLimits_limitless()

def AttLimits_lowerLimited(bound_value):
    r"""AttLimits_lowerLimited(double bound_value) -> AttLimits"""
    return _libBornAgainFit.AttLimits_lowerLimited(bound_value)

def AttLimits_positive():
    r"""AttLimits_positive() -> AttLimits"""
    return _libBornAgainFit.AttLimits_positive()

def AttLimits_nonnegative():
    r"""AttLimits_nonnegative() -> AttLimits"""
    return _libBornAgainFit.AttLimits_nonnegative()

def AttLimits_upperLimited(bound_value):
    r"""AttLimits_upperLimited(double bound_value) -> AttLimits"""
    return _libBornAgainFit.AttLimits_upperLimited(bound_value)

def AttLimits_limited(left_bound_value, right_bound_value):
    r"""AttLimits_limited(double left_bound_value, double right_bound_value) -> AttLimits"""
    return _libBornAgainFit.AttLimits_limited(left_bound_value, right_bound_value)

def AttLimits_fixed():
    r"""AttLimits_fixed() -> AttLimits"""
    return _libBornAgainFit.AttLimits_fixed()

class Parameter(object):
    r"""


    A fittable parameter with value, error, step, and limits.

    C++ includes: Parameter.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Parameter self) -> Parameter
        __init__(Parameter self, std::string const & name, double value, AttLimits limits=AttLimits::limitless(), double step=0.0) -> Parameter
        Parameter::Parameter(const std::string &name, double value, const AttLimits &limits=AttLimits::limitless(), double step=0.0)

        Fit parameter constructor.

        Parameters:
        -----------

        name: 
        unique name of fit parameters

        value: 
        starting value of fit parameter

        limits: 
        fit parameter limits

        step: 
        initial step of fit parameter during the minimization, will be calculated automatically, if zero. 

        """
        _libBornAgainFit.Parameter_swiginit(self, _libBornAgainFit.new_Parameter(*args))

    def name(self):
        r"""
        name(Parameter self) -> std::string
        std::string Parameter::name() const

        """
        return _libBornAgainFit.Parameter_name(self)

    def startValue(self):
        r"""
        startValue(Parameter self) -> double
        double Parameter::startValue() const

        """
        return _libBornAgainFit.Parameter_startValue(self)

    def limits(self):
        r"""
        limits(Parameter self) -> AttLimits
        AttLimits Parameter::limits() const

        """
        return _libBornAgainFit.Parameter_limits(self)

    def value(self):
        r"""
        value(Parameter self) -> double
        double Parameter::value() const

        """
        return _libBornAgainFit.Parameter_value(self)

    def setValue(self, value):
        r"""
        setValue(Parameter self, double value)
        void Parameter::setValue(double value)

        """
        return _libBornAgainFit.Parameter_setValue(self, value)

    def step(self):
        r"""
        step(Parameter self) -> double
        double Parameter::step() const

        """
        return _libBornAgainFit.Parameter_step(self)

    def error(self):
        r"""
        error(Parameter self) -> double
        double Parameter::error() const

        """
        return _libBornAgainFit.Parameter_error(self)

    def setError(self, value):
        r"""
        setError(Parameter self, double value)
        void Parameter::setError(double value)

        """
        return _libBornAgainFit.Parameter_setError(self, value)

    value = property(value, setValue)
    error = property(error, setError)



    __swig_destroy__ = _libBornAgainFit.delete_Parameter

# Register Parameter in _libBornAgainFit:
_libBornAgainFit.Parameter_swigregister(Parameter)

class Parameters(object):
    r"""


    A collection of fit parameters.

    C++ includes: Parameters.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(Parameters self) -> Parameters
        Fit::Parameters::Parameters()=default

        """
        _libBornAgainFit.Parameters_swiginit(self, _libBornAgainFit.new_Parameters())

    def add_cpp(self, par):
        r"""
        add_cpp(Parameters self, Parameter par)
        void Parameters::add(const Parameter &par)

        """
        return _libBornAgainFit.Parameters_add_cpp(self, par)

    def begin(self, *args):
        r"""
        begin(Parameters self) -> Fit::Parameters::const_iterator
        begin(Parameters self) -> Fit::Parameters::iterator
        iterator Fit::Parameters::begin()

        """
        return _libBornAgainFit.Parameters_begin(self, *args)

    def end(self, *args):
        r"""
        end(Parameters self) -> Fit::Parameters::const_iterator
        end(Parameters self) -> Fit::Parameters::iterator
        iterator Fit::Parameters::end()

        """
        return _libBornAgainFit.Parameters_end(self, *args)

    def size(self):
        r"""
        size(Parameters self) -> size_t
        size_t Parameters::size() const

        """
        return _libBornAgainFit.Parameters_size(self)

    def values(self):
        r"""
        values(Parameters self) -> vdouble1d_t
        std::vector< double > Parameters::values() const

        """
        return _libBornAgainFit.Parameters_values(self)

    def setValues(self, values):
        r"""
        setValues(Parameters self, vdouble1d_t values)
        void Parameters::setValues(const std::vector< double > &values)

        """
        return _libBornAgainFit.Parameters_setValues(self, values)

    def errors(self):
        r"""
        errors(Parameters self) -> vdouble1d_t
        std::vector< double > Parameters::errors() const

        """
        return _libBornAgainFit.Parameters_errors(self)

    def setErrors(self, errors):
        r"""
        setErrors(Parameters self, vdouble1d_t errors)
        void Parameters::setErrors(const std::vector< double > &errors)

        """
        return _libBornAgainFit.Parameters_setErrors(self, errors)

    def correlationMatrix(self):
        r"""
        correlationMatrix(Parameters self) -> vdouble2d_t
        Parameters::corr_matrix_t Parameters::correlationMatrix() const

        """
        return _libBornAgainFit.Parameters_correlationMatrix(self)

    def setCorrelationMatrix(self, matrix):
        r"""
        setCorrelationMatrix(Parameters self, vdouble2d_t matrix)
        void Parameters::setCorrelationMatrix(const corr_matrix_t &matrix)

        """
        return _libBornAgainFit.Parameters_setCorrelationMatrix(self, matrix)

    def freeParameterCount(self):
        r"""
        freeParameterCount(Parameters self) -> size_t
        size_t Parameters::freeParameterCount() const

        Returns number of free parameters. 

        """
        return _libBornAgainFit.Parameters_freeParameterCount(self)

    def __getitem__(self, *args):
        r"""
        __getitem__(Parameters self, std::string name) -> Parameter
        __getitem__(Parameters self, size_t index) -> Parameter
        """
        return _libBornAgainFit.Parameters___getitem__(self, *args)

    def __iter__(self):
        return ParametersIterator(self)


    def add(self, name, value=None, vary=True, min=-float('inf'), max=float('inf'), step=0.0):
        par = None
        if isinstance(name, Parameter):
            par = name
        else:
            limits = AttLimits.limitless()
            if min != -float('inf') and max != float('inf'):
                limits = AttLimits.limited(min, max)
            elif min != -float('inf') and max==float('inf'):
                limits = AttLimits.lowerLimited(min)
            elif min == -float('inf') and max != float('inf'):
                limits = AttLimits.upperLimited(max)
            if not vary:
                limits = AttLimits.fixed()
            par = Parameter(name, value, limits, step)

        self.add_cpp(par)


    __swig_destroy__ = _libBornAgainFit.delete_Parameters

# Register Parameters in _libBornAgainFit:
_libBornAgainFit.Parameters_swigregister(Parameters)

class PyCallback(object):
    r"""


    Base class to wrap Python callable and pass it to C++. Used in swig interface file, intended to be overloaded from Python.

    C++ includes: PyCallback.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    SCALAR = _libBornAgainFit.PyCallback_SCALAR
    
    RESIDUAL = _libBornAgainFit.PyCallback_RESIDUAL
    

    def __init__(self, *args):
        r"""
        __init__(PyCallback self, PyCallback::CallbackType callback_type=SCALAR) -> PyCallback
        PyCallback::PyCallback(CallbackType callback_type=SCALAR)

        """
        if self.__class__ == PyCallback:
            _self = None
        else:
            _self = self
        _libBornAgainFit.PyCallback_swiginit(self, _libBornAgainFit.new_PyCallback(_self, *args))
    __swig_destroy__ = _libBornAgainFit.delete_PyCallback

    def callback_type(self):
        r"""
        callback_type(PyCallback self) -> PyCallback::CallbackType
        PyCallback::CallbackType PyCallback::callback_type() const

        """
        return _libBornAgainFit.PyCallback_callback_type(self)

    def call_scalar(self, pars):
        r"""
        call_scalar(PyCallback self, Parameters pars) -> double
        double PyCallback::call_scalar(Fit::Parameters pars)

        Call Python callable and returns its result. Intended to be overloaded in Python.

        Parameters:
        -----------

        pars: 
         Fit parameters object (intentionally passed by value).

        value of objective function. 

        """
        return _libBornAgainFit.PyCallback_call_scalar(self, pars)

    def call_residuals(self, arg0):
        r"""
        call_residuals(PyCallback self, Parameters arg0) -> vdouble1d_t
        std::vector< double > PyCallback::call_residuals(Fit::Parameters)

        Call Python callable and returns its result. Intended to be overloaded in Python.

        Parameters:
        -----------

        pars: 
         Fit parameters object (intentionally passed by value).

        vector of residuals 

        """
        return _libBornAgainFit.PyCallback_call_residuals(self, arg0)
    def __disown__(self):
        self.this.disown()
        _libBornAgainFit.disown_PyCallback(self)
        return weakref.proxy(self)

# Register PyCallback in _libBornAgainFit:
_libBornAgainFit.PyCallback_swigregister(PyCallback)

class MinimizerResult(object):
    r"""


    Result of minimization round.

    C++ includes: MinimizerResult.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(MinimizerResult self) -> MinimizerResult
        MinimizerResult::MinimizerResult()

        """
        _libBornAgainFit.MinimizerResult_swiginit(self, _libBornAgainFit.new_MinimizerResult())

    def setParameters(self, parameters):
        r"""
        setParameters(MinimizerResult self, Parameters parameters)
        void MinimizerResult::setParameters(const Parameters &parameters)

        """
        return _libBornAgainFit.MinimizerResult_setParameters(self, parameters)

    def parameters(self):
        r"""
        parameters(MinimizerResult self) -> Parameters
        Parameters MinimizerResult::parameters() const

        """
        return _libBornAgainFit.MinimizerResult_parameters(self)

    def setMinValue(self, value):
        r"""
        setMinValue(MinimizerResult self, double value)
        void MinimizerResult::setMinValue(double value)

        """
        return _libBornAgainFit.MinimizerResult_setMinValue(self, value)

    def minValue(self):
        r"""
        minValue(MinimizerResult self) -> double
        double MinimizerResult::minValue() const

        Minimum value of objective function found by minimizer. 

        """
        return _libBornAgainFit.MinimizerResult_minValue(self)

    def toString(self):
        r"""
        toString(MinimizerResult self) -> std::string
        std::string MinimizerResult::toString() const

        Returns multi-line string representing minimization results. 

        """
        return _libBornAgainFit.MinimizerResult_toString(self)

    def setReport(self, value):
        r"""
        setReport(MinimizerResult self, std::string const & value)
        void MinimizerResult::setReport(const std::string &value)

        """
        return _libBornAgainFit.MinimizerResult_setReport(self, value)

    def setDuration(self, value):
        r"""
        setDuration(MinimizerResult self, double value)
        void MinimizerResult::setDuration(double value)

        """
        return _libBornAgainFit.MinimizerResult_setDuration(self, value)

    def setNumberOfCalls(self, value):
        r"""
        setNumberOfCalls(MinimizerResult self, int value)
        void MinimizerResult::setNumberOfCalls(int value)

        """
        return _libBornAgainFit.MinimizerResult_setNumberOfCalls(self, value)

    def setNumberOfGradientCalls(self, value):
        r"""
        setNumberOfGradientCalls(MinimizerResult self, int value)
        void MinimizerResult::setNumberOfGradientCalls(int value)

        """
        return _libBornAgainFit.MinimizerResult_setNumberOfGradientCalls(self, value)
    __swig_destroy__ = _libBornAgainFit.delete_MinimizerResult

# Register MinimizerResult in _libBornAgainFit:
_libBornAgainFit.MinimizerResult_swigregister(MinimizerResult)

class Minimizer(object):
    r"""


    A main class to run fitting.

    C++ includes: Minimizer.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(Minimizer self) -> Minimizer
        Minimizer::Minimizer()

        """
        _libBornAgainFit.Minimizer_swiginit(self, _libBornAgainFit.new_Minimizer())
    __swig_destroy__ = _libBornAgainFit.delete_Minimizer

    def setMinimizer(self, *args):
        r"""
        setMinimizer(Minimizer self, std::string const & minimizerName, std::string const & algorithmName="", std::string const & options="")
        setMinimizer(Minimizer self, IMinimizer minimizer)
        void Minimizer::setMinimizer(IMinimizer *minimizer)

        """
        return _libBornAgainFit.Minimizer_setMinimizer(self, *args)

    def minimize_cpp(self, callback, parameters):
        r"""
        minimize_cpp(Minimizer self, PyCallback callback, Parameters parameters) -> MinimizerResult
        MinimizerResult Minimizer::minimize(PyCallback &callback, const Parameters &parameters)

        Finds minimum of user objective function (to be called from Python). 

        """
        return _libBornAgainFit.Minimizer_minimize_cpp(self, callback, parameters)

    def minimize(self, callback, pars):
        if not callable(callback):
            raise Exception("Not a Python callable")

    # single call to callback to check return type
        result = callback(pars)

        if isinstance(result, float):
            wrp = CallableWrapper(callback, PyCallback.SCALAR)
            return self.minimize_cpp(wrp, pars)
        elif hasattr(result, '__len__'):
            wrp = CallableWrapper(callback, PyCallback.RESIDUAL)
            return self.minimize_cpp(wrp, pars)
        else:
            raise Exception("Wrong callable type")



# Register Minimizer in _libBornAgainFit:
_libBornAgainFit.Minimizer_swigregister(Minimizer)

class IMinimizer(object):
    r"""


    Pure virtual interface for all kind minimizers.

    C++ includes: IMinimizer.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainFit.delete_IMinimizer

    def minimizerName(self):
        r"""
        minimizerName(IMinimizer self) -> std::string
        virtual std::string IMinimizer::minimizerName() const =0

        return name of the minimizer 

        """
        return _libBornAgainFit.IMinimizer_minimizerName(self)

    def algorithmName(self):
        r"""
        algorithmName(IMinimizer self) -> std::string
        virtual std::string IMinimizer::algorithmName() const =0

        return name of the minimization algorithm 

        """
        return _libBornAgainFit.IMinimizer_algorithmName(self)

    def minimize_scalar(self, arg2, arg3):
        r"""
        minimize_scalar(IMinimizer self, fcn_scalar_t arg2, Parameters arg3) -> MinimizerResult
        Fit::MinimizerResult IMinimizer::minimize_scalar(fcn_scalar_t, Fit::Parameters)

        run minimization 

        """
        return _libBornAgainFit.IMinimizer_minimize_scalar(self, arg2, arg3)

    def minimize_residual(self, arg2, arg3):
        r"""
        minimize_residual(IMinimizer self, fcn_residual_t arg2, Parameters arg3) -> MinimizerResult
        Fit::MinimizerResult IMinimizer::minimize_residual(fcn_residual_t, Fit::Parameters)

        """
        return _libBornAgainFit.IMinimizer_minimize_residual(self, arg2, arg3)

    def clear(self):
        r"""
        clear(IMinimizer self)
        virtual void IMinimizer::clear()

        clear resources (parameters) for consecutives minimizations 

        """
        return _libBornAgainFit.IMinimizer_clear(self)

    def minValue(self):
        r"""
        minValue(IMinimizer self) -> double
        double IMinimizer::minValue() const

        Returns minimum function value. 

        """
        return _libBornAgainFit.IMinimizer_minValue(self)

    def setOptions(self, options):
        r"""
        setOptions(IMinimizer self, std::string const & options)
        void IMinimizer::setOptions(const std::string &options)

        Sets option string to the minimizer. 

        """
        return _libBornAgainFit.IMinimizer_setOptions(self, options)

# Register IMinimizer in _libBornAgainFit:
_libBornAgainFit.IMinimizer_swigregister(IMinimizer)

class MinimizerCatalogue(object):
    r"""


    Hard-coded information about all minimizers available.

    C++ includes: MinimizerCatalogue.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(MinimizerCatalogue self) -> MinimizerCatalogue
        MinimizerCatalogue::MinimizerCatalogue()

        """
        _libBornAgainFit.MinimizerCatalogue_swiginit(self, _libBornAgainFit.new_MinimizerCatalogue())

    def toString(self):
        r"""
        toString(MinimizerCatalogue self) -> std::string
        std::string MinimizerCatalogue::toString() const

        Returns multiline string representing catalogue content. 

        """
        return _libBornAgainFit.MinimizerCatalogue_toString(self)

    def minimizerNames(self):
        r"""
        minimizerNames(MinimizerCatalogue self) -> vector_string_t
        std::vector< std::string > MinimizerCatalogue::minimizerNames() const

        """
        return _libBornAgainFit.MinimizerCatalogue_minimizerNames(self)

    def algorithmNames(self, minimizerName):
        r"""
        algorithmNames(MinimizerCatalogue self, std::string const & minimizerName) -> vector_string_t
        std::vector< std::string > MinimizerCatalogue::algorithmNames(const std::string &minimizerName) const

        Returns list of algorithms defined for the minimizer with a given name. 

        """
        return _libBornAgainFit.MinimizerCatalogue_algorithmNames(self, minimizerName)

    def algorithmDescriptions(self, minimizerName):
        r"""
        algorithmDescriptions(MinimizerCatalogue self, std::string const & minimizerName) -> vector_string_t
        std::vector< std::string > MinimizerCatalogue::algorithmDescriptions(const std::string &minimizerName) const

        Returns list of algorithm's descriptions for the minimizer with a given name . 

        """
        return _libBornAgainFit.MinimizerCatalogue_algorithmDescriptions(self, minimizerName)

    def minimizerInfo(self, minimizerName):
        r"""
        minimizerInfo(MinimizerCatalogue self, std::string const & minimizerName) -> MinimizerInfo const &
        const MinimizerInfo & MinimizerCatalogue::minimizerInfo(const std::string &minimizerName) const

        Returns info for minimizer with given name. 

        """
        return _libBornAgainFit.MinimizerCatalogue_minimizerInfo(self, minimizerName)
    __swig_destroy__ = _libBornAgainFit.delete_MinimizerCatalogue

# Register MinimizerCatalogue in _libBornAgainFit:
_libBornAgainFit.MinimizerCatalogue_swigregister(MinimizerCatalogue)

class MinimizerFactory(object):
    r"""


    Factory to create minimizers.

    C++ includes: MinimizerFactory.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def createMinimizer(*args):
        r"""createMinimizer(std::string const & minimizerName, std::string const & algorithmType="", std::string const & optionString="") -> IMinimizer"""
        return _libBornAgainFit.MinimizerFactory_createMinimizer(*args)

    @staticmethod
    def printCatalogue():
        r"""printCatalogue()"""
        return _libBornAgainFit.MinimizerFactory_printCatalogue()

    @staticmethod
    def catalogueToString():
        r"""catalogueToString() -> std::string"""
        return _libBornAgainFit.MinimizerFactory_catalogueToString()

    @staticmethod
    def catalogueDetailsToString():
        r"""catalogueDetailsToString() -> std::string"""
        return _libBornAgainFit.MinimizerFactory_catalogueDetailsToString()

    @staticmethod
    def catalogue():
        r"""catalogue() -> MinimizerCatalogue"""
        return _libBornAgainFit.MinimizerFactory_catalogue()

    def __init__(self):
        r"""
        __init__(MinimizerFactory self) -> MinimizerFactory


        Factory to create minimizers.

        C++ includes: MinimizerFactory.h

        """
        _libBornAgainFit.MinimizerFactory_swiginit(self, _libBornAgainFit.new_MinimizerFactory())
    __swig_destroy__ = _libBornAgainFit.delete_MinimizerFactory

# Register MinimizerFactory in _libBornAgainFit:
_libBornAgainFit.MinimizerFactory_swigregister(MinimizerFactory)

def MinimizerFactory_createMinimizer(*args):
    r"""MinimizerFactory_createMinimizer(std::string const & minimizerName, std::string const & algorithmType="", std::string const & optionString="") -> IMinimizer"""
    return _libBornAgainFit.MinimizerFactory_createMinimizer(*args)

def MinimizerFactory_printCatalogue():
    r"""MinimizerFactory_printCatalogue()"""
    return _libBornAgainFit.MinimizerFactory_printCatalogue()

def MinimizerFactory_catalogueToString():
    r"""MinimizerFactory_catalogueToString() -> std::string"""
    return _libBornAgainFit.MinimizerFactory_catalogueToString()

def MinimizerFactory_catalogueDetailsToString():
    r"""MinimizerFactory_catalogueDetailsToString() -> std::string"""
    return _libBornAgainFit.MinimizerFactory_catalogueDetailsToString()

def MinimizerFactory_catalogue():
    r"""MinimizerFactory_catalogue() -> MinimizerCatalogue"""
    return _libBornAgainFit.MinimizerFactory_catalogue()


class ParametersIterator(object):

    def __init__(self, parameters):
        self.parameters = parameters
        self.index = -1

    def __iter__(self):
        return self

    def next(self):
        self.index += 1
        if self.index < self.parameters.size():
            return self.parameters[self.index]
        else:
            raise StopIteration

    def __next__(self):
        return self.next()


class CallableWrapper(PyCallback):
    def __init__(self, f, callable_type):
        super(CallableWrapper, self).__init__(callable_type)
        self.f_ = f
    def call_scalar(self, obj):
        return self.f_(obj)
    def call_residuals(self, obj):
        return self.f_(obj)



