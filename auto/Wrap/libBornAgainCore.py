# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_libBornAgainCore', [dirname(__file__)])
        except ImportError:
            import _libBornAgainCore
            return _libBornAgainCore
        if fp is not None:
            try:
                _mod = imp.load_module('_libBornAgainCore', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _libBornAgainCore = swig_import_helper()
    del swig_import_helper
else:
    import _libBornAgainCore
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        """value(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainCore.SwigPyIterator_value(self)


    def incr(self, n=1):
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _libBornAgainCore.SwigPyIterator_incr(self, n)


    def decr(self, n=1):
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _libBornAgainCore.SwigPyIterator_decr(self, n)


    def distance(self, x):
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _libBornAgainCore.SwigPyIterator_distance(self, x)


    def equal(self, x):
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _libBornAgainCore.SwigPyIterator_equal(self, x)


    def copy(self):
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _libBornAgainCore.SwigPyIterator_copy(self)


    def next(self):
        """next(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainCore.SwigPyIterator_next(self)


    def __next__(self):
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainCore.SwigPyIterator___next__(self)


    def previous(self):
        """previous(SwigPyIterator self) -> PyObject *"""
        return _libBornAgainCore.SwigPyIterator_previous(self)


    def advance(self, n):
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainCore.SwigPyIterator_advance(self, n)


    def __eq__(self, x):
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _libBornAgainCore.SwigPyIterator___eq__(self, x)


    def __ne__(self, x):
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _libBornAgainCore.SwigPyIterator___ne__(self, x)


    def __iadd__(self, n):
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainCore.SwigPyIterator___iadd__(self, n)


    def __isub__(self, n):
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainCore.SwigPyIterator___isub__(self, n)


    def __add__(self, n):
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _libBornAgainCore.SwigPyIterator___add__(self, n)


    def __sub__(self, *args):
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _libBornAgainCore.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self
SwigPyIterator_swigregister = _libBornAgainCore.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


_libBornAgainCore.SHARED_PTR_DISOWN_swigconstant(_libBornAgainCore)
SHARED_PTR_DISOWN = _libBornAgainCore.SHARED_PTR_DISOWN
class vdouble1d_t(_object):
    """Proxy of C++ std::vector<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vdouble1d_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vdouble1d_t, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vdouble1d_t self) -> SwigPyIterator"""
        return _libBornAgainCore.vdouble1d_t_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vdouble1d_t self) -> bool"""
        return _libBornAgainCore.vdouble1d_t___nonzero__(self)


    def __bool__(self):
        """__bool__(vdouble1d_t self) -> bool"""
        return _libBornAgainCore.vdouble1d_t___bool__(self)


    def __len__(self):
        """__len__(vdouble1d_t self) -> std::vector< double >::size_type"""
        return _libBornAgainCore.vdouble1d_t___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> vdouble1d_t"""
        return _libBornAgainCore.vdouble1d_t___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, vdouble1d_t v)
        """
        return _libBornAgainCore.vdouble1d_t___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _libBornAgainCore.vdouble1d_t___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vdouble1d_t self, std::vector< double >::difference_type i)
        __delitem__(vdouble1d_t self, PySliceObject * slice)
        """
        return _libBornAgainCore.vdouble1d_t___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vdouble1d_t self, PySliceObject * slice) -> vdouble1d_t
        __getitem__(vdouble1d_t self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _libBornAgainCore.vdouble1d_t___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vdouble1d_t self, PySliceObject * slice, vdouble1d_t v)
        __setitem__(vdouble1d_t self, PySliceObject * slice)
        __setitem__(vdouble1d_t self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _libBornAgainCore.vdouble1d_t___setitem__(self, *args)


    def pop(self):
        """pop(vdouble1d_t self) -> std::vector< double >::value_type"""
        return _libBornAgainCore.vdouble1d_t_pop(self)


    def append(self, x):
        """append(vdouble1d_t self, std::vector< double >::value_type const & x)"""
        return _libBornAgainCore.vdouble1d_t_append(self, x)


    def empty(self):
        """empty(vdouble1d_t self) -> bool"""
        return _libBornAgainCore.vdouble1d_t_empty(self)


    def size(self):
        """size(vdouble1d_t self) -> std::vector< double >::size_type"""
        return _libBornAgainCore.vdouble1d_t_size(self)


    def swap(self, v):
        """
        swap(vdouble1d_t self, vdouble1d_t v)

        void swap(OutputDataIterator< TValue, TContainer > &left, OutputDataIterator< TValue, TContainer > &right)

        make Swappable 

        """
        return _libBornAgainCore.vdouble1d_t_swap(self, v)


    def begin(self):
        """begin(vdouble1d_t self) -> std::vector< double >::iterator"""
        return _libBornAgainCore.vdouble1d_t_begin(self)


    def end(self):
        """end(vdouble1d_t self) -> std::vector< double >::iterator"""
        return _libBornAgainCore.vdouble1d_t_end(self)


    def rbegin(self):
        """rbegin(vdouble1d_t self) -> std::vector< double >::reverse_iterator"""
        return _libBornAgainCore.vdouble1d_t_rbegin(self)


    def rend(self):
        """rend(vdouble1d_t self) -> std::vector< double >::reverse_iterator"""
        return _libBornAgainCore.vdouble1d_t_rend(self)


    def clear(self):
        """clear(vdouble1d_t self)"""
        return _libBornAgainCore.vdouble1d_t_clear(self)


    def get_allocator(self):
        """get_allocator(vdouble1d_t self) -> std::vector< double >::allocator_type"""
        return _libBornAgainCore.vdouble1d_t_get_allocator(self)


    def pop_back(self):
        """pop_back(vdouble1d_t self)"""
        return _libBornAgainCore.vdouble1d_t_pop_back(self)


    def erase(self, *args):
        """
        erase(vdouble1d_t self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(vdouble1d_t self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _libBornAgainCore.vdouble1d_t_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(double)> self) -> vdouble1d_t
        __init__(std::vector<(double)> self, vdouble1d_t arg2) -> vdouble1d_t
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> vdouble1d_t
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> vdouble1d_t
        """
        this = _libBornAgainCore.new_vdouble1d_t(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vdouble1d_t self, std::vector< double >::value_type const & x)"""
        return _libBornAgainCore.vdouble1d_t_push_back(self, x)


    def front(self):
        """front(vdouble1d_t self) -> std::vector< double >::value_type const &"""
        return _libBornAgainCore.vdouble1d_t_front(self)


    def back(self):
        """back(vdouble1d_t self) -> std::vector< double >::value_type const &"""
        return _libBornAgainCore.vdouble1d_t_back(self)


    def assign(self, n, x):
        """assign(vdouble1d_t self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _libBornAgainCore.vdouble1d_t_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vdouble1d_t self, std::vector< double >::size_type new_size)
        resize(vdouble1d_t self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _libBornAgainCore.vdouble1d_t_resize(self, *args)


    def insert(self, *args):
        """
        insert(vdouble1d_t self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(vdouble1d_t self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _libBornAgainCore.vdouble1d_t_insert(self, *args)


    def reserve(self, n):
        """reserve(vdouble1d_t self, std::vector< double >::size_type n)"""
        return _libBornAgainCore.vdouble1d_t_reserve(self, n)


    def capacity(self):
        """capacity(vdouble1d_t self) -> std::vector< double >::size_type"""
        return _libBornAgainCore.vdouble1d_t_capacity(self)

    __swig_destroy__ = _libBornAgainCore.delete_vdouble1d_t
    __del__ = lambda self: None
vdouble1d_t_swigregister = _libBornAgainCore.vdouble1d_t_swigregister
vdouble1d_t_swigregister(vdouble1d_t)

class vdouble2d_t(_object):
    """Proxy of C++ std::vector<(std::vector<(double)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vdouble2d_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vdouble2d_t, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vdouble2d_t self) -> SwigPyIterator"""
        return _libBornAgainCore.vdouble2d_t_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vdouble2d_t self) -> bool"""
        return _libBornAgainCore.vdouble2d_t___nonzero__(self)


    def __bool__(self):
        """__bool__(vdouble2d_t self) -> bool"""
        return _libBornAgainCore.vdouble2d_t___bool__(self)


    def __len__(self):
        """__len__(vdouble2d_t self) -> std::vector< std::vector< double > >::size_type"""
        return _libBornAgainCore.vdouble2d_t___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j) -> vdouble2d_t"""
        return _libBornAgainCore.vdouble2d_t___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)
        __setslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j, vdouble2d_t v)
        """
        return _libBornAgainCore.vdouble2d_t___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)"""
        return _libBornAgainCore.vdouble2d_t___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i)
        __delitem__(vdouble2d_t self, PySliceObject * slice)
        """
        return _libBornAgainCore.vdouble2d_t___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vdouble2d_t self, PySliceObject * slice) -> vdouble2d_t
        __getitem__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i) -> vdouble1d_t
        """
        return _libBornAgainCore.vdouble2d_t___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vdouble2d_t self, PySliceObject * slice, vdouble2d_t v)
        __setitem__(vdouble2d_t self, PySliceObject * slice)
        __setitem__(vdouble2d_t self, std::vector< std::vector< double > >::difference_type i, vdouble1d_t x)
        """
        return _libBornAgainCore.vdouble2d_t___setitem__(self, *args)


    def pop(self):
        """pop(vdouble2d_t self) -> vdouble1d_t"""
        return _libBornAgainCore.vdouble2d_t_pop(self)


    def append(self, x):
        """append(vdouble2d_t self, vdouble1d_t x)"""
        return _libBornAgainCore.vdouble2d_t_append(self, x)


    def empty(self):
        """empty(vdouble2d_t self) -> bool"""
        return _libBornAgainCore.vdouble2d_t_empty(self)


    def size(self):
        """size(vdouble2d_t self) -> std::vector< std::vector< double > >::size_type"""
        return _libBornAgainCore.vdouble2d_t_size(self)


    def swap(self, v):
        """
        swap(vdouble2d_t self, vdouble2d_t v)

        void swap(OutputDataIterator< TValue, TContainer > &left, OutputDataIterator< TValue, TContainer > &right)

        make Swappable 

        """
        return _libBornAgainCore.vdouble2d_t_swap(self, v)


    def begin(self):
        """begin(vdouble2d_t self) -> std::vector< std::vector< double > >::iterator"""
        return _libBornAgainCore.vdouble2d_t_begin(self)


    def end(self):
        """end(vdouble2d_t self) -> std::vector< std::vector< double > >::iterator"""
        return _libBornAgainCore.vdouble2d_t_end(self)


    def rbegin(self):
        """rbegin(vdouble2d_t self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _libBornAgainCore.vdouble2d_t_rbegin(self)


    def rend(self):
        """rend(vdouble2d_t self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _libBornAgainCore.vdouble2d_t_rend(self)


    def clear(self):
        """clear(vdouble2d_t self)"""
        return _libBornAgainCore.vdouble2d_t_clear(self)


    def get_allocator(self):
        """get_allocator(vdouble2d_t self) -> std::vector< std::vector< double > >::allocator_type"""
        return _libBornAgainCore.vdouble2d_t_get_allocator(self)


    def pop_back(self):
        """pop_back(vdouble2d_t self)"""
        return _libBornAgainCore.vdouble2d_t_pop_back(self)


    def erase(self, *args):
        """
        erase(vdouble2d_t self, std::vector< std::vector< double > >::iterator pos) -> std::vector< std::vector< double > >::iterator
        erase(vdouble2d_t self, std::vector< std::vector< double > >::iterator first, std::vector< std::vector< double > >::iterator last) -> std::vector< std::vector< double > >::iterator
        """
        return _libBornAgainCore.vdouble2d_t_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(double)>)> self) -> vdouble2d_t
        __init__(std::vector<(std::vector<(double)>)> self, vdouble2d_t arg2) -> vdouble2d_t
        __init__(std::vector<(std::vector<(double)>)> self, std::vector< std::vector< double > >::size_type size) -> vdouble2d_t
        __init__(std::vector<(std::vector<(double)>)> self, std::vector< std::vector< double > >::size_type size, vdouble1d_t value) -> vdouble2d_t
        """
        this = _libBornAgainCore.new_vdouble2d_t(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vdouble2d_t self, vdouble1d_t x)"""
        return _libBornAgainCore.vdouble2d_t_push_back(self, x)


    def front(self):
        """front(vdouble2d_t self) -> vdouble1d_t"""
        return _libBornAgainCore.vdouble2d_t_front(self)


    def back(self):
        """back(vdouble2d_t self) -> vdouble1d_t"""
        return _libBornAgainCore.vdouble2d_t_back(self)


    def assign(self, n, x):
        """assign(vdouble2d_t self, std::vector< std::vector< double > >::size_type n, vdouble1d_t x)"""
        return _libBornAgainCore.vdouble2d_t_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vdouble2d_t self, std::vector< std::vector< double > >::size_type new_size)
        resize(vdouble2d_t self, std::vector< std::vector< double > >::size_type new_size, vdouble1d_t x)
        """
        return _libBornAgainCore.vdouble2d_t_resize(self, *args)


    def insert(self, *args):
        """
        insert(vdouble2d_t self, std::vector< std::vector< double > >::iterator pos, vdouble1d_t x) -> std::vector< std::vector< double > >::iterator
        insert(vdouble2d_t self, std::vector< std::vector< double > >::iterator pos, std::vector< std::vector< double > >::size_type n, vdouble1d_t x)
        """
        return _libBornAgainCore.vdouble2d_t_insert(self, *args)


    def reserve(self, n):
        """reserve(vdouble2d_t self, std::vector< std::vector< double > >::size_type n)"""
        return _libBornAgainCore.vdouble2d_t_reserve(self, n)


    def capacity(self):
        """capacity(vdouble2d_t self) -> std::vector< std::vector< double > >::size_type"""
        return _libBornAgainCore.vdouble2d_t_capacity(self)

    __swig_destroy__ = _libBornAgainCore.delete_vdouble2d_t
    __del__ = lambda self: None
vdouble2d_t_swigregister = _libBornAgainCore.vdouble2d_t_swigregister
vdouble2d_t_swigregister(vdouble2d_t)

class vector_integer_t(_object):
    """Proxy of C++ std::vector<(int)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_integer_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_integer_t, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vector_integer_t self) -> SwigPyIterator"""
        return _libBornAgainCore.vector_integer_t_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vector_integer_t self) -> bool"""
        return _libBornAgainCore.vector_integer_t___nonzero__(self)


    def __bool__(self):
        """__bool__(vector_integer_t self) -> bool"""
        return _libBornAgainCore.vector_integer_t___bool__(self)


    def __len__(self):
        """__len__(vector_integer_t self) -> std::vector< int >::size_type"""
        return _libBornAgainCore.vector_integer_t___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> vector_integer_t"""
        return _libBornAgainCore.vector_integer_t___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        __setslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, vector_integer_t v)
        """
        return _libBornAgainCore.vector_integer_t___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _libBornAgainCore.vector_integer_t___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vector_integer_t self, std::vector< int >::difference_type i)
        __delitem__(vector_integer_t self, PySliceObject * slice)
        """
        return _libBornAgainCore.vector_integer_t___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vector_integer_t self, PySliceObject * slice) -> vector_integer_t
        __getitem__(vector_integer_t self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _libBornAgainCore.vector_integer_t___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vector_integer_t self, PySliceObject * slice, vector_integer_t v)
        __setitem__(vector_integer_t self, PySliceObject * slice)
        __setitem__(vector_integer_t self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _libBornAgainCore.vector_integer_t___setitem__(self, *args)


    def pop(self):
        """pop(vector_integer_t self) -> std::vector< int >::value_type"""
        return _libBornAgainCore.vector_integer_t_pop(self)


    def append(self, x):
        """append(vector_integer_t self, std::vector< int >::value_type const & x)"""
        return _libBornAgainCore.vector_integer_t_append(self, x)


    def empty(self):
        """empty(vector_integer_t self) -> bool"""
        return _libBornAgainCore.vector_integer_t_empty(self)


    def size(self):
        """size(vector_integer_t self) -> std::vector< int >::size_type"""
        return _libBornAgainCore.vector_integer_t_size(self)


    def swap(self, v):
        """
        swap(vector_integer_t self, vector_integer_t v)

        void swap(OutputDataIterator< TValue, TContainer > &left, OutputDataIterator< TValue, TContainer > &right)

        make Swappable 

        """
        return _libBornAgainCore.vector_integer_t_swap(self, v)


    def begin(self):
        """begin(vector_integer_t self) -> std::vector< int >::iterator"""
        return _libBornAgainCore.vector_integer_t_begin(self)


    def end(self):
        """end(vector_integer_t self) -> std::vector< int >::iterator"""
        return _libBornAgainCore.vector_integer_t_end(self)


    def rbegin(self):
        """rbegin(vector_integer_t self) -> std::vector< int >::reverse_iterator"""
        return _libBornAgainCore.vector_integer_t_rbegin(self)


    def rend(self):
        """rend(vector_integer_t self) -> std::vector< int >::reverse_iterator"""
        return _libBornAgainCore.vector_integer_t_rend(self)


    def clear(self):
        """clear(vector_integer_t self)"""
        return _libBornAgainCore.vector_integer_t_clear(self)


    def get_allocator(self):
        """get_allocator(vector_integer_t self) -> std::vector< int >::allocator_type"""
        return _libBornAgainCore.vector_integer_t_get_allocator(self)


    def pop_back(self):
        """pop_back(vector_integer_t self)"""
        return _libBornAgainCore.vector_integer_t_pop_back(self)


    def erase(self, *args):
        """
        erase(vector_integer_t self, std::vector< int >::iterator pos) -> std::vector< int >::iterator
        erase(vector_integer_t self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator
        """
        return _libBornAgainCore.vector_integer_t_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(int)> self) -> vector_integer_t
        __init__(std::vector<(int)> self, vector_integer_t arg2) -> vector_integer_t
        __init__(std::vector<(int)> self, std::vector< int >::size_type size) -> vector_integer_t
        __init__(std::vector<(int)> self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> vector_integer_t
        """
        this = _libBornAgainCore.new_vector_integer_t(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vector_integer_t self, std::vector< int >::value_type const & x)"""
        return _libBornAgainCore.vector_integer_t_push_back(self, x)


    def front(self):
        """front(vector_integer_t self) -> std::vector< int >::value_type const &"""
        return _libBornAgainCore.vector_integer_t_front(self)


    def back(self):
        """back(vector_integer_t self) -> std::vector< int >::value_type const &"""
        return _libBornAgainCore.vector_integer_t_back(self)


    def assign(self, n, x):
        """assign(vector_integer_t self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)"""
        return _libBornAgainCore.vector_integer_t_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vector_integer_t self, std::vector< int >::size_type new_size)
        resize(vector_integer_t self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)
        """
        return _libBornAgainCore.vector_integer_t_resize(self, *args)


    def insert(self, *args):
        """
        insert(vector_integer_t self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator
        insert(vector_integer_t self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)
        """
        return _libBornAgainCore.vector_integer_t_insert(self, *args)


    def reserve(self, n):
        """reserve(vector_integer_t self, std::vector< int >::size_type n)"""
        return _libBornAgainCore.vector_integer_t_reserve(self, n)


    def capacity(self):
        """capacity(vector_integer_t self) -> std::vector< int >::size_type"""
        return _libBornAgainCore.vector_integer_t_capacity(self)

    __swig_destroy__ = _libBornAgainCore.delete_vector_integer_t
    __del__ = lambda self: None
vector_integer_t_swigregister = _libBornAgainCore.vector_integer_t_swigregister
vector_integer_t_swigregister(vector_integer_t)

class vector_longinteger_t(_object):
    """Proxy of C++ std::vector<(unsigned long)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_longinteger_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_longinteger_t, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vector_longinteger_t self) -> SwigPyIterator"""
        return _libBornAgainCore.vector_longinteger_t_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vector_longinteger_t self) -> bool"""
        return _libBornAgainCore.vector_longinteger_t___nonzero__(self)


    def __bool__(self):
        """__bool__(vector_longinteger_t self) -> bool"""
        return _libBornAgainCore.vector_longinteger_t___bool__(self)


    def __len__(self):
        """__len__(vector_longinteger_t self) -> std::vector< unsigned long >::size_type"""
        return _libBornAgainCore.vector_longinteger_t___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j) -> vector_longinteger_t"""
        return _libBornAgainCore.vector_longinteger_t___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)
        __setslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j, vector_longinteger_t v)
        """
        return _libBornAgainCore.vector_longinteger_t___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)"""
        return _libBornAgainCore.vector_longinteger_t___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i)
        __delitem__(vector_longinteger_t self, PySliceObject * slice)
        """
        return _libBornAgainCore.vector_longinteger_t___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vector_longinteger_t self, PySliceObject * slice) -> vector_longinteger_t
        __getitem__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i) -> std::vector< unsigned long >::value_type const &
        """
        return _libBornAgainCore.vector_longinteger_t___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vector_longinteger_t self, PySliceObject * slice, vector_longinteger_t v)
        __setitem__(vector_longinteger_t self, PySliceObject * slice)
        __setitem__(vector_longinteger_t self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::value_type const & x)
        """
        return _libBornAgainCore.vector_longinteger_t___setitem__(self, *args)


    def pop(self):
        """pop(vector_longinteger_t self) -> std::vector< unsigned long >::value_type"""
        return _libBornAgainCore.vector_longinteger_t_pop(self)


    def append(self, x):
        """append(vector_longinteger_t self, std::vector< unsigned long >::value_type const & x)"""
        return _libBornAgainCore.vector_longinteger_t_append(self, x)


    def empty(self):
        """empty(vector_longinteger_t self) -> bool"""
        return _libBornAgainCore.vector_longinteger_t_empty(self)


    def size(self):
        """size(vector_longinteger_t self) -> std::vector< unsigned long >::size_type"""
        return _libBornAgainCore.vector_longinteger_t_size(self)


    def swap(self, v):
        """
        swap(vector_longinteger_t self, vector_longinteger_t v)

        void swap(OutputDataIterator< TValue, TContainer > &left, OutputDataIterator< TValue, TContainer > &right)

        make Swappable 

        """
        return _libBornAgainCore.vector_longinteger_t_swap(self, v)


    def begin(self):
        """begin(vector_longinteger_t self) -> std::vector< unsigned long >::iterator"""
        return _libBornAgainCore.vector_longinteger_t_begin(self)


    def end(self):
        """end(vector_longinteger_t self) -> std::vector< unsigned long >::iterator"""
        return _libBornAgainCore.vector_longinteger_t_end(self)


    def rbegin(self):
        """rbegin(vector_longinteger_t self) -> std::vector< unsigned long >::reverse_iterator"""
        return _libBornAgainCore.vector_longinteger_t_rbegin(self)


    def rend(self):
        """rend(vector_longinteger_t self) -> std::vector< unsigned long >::reverse_iterator"""
        return _libBornAgainCore.vector_longinteger_t_rend(self)


    def clear(self):
        """clear(vector_longinteger_t self)"""
        return _libBornAgainCore.vector_longinteger_t_clear(self)


    def get_allocator(self):
        """get_allocator(vector_longinteger_t self) -> std::vector< unsigned long >::allocator_type"""
        return _libBornAgainCore.vector_longinteger_t_get_allocator(self)


    def pop_back(self):
        """pop_back(vector_longinteger_t self)"""
        return _libBornAgainCore.vector_longinteger_t_pop_back(self)


    def erase(self, *args):
        """
        erase(vector_longinteger_t self, std::vector< unsigned long >::iterator pos) -> std::vector< unsigned long >::iterator
        erase(vector_longinteger_t self, std::vector< unsigned long >::iterator first, std::vector< unsigned long >::iterator last) -> std::vector< unsigned long >::iterator
        """
        return _libBornAgainCore.vector_longinteger_t_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(unsigned long)> self) -> vector_longinteger_t
        __init__(std::vector<(unsigned long)> self, vector_longinteger_t arg2) -> vector_longinteger_t
        __init__(std::vector<(unsigned long)> self, std::vector< unsigned long >::size_type size) -> vector_longinteger_t
        __init__(std::vector<(unsigned long)> self, std::vector< unsigned long >::size_type size, std::vector< unsigned long >::value_type const & value) -> vector_longinteger_t
        """
        this = _libBornAgainCore.new_vector_longinteger_t(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vector_longinteger_t self, std::vector< unsigned long >::value_type const & x)"""
        return _libBornAgainCore.vector_longinteger_t_push_back(self, x)


    def front(self):
        """front(vector_longinteger_t self) -> std::vector< unsigned long >::value_type const &"""
        return _libBornAgainCore.vector_longinteger_t_front(self)


    def back(self):
        """back(vector_longinteger_t self) -> std::vector< unsigned long >::value_type const &"""
        return _libBornAgainCore.vector_longinteger_t_back(self)


    def assign(self, n, x):
        """assign(vector_longinteger_t self, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)"""
        return _libBornAgainCore.vector_longinteger_t_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vector_longinteger_t self, std::vector< unsigned long >::size_type new_size)
        resize(vector_longinteger_t self, std::vector< unsigned long >::size_type new_size, std::vector< unsigned long >::value_type const & x)
        """
        return _libBornAgainCore.vector_longinteger_t_resize(self, *args)


    def insert(self, *args):
        """
        insert(vector_longinteger_t self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::value_type const & x) -> std::vector< unsigned long >::iterator
        insert(vector_longinteger_t self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)
        """
        return _libBornAgainCore.vector_longinteger_t_insert(self, *args)


    def reserve(self, n):
        """reserve(vector_longinteger_t self, std::vector< unsigned long >::size_type n)"""
        return _libBornAgainCore.vector_longinteger_t_reserve(self, n)


    def capacity(self):
        """capacity(vector_longinteger_t self) -> std::vector< unsigned long >::size_type"""
        return _libBornAgainCore.vector_longinteger_t_capacity(self)

    __swig_destroy__ = _libBornAgainCore.delete_vector_longinteger_t
    __del__ = lambda self: None
vector_longinteger_t_swigregister = _libBornAgainCore.vector_longinteger_t_swigregister
vector_longinteger_t_swigregister(vector_longinteger_t)

class vector_complex_t(_object):
    """Proxy of C++ std::vector<(std::complex<(double)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_complex_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_complex_t, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vector_complex_t self) -> SwigPyIterator"""
        return _libBornAgainCore.vector_complex_t_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vector_complex_t self) -> bool"""
        return _libBornAgainCore.vector_complex_t___nonzero__(self)


    def __bool__(self):
        """__bool__(vector_complex_t self) -> bool"""
        return _libBornAgainCore.vector_complex_t___bool__(self)


    def __len__(self):
        """__len__(vector_complex_t self) -> std::vector< std::complex< double > >::size_type"""
        return _libBornAgainCore.vector_complex_t___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j) -> vector_complex_t"""
        return _libBornAgainCore.vector_complex_t___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j)
        __setslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j, vector_complex_t v)
        """
        return _libBornAgainCore.vector_complex_t___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j)"""
        return _libBornAgainCore.vector_complex_t___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i)
        __delitem__(vector_complex_t self, PySliceObject * slice)
        """
        return _libBornAgainCore.vector_complex_t___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vector_complex_t self, PySliceObject * slice) -> vector_complex_t
        __getitem__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i) -> std::vector< std::complex< double > >::value_type const &
        """
        return _libBornAgainCore.vector_complex_t___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vector_complex_t self, PySliceObject * slice, vector_complex_t v)
        __setitem__(vector_complex_t self, PySliceObject * slice)
        __setitem__(vector_complex_t self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::value_type const & x)
        """
        return _libBornAgainCore.vector_complex_t___setitem__(self, *args)


    def pop(self):
        """pop(vector_complex_t self) -> std::vector< std::complex< double > >::value_type"""
        return _libBornAgainCore.vector_complex_t_pop(self)


    def append(self, x):
        """append(vector_complex_t self, std::vector< std::complex< double > >::value_type const & x)"""
        return _libBornAgainCore.vector_complex_t_append(self, x)


    def empty(self):
        """empty(vector_complex_t self) -> bool"""
        return _libBornAgainCore.vector_complex_t_empty(self)


    def size(self):
        """size(vector_complex_t self) -> std::vector< std::complex< double > >::size_type"""
        return _libBornAgainCore.vector_complex_t_size(self)


    def swap(self, v):
        """
        swap(vector_complex_t self, vector_complex_t v)

        void swap(OutputDataIterator< TValue, TContainer > &left, OutputDataIterator< TValue, TContainer > &right)

        make Swappable 

        """
        return _libBornAgainCore.vector_complex_t_swap(self, v)


    def begin(self):
        """begin(vector_complex_t self) -> std::vector< std::complex< double > >::iterator"""
        return _libBornAgainCore.vector_complex_t_begin(self)


    def end(self):
        """end(vector_complex_t self) -> std::vector< std::complex< double > >::iterator"""
        return _libBornAgainCore.vector_complex_t_end(self)


    def rbegin(self):
        """rbegin(vector_complex_t self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _libBornAgainCore.vector_complex_t_rbegin(self)


    def rend(self):
        """rend(vector_complex_t self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _libBornAgainCore.vector_complex_t_rend(self)


    def clear(self):
        """clear(vector_complex_t self)"""
        return _libBornAgainCore.vector_complex_t_clear(self)


    def get_allocator(self):
        """get_allocator(vector_complex_t self) -> std::vector< std::complex< double > >::allocator_type"""
        return _libBornAgainCore.vector_complex_t_get_allocator(self)


    def pop_back(self):
        """pop_back(vector_complex_t self)"""
        return _libBornAgainCore.vector_complex_t_pop_back(self)


    def erase(self, *args):
        """
        erase(vector_complex_t self, std::vector< std::complex< double > >::iterator pos) -> std::vector< std::complex< double > >::iterator
        erase(vector_complex_t self, std::vector< std::complex< double > >::iterator first, std::vector< std::complex< double > >::iterator last) -> std::vector< std::complex< double > >::iterator
        """
        return _libBornAgainCore.vector_complex_t_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::complex<(double)>)> self) -> vector_complex_t
        __init__(std::vector<(std::complex<(double)>)> self, vector_complex_t arg2) -> vector_complex_t
        __init__(std::vector<(std::complex<(double)>)> self, std::vector< std::complex< double > >::size_type size) -> vector_complex_t
        __init__(std::vector<(std::complex<(double)>)> self, std::vector< std::complex< double > >::size_type size, std::vector< std::complex< double > >::value_type const & value) -> vector_complex_t
        """
        this = _libBornAgainCore.new_vector_complex_t(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vector_complex_t self, std::vector< std::complex< double > >::value_type const & x)"""
        return _libBornAgainCore.vector_complex_t_push_back(self, x)


    def front(self):
        """front(vector_complex_t self) -> std::vector< std::complex< double > >::value_type const &"""
        return _libBornAgainCore.vector_complex_t_front(self)


    def back(self):
        """back(vector_complex_t self) -> std::vector< std::complex< double > >::value_type const &"""
        return _libBornAgainCore.vector_complex_t_back(self)


    def assign(self, n, x):
        """assign(vector_complex_t self, std::vector< std::complex< double > >::size_type n, std::vector< std::complex< double > >::value_type const & x)"""
        return _libBornAgainCore.vector_complex_t_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vector_complex_t self, std::vector< std::complex< double > >::size_type new_size)
        resize(vector_complex_t self, std::vector< std::complex< double > >::size_type new_size, std::vector< std::complex< double > >::value_type const & x)
        """
        return _libBornAgainCore.vector_complex_t_resize(self, *args)


    def insert(self, *args):
        """
        insert(vector_complex_t self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::value_type const & x) -> std::vector< std::complex< double > >::iterator
        insert(vector_complex_t self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::size_type n, std::vector< std::complex< double > >::value_type const & x)
        """
        return _libBornAgainCore.vector_complex_t_insert(self, *args)


    def reserve(self, n):
        """reserve(vector_complex_t self, std::vector< std::complex< double > >::size_type n)"""
        return _libBornAgainCore.vector_complex_t_reserve(self, n)


    def capacity(self):
        """capacity(vector_complex_t self) -> std::vector< std::complex< double > >::size_type"""
        return _libBornAgainCore.vector_complex_t_capacity(self)

    __swig_destroy__ = _libBornAgainCore.delete_vector_complex_t
    __del__ = lambda self: None
vector_complex_t_swigregister = _libBornAgainCore.vector_complex_t_swigregister
vector_complex_t_swigregister(vector_complex_t)

class vector_string_t(_object):
    """Proxy of C++ std::vector<(std::string)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_string_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_string_t, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vector_string_t self) -> SwigPyIterator"""
        return _libBornAgainCore.vector_string_t_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vector_string_t self) -> bool"""
        return _libBornAgainCore.vector_string_t___nonzero__(self)


    def __bool__(self):
        """__bool__(vector_string_t self) -> bool"""
        return _libBornAgainCore.vector_string_t___bool__(self)


    def __len__(self):
        """__len__(vector_string_t self) -> std::vector< std::string >::size_type"""
        return _libBornAgainCore.vector_string_t___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> vector_string_t"""
        return _libBornAgainCore.vector_string_t___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        __setslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, vector_string_t v)
        """
        return _libBornAgainCore.vector_string_t___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _libBornAgainCore.vector_string_t___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vector_string_t self, std::vector< std::string >::difference_type i)
        __delitem__(vector_string_t self, PySliceObject * slice)
        """
        return _libBornAgainCore.vector_string_t___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vector_string_t self, PySliceObject * slice) -> vector_string_t
        __getitem__(vector_string_t self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _libBornAgainCore.vector_string_t___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vector_string_t self, PySliceObject * slice, vector_string_t v)
        __setitem__(vector_string_t self, PySliceObject * slice)
        __setitem__(vector_string_t self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _libBornAgainCore.vector_string_t___setitem__(self, *args)


    def pop(self):
        """pop(vector_string_t self) -> std::vector< std::string >::value_type"""
        return _libBornAgainCore.vector_string_t_pop(self)


    def append(self, x):
        """append(vector_string_t self, std::vector< std::string >::value_type const & x)"""
        return _libBornAgainCore.vector_string_t_append(self, x)


    def empty(self):
        """empty(vector_string_t self) -> bool"""
        return _libBornAgainCore.vector_string_t_empty(self)


    def size(self):
        """size(vector_string_t self) -> std::vector< std::string >::size_type"""
        return _libBornAgainCore.vector_string_t_size(self)


    def swap(self, v):
        """
        swap(vector_string_t self, vector_string_t v)

        void swap(OutputDataIterator< TValue, TContainer > &left, OutputDataIterator< TValue, TContainer > &right)

        make Swappable 

        """
        return _libBornAgainCore.vector_string_t_swap(self, v)


    def begin(self):
        """begin(vector_string_t self) -> std::vector< std::string >::iterator"""
        return _libBornAgainCore.vector_string_t_begin(self)


    def end(self):
        """end(vector_string_t self) -> std::vector< std::string >::iterator"""
        return _libBornAgainCore.vector_string_t_end(self)


    def rbegin(self):
        """rbegin(vector_string_t self) -> std::vector< std::string >::reverse_iterator"""
        return _libBornAgainCore.vector_string_t_rbegin(self)


    def rend(self):
        """rend(vector_string_t self) -> std::vector< std::string >::reverse_iterator"""
        return _libBornAgainCore.vector_string_t_rend(self)


    def clear(self):
        """clear(vector_string_t self)"""
        return _libBornAgainCore.vector_string_t_clear(self)


    def get_allocator(self):
        """get_allocator(vector_string_t self) -> std::vector< std::string >::allocator_type"""
        return _libBornAgainCore.vector_string_t_get_allocator(self)


    def pop_back(self):
        """pop_back(vector_string_t self)"""
        return _libBornAgainCore.vector_string_t_pop_back(self)


    def erase(self, *args):
        """
        erase(vector_string_t self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(vector_string_t self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _libBornAgainCore.vector_string_t_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::string)> self) -> vector_string_t
        __init__(std::vector<(std::string)> self, vector_string_t arg2) -> vector_string_t
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size) -> vector_string_t
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> vector_string_t
        """
        this = _libBornAgainCore.new_vector_string_t(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vector_string_t self, std::vector< std::string >::value_type const & x)"""
        return _libBornAgainCore.vector_string_t_push_back(self, x)


    def front(self):
        """front(vector_string_t self) -> std::vector< std::string >::value_type const &"""
        return _libBornAgainCore.vector_string_t_front(self)


    def back(self):
        """back(vector_string_t self) -> std::vector< std::string >::value_type const &"""
        return _libBornAgainCore.vector_string_t_back(self)


    def assign(self, n, x):
        """assign(vector_string_t self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _libBornAgainCore.vector_string_t_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vector_string_t self, std::vector< std::string >::size_type new_size)
        resize(vector_string_t self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _libBornAgainCore.vector_string_t_resize(self, *args)


    def insert(self, *args):
        """
        insert(vector_string_t self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(vector_string_t self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)
        """
        return _libBornAgainCore.vector_string_t_insert(self, *args)


    def reserve(self, n):
        """reserve(vector_string_t self, std::vector< std::string >::size_type n)"""
        return _libBornAgainCore.vector_string_t_reserve(self, n)


    def capacity(self):
        """capacity(vector_string_t self) -> std::vector< std::string >::size_type"""
        return _libBornAgainCore.vector_string_t_capacity(self)

    __swig_destroy__ = _libBornAgainCore.delete_vector_string_t
    __del__ = lambda self: None
vector_string_t_swigregister = _libBornAgainCore.vector_string_t_swigregister
vector_string_t_swigregister(vector_string_t)

import libBornAgainFit

def GetMajorVersionNumber():
    """GetMajorVersionNumber() -> int"""
    return _libBornAgainCore.GetMajorVersionNumber()

def GetMinorVersionNumber():
    """GetMinorVersionNumber() -> int"""
    return _libBornAgainCore.GetMinorVersionNumber()

def GetPatchVersionNumber():
    """GetPatchVersionNumber() -> int"""
    return _libBornAgainCore.GetPatchVersionNumber()

def GetName():
    """GetName() -> std::string"""
    return _libBornAgainCore.GetName()

def GetVersionNumber():
    """GetVersionNumber() -> std::string"""
    return _libBornAgainCore.GetVersionNumber()

def vecOfLambdaAlphaPhi(_lambda, _alpha, _phi):
    """
    vecOfLambdaAlphaPhi(double const _lambda, double const _alpha, double const _phi) -> kvector_t

    BA_CORE_API_ BasicVector3D<double> vecOfLambdaAlphaPhi(const double _lambda, const double _alpha, const double _phi)

    Creates a vector<double> as a wavevector with given wavelength and angles. Specifically needed for grazing-incidence scattering. 

    """
    return _libBornAgainCore.vecOfLambdaAlphaPhi(_lambda, _alpha, _phi)
class INoncopyable(_object):
    """


    Mix-in for objects that must not be copied.

    This virtual base class disables the copy constructor and the operator= in all its child classes.

    C++ includes: INoncopyable.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, INoncopyable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, INoncopyable, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(INoncopyable self) -> INoncopyable

        INoncopyable::INoncopyable(const INoncopyable &)=delete

        """
        this = _libBornAgainCore.new_INoncopyable()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_INoncopyable
    __del__ = lambda self: None
INoncopyable_swigregister = _libBornAgainCore.INoncopyable_swigregister
INoncopyable_swigregister(INoncopyable)
cvar = _libBornAgainCore.cvar
major_version_number = cvar.major_version_number
minor_version_number = cvar.minor_version_number
patch_version_number = cvar.patch_version_number
PI2 = cvar.PI2

class ICloneable(INoncopyable):
    """


    Mix-in for objects that must not be copied, except by cloning.

    The base class  INoncopyable disables the copy constructor and the operator= in all its child classes. Child classes of  ICloneable should provide clone().

    C++ includes: ICloneable.h

    """

    __swig_setmethods__ = {}
    for _s in [INoncopyable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICloneable, name, value)
    __swig_getmethods__ = {}
    for _s in [INoncopyable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ICloneable, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self):
        """
        clone(ICloneable self) -> ICloneable

        virtual ICloneable* ICloneable::clone() const =0

        """
        return _libBornAgainCore.ICloneable_clone(self)


    def transferToCPP(self):
        """
        transferToCPP(ICloneable self)

        virtual void ICloneable::transferToCPP()

        Used for Python overriding of clone. 

        """
        return self.__disown__()

    __swig_destroy__ = _libBornAgainCore.delete_ICloneable
    __del__ = lambda self: None
ICloneable_swigregister = _libBornAgainCore.ICloneable_swigregister
ICloneable_swigregister(ICloneable)

class INamed(_object):
    """


    Interface for named objects.

    C++ includes: INamed.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, INamed, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, INamed, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(INamed self) -> INamed
        __init__(INamed self, std::string const & name) -> INamed

        INamed::INamed(const std::string &name)

        """
        if self.__class__ == INamed:
            _self = None
        else:
            _self = self
        this = _libBornAgainCore.new_INamed(_self, *args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_INamed
    __del__ = lambda self: None

    def getName(self):
        """
        getName(INamed self) -> std::string

        std::string INamed::getName() const

        """
        return _libBornAgainCore.INamed_getName(self)

    def __disown__(self):
        self.this.disown()
        _libBornAgainCore.disown_INamed(self)
        return weakref_proxy(self)
INamed_swigregister = _libBornAgainCore.INamed_swigregister
INamed_swigregister(INamed)

class IParameterized(INamed):
    """


    Manages a local parameter pool, and a tree of child pools.

    C++ includes: IParameterized.h

    """

    __swig_setmethods__ = {}
    for _s in [INamed]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IParameterized, name, value)
    __swig_getmethods__ = {}
    for _s in [INamed]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IParameterized, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IParameterized self, std::string const & name) -> IParameterized
        __init__(IParameterized self) -> IParameterized
        __init__(IParameterized self, IParameterized other) -> IParameterized

        IParameterized::IParameterized(const IParameterized &other)

        """
        if self.__class__ == IParameterized:
            _self = None
        else:
            _self = self
        this = _libBornAgainCore.new_IParameterized(_self, *args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_IParameterized
    __del__ = lambda self: None

    def getParameterPool(self):
        """
        getParameterPool(IParameterized self) -> ParameterPool

        ParameterPool* IParameterized::getParameterPool() const

        Returns pointer to the parameter pool. 

        """
        return _libBornAgainCore.IParameterized_getParameterPool(self)


    def createParameterTree(self):
        """
        createParameterTree(IParameterized self) -> ParameterPool

        ParameterPool * IParameterized::createParameterTree()

        Creates new parameter pool, with all local parameters and those of its children. 

        """
        return _libBornAgainCore.IParameterized_createParameterTree(self)


    def printParameters(self):
        """
        printParameters(IParameterized self)

        void IParameterized::printParameters()

        """
        return _libBornAgainCore.IParameterized_printParameters(self)


    def registerParameter(self, name, parpointer):
        """
        registerParameter(IParameterized self, std::string const & name, double * parpointer) -> RealParameter

        RealParameter & IParameterized::registerParameter(const std::string &name, double *parpointer)

        """
        return _libBornAgainCore.IParameterized_registerParameter(self, name, parpointer)


    def setParameterValue(self, name, value):
        """
        setParameterValue(IParameterized self, std::string const & name, double value)

        void IParameterized::setParameterValue(const std::string &name, double value)

        """
        return _libBornAgainCore.IParameterized_setParameterValue(self, name, value)


    def getParameter(self, name):
        """
        getParameter(IParameterized self, std::string const & name) -> RealParameter

        RealParameter * IParameterized::getParameter(const std::string &name) const

        Returns parameter with given 'name'. 

        """
        return _libBornAgainCore.IParameterized_getParameter(self, name)


    def onChange(self):
        """onChange(IParameterized self)"""
        return _libBornAgainCore.IParameterized_onChange(self)


    def _print(self, ostr):
        """_print(IParameterized self, std::ostream & ostr)"""
        return _libBornAgainCore.IParameterized__print(self, ostr)

    def __disown__(self):
        self.this.disown()
        _libBornAgainCore.disown_IParameterized(self)
        return weakref_proxy(self)
IParameterized_swigregister = _libBornAgainCore.IParameterized_swigregister
IParameterized_swigregister(IParameterized)

class kvector_t(_object):
    """


    Three-dimensional vector template, for use with integer, double, or complex components.

    C++ includes: BasicVector3D.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, kvector_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, kvector_t, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BasicVector3D<(double)> self) -> kvector_t
        __init__(BasicVector3D<(double)> self, double const x1, double const y1, double const z1) -> kvector_t

        BasicVector3D< T >::BasicVector3D(const T x1, const T y1, const T z1)

        Constructor from cartesian components. 

        """
        this = _libBornAgainCore.new_kvector_t(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def x(self):
        """
        x(kvector_t self) -> double

        T BasicVector3D< T >::x() const

        Returns x-component in cartesian coordinate system. 

        """
        return _libBornAgainCore.kvector_t_x(self)


    def y(self):
        """
        y(kvector_t self) -> double

        T BasicVector3D< T >::y() const

        Returns y-component in cartesian coordinate system. 

        """
        return _libBornAgainCore.kvector_t_y(self)


    def z(self):
        """
        z(kvector_t self) -> double

        T BasicVector3D< T >::z() const

        Returns z-component in cartesian coordinate system. 

        """
        return _libBornAgainCore.kvector_t_z(self)


    def setX(self, a):
        """
        setX(kvector_t self, double const & a)

        void BasicVector3D< T >::setX(const T &a)

        Sets x-component in cartesian coordinate system. 

        """
        return _libBornAgainCore.kvector_t_setX(self, a)


    def setY(self, a):
        """
        setY(kvector_t self, double const & a)

        void BasicVector3D< T >::setY(const T &a)

        Sets y-component in cartesian coordinate system. 

        """
        return _libBornAgainCore.kvector_t_setY(self, a)


    def setZ(self, a):
        """
        setZ(kvector_t self, double const & a)

        void BasicVector3D< T >::setZ(const T &a)

        Sets z-component in cartesian coordinate system. 

        """
        return _libBornAgainCore.kvector_t_setZ(self, a)


    def __iadd__(self, v):
        """__iadd__(kvector_t self, kvector_t v) -> kvector_t"""
        return _libBornAgainCore.kvector_t___iadd__(self, v)


    def __isub__(self, v):
        """__isub__(kvector_t self, kvector_t v) -> kvector_t"""
        return _libBornAgainCore.kvector_t___isub__(self, v)


    def conj(self):
        """
        conj(kvector_t self) -> kvector_t

        BasicVector3D< complex_t > BasicVector3D< complex_t >::conj() const

        Returns complex conjugate vector. 

        """
        return _libBornAgainCore.kvector_t_conj(self)


    def mag2(self):
        """
        mag2(kvector_t self) -> double

        double BasicVector3D< T >::mag2() const

        Returns squared magnitude squared of the vector. 

        """
        return _libBornAgainCore.kvector_t_mag2(self)


    def mag(self):
        """
        mag(kvector_t self) -> double

        double BasicVector3D< T >::mag() const

        Returns magnitude of the vector. 

        """
        return _libBornAgainCore.kvector_t_mag(self)


    def magxy2(self):
        """
        magxy2(kvector_t self) -> double

        double BasicVector3D< T >::magxy2() const

        Returns squared distance from z axis. 

        """
        return _libBornAgainCore.kvector_t_magxy2(self)


    def magxy(self):
        """
        magxy(kvector_t self) -> double

        double BasicVector3D< T >::magxy() const

        Returns distance from z axis. 

        """
        return _libBornAgainCore.kvector_t_magxy(self)


    def phi(self):
        """
        phi(kvector_t self) -> double

        double BasicVector3D< T >::phi() const

        Returns azimuth angle. 

        """
        return _libBornAgainCore.kvector_t_phi(self)


    def theta(self):
        """
        theta(kvector_t self) -> double

        double BasicVector3D< T >::theta() const

        Returns polar angle. 

        """
        return _libBornAgainCore.kvector_t_theta(self)


    def cosTheta(self):
        """
        cosTheta(kvector_t self) -> double

        double BasicVector3D< T >::cosTheta() const

        Returns cosine of polar angle. 

        """
        return _libBornAgainCore.kvector_t_cosTheta(self)


    def sin2Theta(self):
        """
        sin2Theta(kvector_t self) -> double

        double BasicVector3D< T >::sin2Theta() const

        Returns squared sine of polar angle. 

        """
        return _libBornAgainCore.kvector_t_sin2Theta(self)


    def unit(self):
        """
        unit(kvector_t self) -> kvector_t

        BasicVector3D< complex_t > BasicVector3D< complex_t >::unit() const

        """
        return _libBornAgainCore.kvector_t_unit(self)


    def complex(self):
        """
        complex(kvector_t self) -> cvector_t

        BasicVector3D<std::complex<double> > BasicVector3D< T >::complex() const

        Returns this, trivially converted to complex type. 

        """
        return _libBornAgainCore.kvector_t_complex(self)


    def real(self):
        """
        real(kvector_t self) -> kvector_t

        BasicVector3D< double > BasicVector3D< complex_t >::real() const

        Returns real parts. 

        """
        return _libBornAgainCore.kvector_t_real(self)


    def angle(self, v):
        """
        angle(kvector_t self, kvector_t v) -> double

        double BasicVector3D< T >::angle(const BasicVector3D< T > &v) const

        Returns angle with respect to another vector. 

        """
        return _libBornAgainCore.kvector_t_angle(self, v)


    def project(self, v):
        """
        project(kvector_t self, kvector_t v) -> kvector_t

        BasicVector3D<T> BasicVector3D< T >::project(const BasicVector3D< T > &v) const

        Returns projection of this onto other vector: (this*v)*v/|v|^2. 

        """
        return _libBornAgainCore.kvector_t_project(self, v)


    def __add__(self, rhs):
        """__add__(kvector_t self, kvector_t rhs) -> kvector_t"""
        return _libBornAgainCore.kvector_t___add__(self, rhs)


    def __mul__(self, c):
        """__mul__(kvector_t self, double c) -> kvector_t"""
        return _libBornAgainCore.kvector_t___mul__(self, c)


    def __rmul__(self, c):
        """__rmul__(kvector_t self, double c) -> kvector_t"""
        return _libBornAgainCore.kvector_t___rmul__(self, c)


    def __neg__(self):
        """__neg__(kvector_t self) -> kvector_t"""
        return _libBornAgainCore.kvector_t___neg__(self)

    __swig_destroy__ = _libBornAgainCore.delete_kvector_t
    __del__ = lambda self: None
kvector_t_swigregister = _libBornAgainCore.kvector_t_swigregister
kvector_t_swigregister(kvector_t)

class vector_kvector_t(_object):
    """Proxy of C++ std::vector<(BasicVector3D<(double)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_kvector_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_kvector_t, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vector_kvector_t self) -> SwigPyIterator"""
        return _libBornAgainCore.vector_kvector_t_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vector_kvector_t self) -> bool"""
        return _libBornAgainCore.vector_kvector_t___nonzero__(self)


    def __bool__(self):
        """__bool__(vector_kvector_t self) -> bool"""
        return _libBornAgainCore.vector_kvector_t___bool__(self)


    def __len__(self):
        """__len__(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::size_type"""
        return _libBornAgainCore.vector_kvector_t___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i, std::vector< BasicVector3D< double > >::difference_type j) -> vector_kvector_t"""
        return _libBornAgainCore.vector_kvector_t___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i, std::vector< BasicVector3D< double > >::difference_type j)
        __setslice__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i, std::vector< BasicVector3D< double > >::difference_type j, vector_kvector_t v)
        """
        return _libBornAgainCore.vector_kvector_t___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i, std::vector< BasicVector3D< double > >::difference_type j)"""
        return _libBornAgainCore.vector_kvector_t___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i)
        __delitem__(vector_kvector_t self, PySliceObject * slice)
        """
        return _libBornAgainCore.vector_kvector_t___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vector_kvector_t self, PySliceObject * slice) -> vector_kvector_t
        __getitem__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i) -> kvector_t
        """
        return _libBornAgainCore.vector_kvector_t___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vector_kvector_t self, PySliceObject * slice, vector_kvector_t v)
        __setitem__(vector_kvector_t self, PySliceObject * slice)
        __setitem__(vector_kvector_t self, std::vector< BasicVector3D< double > >::difference_type i, kvector_t x)
        """
        return _libBornAgainCore.vector_kvector_t___setitem__(self, *args)


    def pop(self):
        """pop(vector_kvector_t self) -> kvector_t"""
        return _libBornAgainCore.vector_kvector_t_pop(self)


    def append(self, x):
        """append(vector_kvector_t self, kvector_t x)"""
        return _libBornAgainCore.vector_kvector_t_append(self, x)


    def empty(self):
        """empty(vector_kvector_t self) -> bool"""
        return _libBornAgainCore.vector_kvector_t_empty(self)


    def size(self):
        """size(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::size_type"""
        return _libBornAgainCore.vector_kvector_t_size(self)


    def swap(self, v):
        """
        swap(vector_kvector_t self, vector_kvector_t v)

        void swap(OutputDataIterator< TValue, TContainer > &left, OutputDataIterator< TValue, TContainer > &right)

        make Swappable 

        """
        return _libBornAgainCore.vector_kvector_t_swap(self, v)


    def begin(self):
        """begin(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::iterator"""
        return _libBornAgainCore.vector_kvector_t_begin(self)


    def end(self):
        """end(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::iterator"""
        return _libBornAgainCore.vector_kvector_t_end(self)


    def rbegin(self):
        """rbegin(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::reverse_iterator"""
        return _libBornAgainCore.vector_kvector_t_rbegin(self)


    def rend(self):
        """rend(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::reverse_iterator"""
        return _libBornAgainCore.vector_kvector_t_rend(self)


    def clear(self):
        """clear(vector_kvector_t self)"""
        return _libBornAgainCore.vector_kvector_t_clear(self)


    def get_allocator(self):
        """get_allocator(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::allocator_type"""
        return _libBornAgainCore.vector_kvector_t_get_allocator(self)


    def pop_back(self):
        """pop_back(vector_kvector_t self)"""
        return _libBornAgainCore.vector_kvector_t_pop_back(self)


    def erase(self, *args):
        """
        erase(vector_kvector_t self, std::vector< BasicVector3D< double > >::iterator pos) -> std::vector< BasicVector3D< double > >::iterator
        erase(vector_kvector_t self, std::vector< BasicVector3D< double > >::iterator first, std::vector< BasicVector3D< double > >::iterator last) -> std::vector< BasicVector3D< double > >::iterator
        """
        return _libBornAgainCore.vector_kvector_t_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(BasicVector3D<(double)>)> self) -> vector_kvector_t
        __init__(std::vector<(BasicVector3D<(double)>)> self, vector_kvector_t arg2) -> vector_kvector_t
        __init__(std::vector<(BasicVector3D<(double)>)> self, std::vector< BasicVector3D< double > >::size_type size) -> vector_kvector_t
        __init__(std::vector<(BasicVector3D<(double)>)> self, std::vector< BasicVector3D< double > >::size_type size, kvector_t value) -> vector_kvector_t
        """
        this = _libBornAgainCore.new_vector_kvector_t(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vector_kvector_t self, kvector_t x)"""
        return _libBornAgainCore.vector_kvector_t_push_back(self, x)


    def front(self):
        """front(vector_kvector_t self) -> kvector_t"""
        return _libBornAgainCore.vector_kvector_t_front(self)


    def back(self):
        """back(vector_kvector_t self) -> kvector_t"""
        return _libBornAgainCore.vector_kvector_t_back(self)


    def assign(self, n, x):
        """assign(vector_kvector_t self, std::vector< BasicVector3D< double > >::size_type n, kvector_t x)"""
        return _libBornAgainCore.vector_kvector_t_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vector_kvector_t self, std::vector< BasicVector3D< double > >::size_type new_size)
        resize(vector_kvector_t self, std::vector< BasicVector3D< double > >::size_type new_size, kvector_t x)
        """
        return _libBornAgainCore.vector_kvector_t_resize(self, *args)


    def insert(self, *args):
        """
        insert(vector_kvector_t self, std::vector< BasicVector3D< double > >::iterator pos, kvector_t x) -> std::vector< BasicVector3D< double > >::iterator
        insert(vector_kvector_t self, std::vector< BasicVector3D< double > >::iterator pos, std::vector< BasicVector3D< double > >::size_type n, kvector_t x)
        """
        return _libBornAgainCore.vector_kvector_t_insert(self, *args)


    def reserve(self, n):
        """reserve(vector_kvector_t self, std::vector< BasicVector3D< double > >::size_type n)"""
        return _libBornAgainCore.vector_kvector_t_reserve(self, n)


    def capacity(self):
        """capacity(vector_kvector_t self) -> std::vector< BasicVector3D< double > >::size_type"""
        return _libBornAgainCore.vector_kvector_t_capacity(self)

    __swig_destroy__ = _libBornAgainCore.delete_vector_kvector_t
    __del__ = lambda self: None
vector_kvector_t_swigregister = _libBornAgainCore.vector_kvector_t_swigregister
vector_kvector_t_swigregister(vector_kvector_t)

class cvector_t(_object):
    """


    Three-dimensional vector template, for use with integer, double, or complex components.

    C++ includes: BasicVector3D.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cvector_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cvector_t, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BasicVector3D<(std::complex<(double)>)> self) -> cvector_t
        __init__(BasicVector3D<(std::complex<(double)>)> self, std::complex< double > const x1, std::complex< double > const y1, std::complex< double > const z1) -> cvector_t

        BasicVector3D< T >::BasicVector3D(const T x1, const T y1, const T z1)

        Constructor from cartesian components. 

        """
        this = _libBornAgainCore.new_cvector_t(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def x(self):
        """
        x(cvector_t self) -> std::complex< double >

        T BasicVector3D< T >::x() const

        Returns x-component in cartesian coordinate system. 

        """
        return _libBornAgainCore.cvector_t_x(self)


    def y(self):
        """
        y(cvector_t self) -> std::complex< double >

        T BasicVector3D< T >::y() const

        Returns y-component in cartesian coordinate system. 

        """
        return _libBornAgainCore.cvector_t_y(self)


    def z(self):
        """
        z(cvector_t self) -> std::complex< double >

        T BasicVector3D< T >::z() const

        Returns z-component in cartesian coordinate system. 

        """
        return _libBornAgainCore.cvector_t_z(self)


    def setX(self, a):
        """
        setX(cvector_t self, std::complex< double > const & a)

        void BasicVector3D< T >::setX(const T &a)

        Sets x-component in cartesian coordinate system. 

        """
        return _libBornAgainCore.cvector_t_setX(self, a)


    def setY(self, a):
        """
        setY(cvector_t self, std::complex< double > const & a)

        void BasicVector3D< T >::setY(const T &a)

        Sets y-component in cartesian coordinate system. 

        """
        return _libBornAgainCore.cvector_t_setY(self, a)


    def setZ(self, a):
        """
        setZ(cvector_t self, std::complex< double > const & a)

        void BasicVector3D< T >::setZ(const T &a)

        Sets z-component in cartesian coordinate system. 

        """
        return _libBornAgainCore.cvector_t_setZ(self, a)


    def __iadd__(self, v):
        """__iadd__(cvector_t self, cvector_t v) -> cvector_t"""
        return _libBornAgainCore.cvector_t___iadd__(self, v)


    def __isub__(self, v):
        """__isub__(cvector_t self, cvector_t v) -> cvector_t"""
        return _libBornAgainCore.cvector_t___isub__(self, v)


    def conj(self):
        """
        conj(cvector_t self) -> cvector_t

        BasicVector3D< complex_t > BasicVector3D< complex_t >::conj() const

        Returns complex conjugate vector. 

        """
        return _libBornAgainCore.cvector_t_conj(self)


    def mag2(self):
        """
        mag2(cvector_t self) -> double

        double BasicVector3D< T >::mag2() const

        Returns squared magnitude squared of the vector. 

        """
        return _libBornAgainCore.cvector_t_mag2(self)


    def mag(self):
        """
        mag(cvector_t self) -> double

        double BasicVector3D< T >::mag() const

        Returns magnitude of the vector. 

        """
        return _libBornAgainCore.cvector_t_mag(self)


    def magxy2(self):
        """
        magxy2(cvector_t self) -> double

        double BasicVector3D< T >::magxy2() const

        Returns squared distance from z axis. 

        """
        return _libBornAgainCore.cvector_t_magxy2(self)


    def magxy(self):
        """
        magxy(cvector_t self) -> double

        double BasicVector3D< T >::magxy() const

        Returns distance from z axis. 

        """
        return _libBornAgainCore.cvector_t_magxy(self)


    def unit(self):
        """
        unit(cvector_t self) -> cvector_t

        BasicVector3D< complex_t > BasicVector3D< complex_t >::unit() const

        """
        return _libBornAgainCore.cvector_t_unit(self)


    def real(self):
        """
        real(cvector_t self) -> kvector_t

        BasicVector3D< double > BasicVector3D< complex_t >::real() const

        Returns real parts. 

        """
        return _libBornAgainCore.cvector_t_real(self)


    def project(self, v):
        """
        project(cvector_t self, cvector_t v) -> cvector_t

        BasicVector3D<T> BasicVector3D< T >::project(const BasicVector3D< T > &v) const

        Returns projection of this onto other vector: (this*v)*v/|v|^2. 

        """
        return _libBornAgainCore.cvector_t_project(self, v)

    __swig_destroy__ = _libBornAgainCore.delete_cvector_t
    __del__ = lambda self: None
cvector_t_swigregister = _libBornAgainCore.cvector_t_swigregister
cvector_t_swigregister(cvector_t)

class vector_cvector_t(_object):
    """Proxy of C++ std::vector<(BasicVector3D<(std::complex<(double)>)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_cvector_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_cvector_t, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vector_cvector_t self) -> SwigPyIterator"""
        return _libBornAgainCore.vector_cvector_t_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vector_cvector_t self) -> bool"""
        return _libBornAgainCore.vector_cvector_t___nonzero__(self)


    def __bool__(self):
        """__bool__(vector_cvector_t self) -> bool"""
        return _libBornAgainCore.vector_cvector_t___bool__(self)


    def __len__(self):
        """__len__(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::size_type"""
        return _libBornAgainCore.vector_cvector_t___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i, std::vector< BasicVector3D< std::complex< double > > >::difference_type j) -> vector_cvector_t"""
        return _libBornAgainCore.vector_cvector_t___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i, std::vector< BasicVector3D< std::complex< double > > >::difference_type j)
        __setslice__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i, std::vector< BasicVector3D< std::complex< double > > >::difference_type j, vector_cvector_t v)
        """
        return _libBornAgainCore.vector_cvector_t___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i, std::vector< BasicVector3D< std::complex< double > > >::difference_type j)"""
        return _libBornAgainCore.vector_cvector_t___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i)
        __delitem__(vector_cvector_t self, PySliceObject * slice)
        """
        return _libBornAgainCore.vector_cvector_t___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vector_cvector_t self, PySliceObject * slice) -> vector_cvector_t
        __getitem__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i) -> cvector_t
        """
        return _libBornAgainCore.vector_cvector_t___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vector_cvector_t self, PySliceObject * slice, vector_cvector_t v)
        __setitem__(vector_cvector_t self, PySliceObject * slice)
        __setitem__(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::difference_type i, cvector_t x)
        """
        return _libBornAgainCore.vector_cvector_t___setitem__(self, *args)


    def pop(self):
        """pop(vector_cvector_t self) -> cvector_t"""
        return _libBornAgainCore.vector_cvector_t_pop(self)


    def append(self, x):
        """append(vector_cvector_t self, cvector_t x)"""
        return _libBornAgainCore.vector_cvector_t_append(self, x)


    def empty(self):
        """empty(vector_cvector_t self) -> bool"""
        return _libBornAgainCore.vector_cvector_t_empty(self)


    def size(self):
        """size(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::size_type"""
        return _libBornAgainCore.vector_cvector_t_size(self)


    def swap(self, v):
        """
        swap(vector_cvector_t self, vector_cvector_t v)

        void swap(OutputDataIterator< TValue, TContainer > &left, OutputDataIterator< TValue, TContainer > &right)

        make Swappable 

        """
        return _libBornAgainCore.vector_cvector_t_swap(self, v)


    def begin(self):
        """begin(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::iterator"""
        return _libBornAgainCore.vector_cvector_t_begin(self)


    def end(self):
        """end(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::iterator"""
        return _libBornAgainCore.vector_cvector_t_end(self)


    def rbegin(self):
        """rbegin(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::reverse_iterator"""
        return _libBornAgainCore.vector_cvector_t_rbegin(self)


    def rend(self):
        """rend(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::reverse_iterator"""
        return _libBornAgainCore.vector_cvector_t_rend(self)


    def clear(self):
        """clear(vector_cvector_t self)"""
        return _libBornAgainCore.vector_cvector_t_clear(self)


    def get_allocator(self):
        """get_allocator(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::allocator_type"""
        return _libBornAgainCore.vector_cvector_t_get_allocator(self)


    def pop_back(self):
        """pop_back(vector_cvector_t self)"""
        return _libBornAgainCore.vector_cvector_t_pop_back(self)


    def erase(self, *args):
        """
        erase(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::iterator pos) -> std::vector< BasicVector3D< std::complex< double > > >::iterator
        erase(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::iterator first, std::vector< BasicVector3D< std::complex< double > > >::iterator last) -> std::vector< BasicVector3D< std::complex< double > > >::iterator
        """
        return _libBornAgainCore.vector_cvector_t_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(BasicVector3D<(std::complex<(double)>)>)> self) -> vector_cvector_t
        __init__(std::vector<(BasicVector3D<(std::complex<(double)>)>)> self, vector_cvector_t arg2) -> vector_cvector_t
        __init__(std::vector<(BasicVector3D<(std::complex<(double)>)>)> self, std::vector< BasicVector3D< std::complex< double > > >::size_type size) -> vector_cvector_t
        __init__(std::vector<(BasicVector3D<(std::complex<(double)>)>)> self, std::vector< BasicVector3D< std::complex< double > > >::size_type size, cvector_t value) -> vector_cvector_t
        """
        this = _libBornAgainCore.new_vector_cvector_t(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vector_cvector_t self, cvector_t x)"""
        return _libBornAgainCore.vector_cvector_t_push_back(self, x)


    def front(self):
        """front(vector_cvector_t self) -> cvector_t"""
        return _libBornAgainCore.vector_cvector_t_front(self)


    def back(self):
        """back(vector_cvector_t self) -> cvector_t"""
        return _libBornAgainCore.vector_cvector_t_back(self)


    def assign(self, n, x):
        """assign(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::size_type n, cvector_t x)"""
        return _libBornAgainCore.vector_cvector_t_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::size_type new_size)
        resize(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::size_type new_size, cvector_t x)
        """
        return _libBornAgainCore.vector_cvector_t_resize(self, *args)


    def insert(self, *args):
        """
        insert(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::iterator pos, cvector_t x) -> std::vector< BasicVector3D< std::complex< double > > >::iterator
        insert(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::iterator pos, std::vector< BasicVector3D< std::complex< double > > >::size_type n, cvector_t x)
        """
        return _libBornAgainCore.vector_cvector_t_insert(self, *args)


    def reserve(self, n):
        """reserve(vector_cvector_t self, std::vector< BasicVector3D< std::complex< double > > >::size_type n)"""
        return _libBornAgainCore.vector_cvector_t_reserve(self, n)


    def capacity(self):
        """capacity(vector_cvector_t self) -> std::vector< BasicVector3D< std::complex< double > > >::size_type"""
        return _libBornAgainCore.vector_cvector_t_capacity(self)

    __swig_destroy__ = _libBornAgainCore.delete_vector_cvector_t
    __del__ = lambda self: None
vector_cvector_t_swigregister = _libBornAgainCore.vector_cvector_t_swigregister
vector_cvector_t_swigregister(vector_cvector_t)


def mul_I(z):
    """
    mul_I(complex_t z) -> complex_t

    complex_t mul_I(complex_t z)

    Returns product I*z, where I is the imaginary unit. 

    """
    return _libBornAgainCore.mul_I(z)

def exp_I(z):
    """
    exp_I(complex_t z) -> complex_t

    complex_t exp_I(complex_t z)

    Returns exp(I*z), where I is the imaginary unit. 

    """
    return _libBornAgainCore.exp_I(z)

def rad2deg(angle):
    """
    rad2deg(double angle) -> double

    double Units::rad2deg(double angle)

    """
    return _libBornAgainCore.rad2deg(angle)

def deg2rad(angle):
    """
    deg2rad(double angle) -> double

    double Units::deg2rad(double angle)

    """
    return _libBornAgainCore.deg2rad(angle)
class WavevectorInfo(_object):
    """


    Holds all wavevector information relevant for calculating form factors.

    C++ includes: WavevectorInfo.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, WavevectorInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, WavevectorInfo, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(WavevectorInfo self) -> WavevectorInfo
        __init__(WavevectorInfo self, cvector_t ki, cvector_t kf, double wavelength) -> WavevectorInfo
        __init__(WavevectorInfo self, kvector_t ki, kvector_t kf, double wavelength) -> WavevectorInfo

        WavevectorInfo::WavevectorInfo(kvector_t ki, kvector_t kf, double wavelength)

        """
        this = _libBornAgainCore.new_WavevectorInfo(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def getKi(self):
        """
        getKi(WavevectorInfo self) -> cvector_t

        cvector_t WavevectorInfo::getKi() const

        """
        return _libBornAgainCore.WavevectorInfo_getKi(self)


    def getKf(self):
        """
        getKf(WavevectorInfo self) -> cvector_t

        cvector_t WavevectorInfo::getKf() const

        """
        return _libBornAgainCore.WavevectorInfo_getKf(self)


    def getQ(self):
        """
        getQ(WavevectorInfo self) -> cvector_t

        cvector_t WavevectorInfo::getQ() const

        """
        return _libBornAgainCore.WavevectorInfo_getQ(self)


    def getWavelength(self):
        """
        getWavelength(WavevectorInfo self) -> double

        double WavevectorInfo::getWavelength() const

        """
        return _libBornAgainCore.WavevectorInfo_getWavelength(self)

    __swig_destroy__ = _libBornAgainCore.delete_WavevectorInfo
    __del__ = lambda self: None
WavevectorInfo_swigregister = _libBornAgainCore.WavevectorInfo_swigregister
WavevectorInfo_swigregister(WavevectorInfo)
nanometer = cvar.nanometer
angstrom = cvar.angstrom
micrometer = cvar.micrometer
millimeter = cvar.millimeter
meter = cvar.meter
nm = cvar.nm
radian = cvar.radian
milliradian = cvar.milliradian
degree = cvar.degree
steradian = cvar.steradian
rad = cvar.rad
mrad = cvar.mrad
sr = cvar.sr
deg = cvar.deg
tesla = cvar.tesla
gauss = cvar.gauss

class Beam(IParameterized):
    """


    Ideal collimated beam defined by wavelength, direction and intensity.

    C++ includes: Beam.h

    """

    __swig_setmethods__ = {}
    for _s in [IParameterized]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Beam, name, value)
    __swig_getmethods__ = {}
    for _s in [IParameterized]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Beam, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Beam self) -> Beam
        __init__(Beam self, Beam other) -> Beam

        Beam::Beam(const Beam &other)

        """
        this = _libBornAgainCore.new_Beam(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_Beam
    __del__ = lambda self: None

    def getCentralK(self):
        """
        getCentralK(Beam self) -> kvector_t

        kvector_t Beam::getCentralK() const

        Returns the wavevector. 

        """
        return _libBornAgainCore.Beam_getCentralK(self)


    def setCentralK(self, wavelength, alpha_i, phi_i):
        """
        setCentralK(Beam self, double wavelength, double alpha_i, double phi_i)

        void Beam::setCentralK(double wavelength, double alpha_i, double phi_i)

        Sets the wavevector in terms of wavelength and incoming angles. 

        """
        return _libBornAgainCore.Beam_setCentralK(self, wavelength, alpha_i, phi_i)


    def getIntensity(self):
        """
        getIntensity(Beam self) -> double

        double Beam::getIntensity() const

        Returns the beam intensity in neutrons/sec. 

        """
        return _libBornAgainCore.Beam_getIntensity(self)


    def setIntensity(self, intensity):
        """
        setIntensity(Beam self, double intensity)

        void Beam::setIntensity(double intensity)

        Sets the beam intensity in neutrons/sec. 

        """
        return _libBornAgainCore.Beam_setIntensity(self, intensity)


    def setPolarization(self, bloch_vector):
        """
        setPolarization(Beam self, kvector_t bloch_vector)

        void Beam::setPolarization(const kvector_t bloch_vector)

        Sets the polarization density matrix according to the given Bloch vector. 

        """
        return _libBornAgainCore.Beam_setPolarization(self, bloch_vector)


    def getWavelength(self):
        """
        getWavelength(Beam self) -> double

        double Beam::getWavelength() const

        """
        return _libBornAgainCore.Beam_getWavelength(self)


    def getAlpha(self):
        """
        getAlpha(Beam self) -> double

        double Beam::getAlpha() const

        """
        return _libBornAgainCore.Beam_getAlpha(self)


    def getPhi(self):
        """
        getPhi(Beam self) -> double

        double Beam::getPhi() const

        """
        return _libBornAgainCore.Beam_getPhi(self)

Beam_swigregister = _libBornAgainCore.Beam_swigregister
Beam_swigregister(Beam)

class Bin1D(_object):
    """Proxy of C++ Bin1D class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Bin1D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Bin1D, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bin1D self) -> Bin1D
        __init__(Bin1D self, double lower, double upper) -> Bin1D

        Bin1D::Bin1D(double lower, double upper)

        """
        this = _libBornAgainCore.new_Bin1D(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["m_lower"] = _libBornAgainCore.Bin1D_m_lower_set
    __swig_getmethods__["m_lower"] = _libBornAgainCore.Bin1D_m_lower_get
    if _newclass:
        m_lower = _swig_property(_libBornAgainCore.Bin1D_m_lower_get, _libBornAgainCore.Bin1D_m_lower_set)
    __swig_setmethods__["m_upper"] = _libBornAgainCore.Bin1D_m_upper_set
    __swig_getmethods__["m_upper"] = _libBornAgainCore.Bin1D_m_upper_get
    if _newclass:
        m_upper = _swig_property(_libBornAgainCore.Bin1D_m_upper_get, _libBornAgainCore.Bin1D_m_upper_set)

    def getMidPoint(self):
        """
        getMidPoint(Bin1D self) -> double

        double Bin1D::getMidPoint() const

        """
        return _libBornAgainCore.Bin1D_getMidPoint(self)


    def getBinSize(self):
        """
        getBinSize(Bin1D self) -> double

        double Bin1D::getBinSize() const

        """
        return _libBornAgainCore.Bin1D_getBinSize(self)

    __swig_destroy__ = _libBornAgainCore.delete_Bin1D
    __del__ = lambda self: None
Bin1D_swigregister = _libBornAgainCore.Bin1D_swigregister
Bin1D_swigregister(Bin1D)


def BinContains(bin, value):
    """
    BinContains(Bin1D bin, double value) -> bool

    bool BinContains(const Bin1D &bin, double value)

    Checks if value is contained in bin: value in [m_lower, m_upper) 

    """
    return _libBornAgainCore.BinContains(bin, value)
class Bin1DKVector(_object):
    """


    An one-dimensional range of kvector_t's.

    C++ includes: Bin.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Bin1DKVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Bin1DKVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bin1DKVector self) -> Bin1DKVector
        __init__(Bin1DKVector self, kvector_t lower, kvector_t upper) -> Bin1DKVector
        __init__(Bin1DKVector self, double wavelength, Bin1D alpha_bin, Bin1D phi_bin) -> Bin1DKVector

        Bin1DKVector::Bin1DKVector(double wavelength, const Bin1D &alpha_bin, const Bin1D &phi_bin)

        creation on  Bin1DKVector from alpha and phi bins 

        """
        this = _libBornAgainCore.new_Bin1DKVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def getMidPoint(self):
        """
        getMidPoint(Bin1DKVector self) -> kvector_t

        kvector_t Bin1DKVector::getMidPoint() const

        """
        return _libBornAgainCore.Bin1DKVector_getMidPoint(self)


    def getDelta(self):
        """
        getDelta(Bin1DKVector self) -> kvector_t

        kvector_t Bin1DKVector::getDelta() const

        """
        return _libBornAgainCore.Bin1DKVector_getDelta(self)

    __swig_setmethods__["m_q_lower"] = _libBornAgainCore.Bin1DKVector_m_q_lower_set
    __swig_getmethods__["m_q_lower"] = _libBornAgainCore.Bin1DKVector_m_q_lower_get
    if _newclass:
        m_q_lower = _swig_property(_libBornAgainCore.Bin1DKVector_m_q_lower_get, _libBornAgainCore.Bin1DKVector_m_q_lower_set)
    __swig_setmethods__["m_q_upper"] = _libBornAgainCore.Bin1DKVector_m_q_upper_set
    __swig_getmethods__["m_q_upper"] = _libBornAgainCore.Bin1DKVector_m_q_upper_get
    if _newclass:
        m_q_upper = _swig_property(_libBornAgainCore.Bin1DKVector_m_q_upper_get, _libBornAgainCore.Bin1DKVector_m_q_upper_set)
    __swig_destroy__ = _libBornAgainCore.delete_Bin1DKVector
    __del__ = lambda self: None
Bin1DKVector_swigregister = _libBornAgainCore.Bin1DKVector_swigregister
Bin1DKVector_swigregister(Bin1DKVector)

class Bin1DCVector(_object):
    """


    An one-dimensional range of cvector_t's.

    C++ includes: Bin.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Bin1DCVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Bin1DCVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bin1DCVector self) -> Bin1DCVector
        __init__(Bin1DCVector self, cvector_t lower, cvector_t upper) -> Bin1DCVector
        __init__(Bin1DCVector self, double wavelength, Bin1D alpha_bin, Bin1D phi_bin) -> Bin1DCVector

        Bin1DCVector::Bin1DCVector(double wavelength, const Bin1D &alpha_bin, const Bin1D &phi_bin)

        creation on  Bin1DCVector from alpha and phi bins 

        """
        this = _libBornAgainCore.new_Bin1DCVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def getMidPoint(self):
        """
        getMidPoint(Bin1DCVector self) -> cvector_t

        cvector_t Bin1DCVector::getMidPoint() const

        """
        return _libBornAgainCore.Bin1DCVector_getMidPoint(self)


    def getDelta(self):
        """
        getDelta(Bin1DCVector self) -> cvector_t

        cvector_t Bin1DCVector::getDelta() const

        """
        return _libBornAgainCore.Bin1DCVector_getDelta(self)

    __swig_setmethods__["m_q_lower"] = _libBornAgainCore.Bin1DCVector_m_q_lower_set
    __swig_getmethods__["m_q_lower"] = _libBornAgainCore.Bin1DCVector_m_q_lower_get
    if _newclass:
        m_q_lower = _swig_property(_libBornAgainCore.Bin1DCVector_m_q_lower_get, _libBornAgainCore.Bin1DCVector_m_q_lower_set)
    __swig_setmethods__["m_q_upper"] = _libBornAgainCore.Bin1DCVector_m_q_upper_set
    __swig_getmethods__["m_q_upper"] = _libBornAgainCore.Bin1DCVector_m_q_upper_get
    if _newclass:
        m_q_upper = _swig_property(_libBornAgainCore.Bin1DCVector_m_q_upper_get, _libBornAgainCore.Bin1DCVector_m_q_upper_set)
    __swig_destroy__ = _libBornAgainCore.delete_Bin1DCVector
    __del__ = lambda self: None
Bin1DCVector_swigregister = _libBornAgainCore.Bin1DCVector_swigregister
Bin1DCVector_swigregister(Bin1DCVector)

class IAxis(_object):
    """


    Interface for one-dimensional axes.

    C++ includes: IAxis.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IAxis, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IAxis, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self):
        """
        clone(IAxis self) -> IAxis

        virtual IAxis* IAxis::clone() const =0

        clone function 

        """
        return _libBornAgainCore.IAxis_clone(self)


    def createDoubleBinSize(self):
        """
        createDoubleBinSize(IAxis self) -> IAxis

        IAxis * IAxis::createDoubleBinSize() const

        Creates a new axis with half the number of bins. 

        """
        return _libBornAgainCore.IAxis_createDoubleBinSize(self)

    __swig_destroy__ = _libBornAgainCore.delete_IAxis
    __del__ = lambda self: None

    def size(self):
        """
        size(IAxis self) -> size_t

        virtual size_t IAxis::size() const =0

        retrieve the number of bins 

        """
        return _libBornAgainCore.IAxis_size(self)


    def getName(self):
        """
        getName(IAxis self) -> std::string

        std::string IAxis::getName() const

        retrieve the label of the axis 

        """
        return _libBornAgainCore.IAxis_getName(self)


    def setName(self, name):
        """
        setName(IAxis self, std::string name)

        void IAxis::setName(std::string name)

        Sets the axis label. 

        """
        return _libBornAgainCore.IAxis_setName(self, name)


    def getBin(self, index):
        """
        getBin(IAxis self, size_t index) -> Bin1D

        virtual Bin1D IAxis::getBin(size_t index) const =0

        retrieve a 1d bin for the given index 

        """
        return _libBornAgainCore.IAxis_getBin(self, index)


    def getMin(self):
        """
        getMin(IAxis self) -> double

        virtual double IAxis::getMin() const =0

        Returns value of first point of axis. 

        """
        return _libBornAgainCore.IAxis_getMin(self)


    def getMax(self):
        """
        getMax(IAxis self) -> double

        virtual double IAxis::getMax() const =0

        Returns value of last point of axis. 

        """
        return _libBornAgainCore.IAxis_getMax(self)


    def getBinCenter(self, index):
        """
        getBinCenter(IAxis self, size_t index) -> double

        virtual double IAxis::getBinCenter(size_t index) const =0

        """
        return _libBornAgainCore.IAxis_getBinCenter(self, index)


    def findClosestIndex(self, value):
        """
        findClosestIndex(IAxis self, double value) -> size_t

        virtual size_t IAxis::findClosestIndex(double value) const =0

        find bin index which is best match for given value 

        """
        return _libBornAgainCore.IAxis_findClosestIndex(self, value)


    def findIndex(self, value):
        """
        findIndex(IAxis self, double value) -> size_t

        size_t IAxis::findIndex(double value) const

        find index of bin that contains the given value returns  size() when value is not found 

        """
        return _libBornAgainCore.IAxis_findIndex(self, value)


    def __eq__(self, right):
        """__eq__(IAxis self, IAxis right) -> bool"""
        return _libBornAgainCore.IAxis___eq__(self, right)


    def __ne__(self, right):
        """__ne__(IAxis self, IAxis right) -> bool"""
        return _libBornAgainCore.IAxis___ne__(self, right)


    def getBinCenters(self):
        """
        getBinCenters(IAxis self) -> vdouble1d_t

        std::vector< double > IAxis::getBinCenters() const

        """
        return _libBornAgainCore.IAxis_getBinCenters(self)


    def getBinBoundaries(self):
        """
        getBinBoundaries(IAxis self) -> vdouble1d_t

        std::vector< double > IAxis::getBinBoundaries() const

        """
        return _libBornAgainCore.IAxis_getBinBoundaries(self)


    def createClippedAxis(self, left, right):
        """
        createClippedAxis(IAxis self, double left, double right) -> IAxis

        IAxis * IAxis::createClippedAxis(double left, double right) const

        Creates a new clipped axis. 

        """
        return _libBornAgainCore.IAxis_createClippedAxis(self, left, right)


    def contains(self, value):
        """
        contains(IAxis self, double value) -> bool

        bool IAxis::contains(double value) const

        Returns true if axis contains given point. 

        """
        return _libBornAgainCore.IAxis_contains(self, value)

IAxis_swigregister = _libBornAgainCore.IAxis_swigregister
IAxis_swigregister(IAxis)


def HaveSameNameAndShape(left, right):
    """
    HaveSameNameAndShape(IAxis left, IAxis right) -> bool

    bool HaveSameNameAndShape(const IAxis &left, const IAxis &right)

    global helper function for comparison of axes 

    """
    return _libBornAgainCore.HaveSameNameAndShape(left, right)
class VariableBinAxis(IAxis):
    """


    Axis with variable bin size.

    C++ includes: VariableBinAxis.h

    """

    __swig_setmethods__ = {}
    for _s in [IAxis]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VariableBinAxis, name, value)
    __swig_getmethods__ = {}
    for _s in [IAxis]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VariableBinAxis, name)
    __repr__ = _swig_repr

    def __init__(self, name, nbins, bin_boundaries):
        """
        __init__(VariableBinAxis self, std::string const & name, size_t nbins, vdouble1d_t bin_boundaries) -> VariableBinAxis

        VariableBinAxis::VariableBinAxis(const std::string &name, size_t nbins, const std::vector< double > &bin_boundaries)

        VariableBinAxis constructor.

        Parameters:
        -----------

        name: 
        Axis name

        nbins: 
        number of bins

        bin_boundaries: 
        Array of size nbins+1 containing low-edges for each bin and upper edge of last bin. 

        """
        this = _libBornAgainCore.new_VariableBinAxis(name, nbins, bin_boundaries)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_VariableBinAxis
    __del__ = lambda self: None

    def clone(self):
        """
        clone(VariableBinAxis self) -> VariableBinAxis

        VariableBinAxis * VariableBinAxis::clone() const

        clone function 

        """
        return _libBornAgainCore.VariableBinAxis_clone(self)


    def size(self):
        """
        size(VariableBinAxis self) -> size_t

        size_t VariableBinAxis::size() const

        retrieve the number of bins 

        """
        return _libBornAgainCore.VariableBinAxis_size(self)


    def getBin(self, index):
        """
        getBin(VariableBinAxis self, size_t index) -> Bin1D

        Bin1D VariableBinAxis::getBin(size_t index) const

        retrieve a 1d bin for the given index 

        """
        return _libBornAgainCore.VariableBinAxis_getBin(self, index)


    def getMin(self):
        """
        getMin(VariableBinAxis self) -> double

        double VariableBinAxis::getMin() const

        Returns value of first point of axis. 

        """
        return _libBornAgainCore.VariableBinAxis_getMin(self)


    def getMax(self):
        """
        getMax(VariableBinAxis self) -> double

        double VariableBinAxis::getMax() const

        Returns value of last point of axis. 

        """
        return _libBornAgainCore.VariableBinAxis_getMax(self)


    def getBinCenter(self, index):
        """
        getBinCenter(VariableBinAxis self, size_t index) -> double

        double VariableBinAxis::getBinCenter(size_t index) const

        """
        return _libBornAgainCore.VariableBinAxis_getBinCenter(self, index)


    def findClosestIndex(self, value):
        """
        findClosestIndex(VariableBinAxis self, double value) -> size_t

        size_t VariableBinAxis::findClosestIndex(double value) const

        find bin index which is best match for given value 

        """
        return _libBornAgainCore.VariableBinAxis_findClosestIndex(self, value)


    def getBinCenters(self):
        """
        getBinCenters(VariableBinAxis self) -> vdouble1d_t

        std::vector< double > VariableBinAxis::getBinCenters() const

        """
        return _libBornAgainCore.VariableBinAxis_getBinCenters(self)


    def getBinBoundaries(self):
        """
        getBinBoundaries(VariableBinAxis self) -> vdouble1d_t

        std::vector<double> VariableBinAxis::getBinBoundaries() const

        """
        return _libBornAgainCore.VariableBinAxis_getBinBoundaries(self)


    def createClippedAxis(self, left, right):
        """
        createClippedAxis(VariableBinAxis self, double left, double right) -> VariableBinAxis

        VariableBinAxis * VariableBinAxis::createClippedAxis(double left, double right) const

        Creates a new clipped axis. 

        """
        return _libBornAgainCore.VariableBinAxis_createClippedAxis(self, left, right)


    def __getitem__(self, i):
        """__getitem__(VariableBinAxis self, unsigned int i) -> double"""
        return _libBornAgainCore.VariableBinAxis___getitem__(self, i)

VariableBinAxis_swigregister = _libBornAgainCore.VariableBinAxis_swigregister
VariableBinAxis_swigregister(VariableBinAxis)

class ConstKBinAxis(VariableBinAxis):
    """


    Axis with fixed bin size in sin(angle) space.

    C++ includes: ConstKBinAxis.h

    """

    __swig_setmethods__ = {}
    for _s in [VariableBinAxis]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstKBinAxis, name, value)
    __swig_getmethods__ = {}
    for _s in [VariableBinAxis]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstKBinAxis, name)
    __repr__ = _swig_repr

    def __init__(self, name, nbins, start, end):
        """
        __init__(ConstKBinAxis self, std::string const & name, size_t nbins, double start, double end) -> ConstKBinAxis

        ConstKBinAxis::ConstKBinAxis(const std::string &name, size_t nbins, double start, double end)

        ConstKBinAxis constructor.

        Parameters:
        -----------

        name: 
        Axis name

        nbins: 
        number of bins

        start: 
        low edge of first bin

        end: 
        upper edge of last bin 

        """
        this = _libBornAgainCore.new_ConstKBinAxis(name, nbins, start, end)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_ConstKBinAxis
    __del__ = lambda self: None

    def clone(self):
        """
        clone(ConstKBinAxis self) -> ConstKBinAxis

        ConstKBinAxis * ConstKBinAxis::clone() const

        clone function 

        """
        return _libBornAgainCore.ConstKBinAxis_clone(self)


    def createClippedAxis(self, left, right):
        """
        createClippedAxis(ConstKBinAxis self, double left, double right) -> ConstKBinAxis

        ConstKBinAxis * ConstKBinAxis::createClippedAxis(double left, double right) const

        Creates a new clipped axis. 

        """
        return _libBornAgainCore.ConstKBinAxis_createClippedAxis(self, left, right)

ConstKBinAxis_swigregister = _libBornAgainCore.ConstKBinAxis_swigregister
ConstKBinAxis_swigregister(ConstKBinAxis)

class CustomBinAxis(VariableBinAxis):
    """


    Axis with fixed bin size in sin(angle) space used for numerical comparison with IsGisaxs. The main feature of the axis is that it produces zero bin sizes.

    C++ includes: CustomBinAxis.h

    """

    __swig_setmethods__ = {}
    for _s in [VariableBinAxis]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomBinAxis, name, value)
    __swig_getmethods__ = {}
    for _s in [VariableBinAxis]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomBinAxis, name)
    __repr__ = _swig_repr

    def __init__(self, name, nbins, start, end):
        """
        __init__(CustomBinAxis self, std::string const & name, size_t nbins, double start, double end) -> CustomBinAxis

        CustomBinAxis::CustomBinAxis(const std::string &name, size_t nbins, double start, double end)

        CustomBinAxis constructor.

        Parameters:
        -----------

        name: 
        Axis name

        nbins: 
        number of bins

        start: 
        center of first bin (IsGisaxs convention)

        end: 
        center of last bin (IsGisaxs convention) 

        """
        this = _libBornAgainCore.new_CustomBinAxis(name, nbins, start, end)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_CustomBinAxis
    __del__ = lambda self: None

    def clone(self):
        """
        clone(CustomBinAxis self) -> CustomBinAxis

        CustomBinAxis * CustomBinAxis::clone() const

        clone function 

        """
        return _libBornAgainCore.CustomBinAxis_clone(self)


    def getBin(self, index):
        """
        getBin(CustomBinAxis self, size_t index) -> Bin1D

        Bin1D CustomBinAxis::getBin(size_t index) const

        retrieve a 1d bin for the given index 

        """
        return _libBornAgainCore.CustomBinAxis_getBin(self, index)


    def getBinCenters(self):
        """
        getBinCenters(CustomBinAxis self) -> vdouble1d_t

        std::vector< double > CustomBinAxis::getBinCenters() const

        """
        return _libBornAgainCore.CustomBinAxis_getBinCenters(self)


    def createClippedAxis(self, left, right):
        """
        createClippedAxis(CustomBinAxis self, double left, double right) -> CustomBinAxis

        CustomBinAxis * CustomBinAxis::createClippedAxis(double left, double right) const

        Creates a new clipped axis. 

        """
        return _libBornAgainCore.CustomBinAxis_createClippedAxis(self, left, right)

CustomBinAxis_swigregister = _libBornAgainCore.CustomBinAxis_swigregister
CustomBinAxis_swigregister(CustomBinAxis)

class IShape2D(ICloneable, INamed):
    """Proxy of C++ IShape2D class."""

    __swig_setmethods__ = {}
    for _s in [ICloneable, INamed]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IShape2D, name, value)
    __swig_getmethods__ = {}
    for _s in [ICloneable, INamed]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IShape2D, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self):
        """
        clone(IShape2D self) -> IShape2D

        virtual ICloneable* ICloneable::clone() const =0

        """
        return _libBornAgainCore.IShape2D_clone(self)


    def contains(self, *args):
        """
        contains(IShape2D self, double x, double y) -> bool
        contains(IShape2D self, Bin1D binx, Bin1D biny) -> bool
        """
        return _libBornAgainCore.IShape2D_contains(self, *args)

    __swig_destroy__ = _libBornAgainCore.delete_IShape2D
    __del__ = lambda self: None
IShape2D_swigregister = _libBornAgainCore.IShape2D_swigregister
IShape2D_swigregister(IShape2D)

class ISample(ICloneable, IParameterized):
    """


    Pure virtual base class for sample components and properties related to scattering.

    Inherited by  ICompositeSample,  IFormFactor,  IInterferenceFunction,  IRoughness,  IRotation. So it is much more basic and abstract than the name "ISample" suggests.

    Since  ICompositeSample contains a vector of  ISample's, we provide here some machinery for iterating through a tree (getMaterial, containedMaterials, containedSubclasses, ..). The functions getChildren and size, completely trivial here, become meaningful through their overloads in  ICompositeSample.

    C++ includes: ISample.h

    """

    __swig_setmethods__ = {}
    for _s in [ICloneable, IParameterized]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ISample, name, value)
    __swig_getmethods__ = {}
    for _s in [ICloneable, IParameterized]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ISample, name)
    __repr__ = _swig_repr

    def clone(self):
        """
        clone(ISample self) -> ISample

        ISample* ISample::clone() const override=0

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.ISample_clone(self)


    def cloneInvertB(self):
        """
        cloneInvertB(ISample self) -> ISample

        ISample * ISample::cloneInvertB() const

        Returns a clone with inverted magnetic fields. 

        """
        return _libBornAgainCore.ISample_cloneInvertB(self)


    def accept(self, p_visitor):
        """
        accept(ISample self, ISampleVisitor p_visitor)

        virtual void ISample::accept(ISampleVisitor *p_visitor) const =0

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.ISample_accept(self, p_visitor)


    def to_str(self, indent=0):
        """
        to_str(ISample self, int indent=0) -> std::string
        to_str(ISample self) -> std::string

        std::string ISample::to_str(int indent=0) const

        Returns textual representation of this and its descendants. 

        """
        return _libBornAgainCore.ISample_to_str(self, indent)


    def getMaterial(self):
        """
        getMaterial(ISample self) -> IMaterial

        virtual const IMaterial* ISample::getMaterial() const

        Returns nullptr, unless overwritten to return a specific material. 

        """
        return _libBornAgainCore.ISample_getMaterial(self)


    def getAmbientMaterial(self):
        """
        getAmbientMaterial(ISample self) -> IMaterial

        virtual const IMaterial* ISample::getAmbientMaterial() const

        Returns nullptr, unless overwritten to return a specific material. 

        """
        return _libBornAgainCore.ISample_getAmbientMaterial(self)


    def containedMaterials(self):
        """
        containedMaterials(ISample self) -> std::vector< IMaterial const *,std::allocator< IMaterial const * > >

        std::vector< const IMaterial * > ISample::containedMaterials() const

        Returns set of unique materials contained in this  ISample. 

        """
        return _libBornAgainCore.ISample_containedMaterials(self)


    def getChildren(self):
        """
        getChildren(ISample self) -> swig_dummy_type_const_isample_vector

        virtual std::vector<const ISample*> ISample::getChildren() const

        Returns a vector of children. 

        """
        return _libBornAgainCore.ISample_getChildren(self)


    def size(self):
        """
        size(ISample self) -> size_t

        virtual size_t ISample::size() const

        Returns number of children. 

        """
        return _libBornAgainCore.ISample_size(self)


    def __init__(self):
        """
        __init__(ISample self) -> ISample



        Pure virtual base class for sample components and properties related to scattering.

        Inherited by  ICompositeSample,  IFormFactor,  IInterferenceFunction,  IRoughness,  IRotation. So it is much more basic and abstract than the name "ISample" suggests.

        Since  ICompositeSample contains a vector of  ISample's, we provide here some machinery for iterating through a tree (getMaterial, containedMaterials, containedSubclasses, ..). The functions getChildren and size, completely trivial here, become meaningful through their overloads in  ICompositeSample.

        C++ includes: ISample.h

        """
        if self.__class__ == ISample:
            _self = None
        else:
            _self = self
        this = _libBornAgainCore.new_ISample(_self, )
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_ISample
    __del__ = lambda self: None
    def __disown__(self):
        self.this.disown()
        _libBornAgainCore.disown_ISample(self)
        return weakref_proxy(self)

    def onChange(self):
        """onChange(ISample self)"""
        return _libBornAgainCore.ISample_onChange(self)


    def _print(self, ostr):
        """_print(ISample self, std::ostream & ostr)"""
        return _libBornAgainCore.ISample__print(self, ostr)

ISample_swigregister = _libBornAgainCore.ISample_swigregister
ISample_swigregister(ISample)

class swig_dummy_type_isample_vector(_object):
    """Proxy of C++ std::vector<(p.ISample)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, swig_dummy_type_isample_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, swig_dummy_type_isample_vector, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(swig_dummy_type_isample_vector self) -> SwigPyIterator"""
        return _libBornAgainCore.swig_dummy_type_isample_vector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(swig_dummy_type_isample_vector self) -> bool"""
        return _libBornAgainCore.swig_dummy_type_isample_vector___nonzero__(self)


    def __bool__(self):
        """__bool__(swig_dummy_type_isample_vector self) -> bool"""
        return _libBornAgainCore.swig_dummy_type_isample_vector___bool__(self)


    def __len__(self):
        """__len__(swig_dummy_type_isample_vector self) -> std::vector< ISample * >::size_type"""
        return _libBornAgainCore.swig_dummy_type_isample_vector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(swig_dummy_type_isample_vector self, std::vector< ISample * >::difference_type i, std::vector< ISample * >::difference_type j) -> swig_dummy_type_isample_vector"""
        return _libBornAgainCore.swig_dummy_type_isample_vector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(swig_dummy_type_isample_vector self, std::vector< ISample * >::difference_type i, std::vector< ISample * >::difference_type j)
        __setslice__(swig_dummy_type_isample_vector self, std::vector< ISample * >::difference_type i, std::vector< ISample * >::difference_type j, swig_dummy_type_isample_vector v)
        """
        return _libBornAgainCore.swig_dummy_type_isample_vector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(swig_dummy_type_isample_vector self, std::vector< ISample * >::difference_type i, std::vector< ISample * >::difference_type j)"""
        return _libBornAgainCore.swig_dummy_type_isample_vector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(swig_dummy_type_isample_vector self, std::vector< ISample * >::difference_type i)
        __delitem__(swig_dummy_type_isample_vector self, PySliceObject * slice)
        """
        return _libBornAgainCore.swig_dummy_type_isample_vector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(swig_dummy_type_isample_vector self, PySliceObject * slice) -> swig_dummy_type_isample_vector
        __getitem__(swig_dummy_type_isample_vector self, std::vector< ISample * >::difference_type i) -> ISample
        """
        return _libBornAgainCore.swig_dummy_type_isample_vector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(swig_dummy_type_isample_vector self, PySliceObject * slice, swig_dummy_type_isample_vector v)
        __setitem__(swig_dummy_type_isample_vector self, PySliceObject * slice)
        __setitem__(swig_dummy_type_isample_vector self, std::vector< ISample * >::difference_type i, ISample x)
        """
        return _libBornAgainCore.swig_dummy_type_isample_vector___setitem__(self, *args)


    def pop(self):
        """pop(swig_dummy_type_isample_vector self) -> ISample"""
        return _libBornAgainCore.swig_dummy_type_isample_vector_pop(self)


    def append(self, x):
        """append(swig_dummy_type_isample_vector self, ISample x)"""
        return _libBornAgainCore.swig_dummy_type_isample_vector_append(self, x)


    def empty(self):
        """empty(swig_dummy_type_isample_vector self) -> bool"""
        return _libBornAgainCore.swig_dummy_type_isample_vector_empty(self)


    def size(self):
        """size(swig_dummy_type_isample_vector self) -> std::vector< ISample * >::size_type"""
        return _libBornAgainCore.swig_dummy_type_isample_vector_size(self)


    def swap(self, v):
        """
        swap(swig_dummy_type_isample_vector self, swig_dummy_type_isample_vector v)

        void swap(OutputDataIterator< TValue, TContainer > &left, OutputDataIterator< TValue, TContainer > &right)

        make Swappable 

        """
        return _libBornAgainCore.swig_dummy_type_isample_vector_swap(self, v)


    def begin(self):
        """begin(swig_dummy_type_isample_vector self) -> std::vector< ISample * >::iterator"""
        return _libBornAgainCore.swig_dummy_type_isample_vector_begin(self)


    def end(self):
        """end(swig_dummy_type_isample_vector self) -> std::vector< ISample * >::iterator"""
        return _libBornAgainCore.swig_dummy_type_isample_vector_end(self)


    def rbegin(self):
        """rbegin(swig_dummy_type_isample_vector self) -> std::vector< ISample * >::reverse_iterator"""
        return _libBornAgainCore.swig_dummy_type_isample_vector_rbegin(self)


    def rend(self):
        """rend(swig_dummy_type_isample_vector self) -> std::vector< ISample * >::reverse_iterator"""
        return _libBornAgainCore.swig_dummy_type_isample_vector_rend(self)


    def clear(self):
        """clear(swig_dummy_type_isample_vector self)"""
        return _libBornAgainCore.swig_dummy_type_isample_vector_clear(self)


    def get_allocator(self):
        """get_allocator(swig_dummy_type_isample_vector self) -> std::vector< ISample * >::allocator_type"""
        return _libBornAgainCore.swig_dummy_type_isample_vector_get_allocator(self)


    def pop_back(self):
        """pop_back(swig_dummy_type_isample_vector self)"""
        return _libBornAgainCore.swig_dummy_type_isample_vector_pop_back(self)


    def erase(self, *args):
        """
        erase(swig_dummy_type_isample_vector self, std::vector< ISample * >::iterator pos) -> std::vector< ISample * >::iterator
        erase(swig_dummy_type_isample_vector self, std::vector< ISample * >::iterator first, std::vector< ISample * >::iterator last) -> std::vector< ISample * >::iterator
        """
        return _libBornAgainCore.swig_dummy_type_isample_vector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(p.ISample)> self) -> swig_dummy_type_isample_vector
        __init__(std::vector<(p.ISample)> self, swig_dummy_type_isample_vector arg2) -> swig_dummy_type_isample_vector
        __init__(std::vector<(p.ISample)> self, std::vector< ISample * >::size_type size) -> swig_dummy_type_isample_vector
        __init__(std::vector<(p.ISample)> self, std::vector< ISample * >::size_type size, ISample value) -> swig_dummy_type_isample_vector
        """
        this = _libBornAgainCore.new_swig_dummy_type_isample_vector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        """push_back(swig_dummy_type_isample_vector self, ISample x)"""
        return _libBornAgainCore.swig_dummy_type_isample_vector_push_back(self, x)


    def front(self):
        """front(swig_dummy_type_isample_vector self) -> ISample"""
        return _libBornAgainCore.swig_dummy_type_isample_vector_front(self)


    def back(self):
        """back(swig_dummy_type_isample_vector self) -> ISample"""
        return _libBornAgainCore.swig_dummy_type_isample_vector_back(self)


    def assign(self, n, x):
        """assign(swig_dummy_type_isample_vector self, std::vector< ISample * >::size_type n, ISample x)"""
        return _libBornAgainCore.swig_dummy_type_isample_vector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(swig_dummy_type_isample_vector self, std::vector< ISample * >::size_type new_size)
        resize(swig_dummy_type_isample_vector self, std::vector< ISample * >::size_type new_size, ISample x)
        """
        return _libBornAgainCore.swig_dummy_type_isample_vector_resize(self, *args)


    def insert(self, *args):
        """
        insert(swig_dummy_type_isample_vector self, std::vector< ISample * >::iterator pos, ISample x) -> std::vector< ISample * >::iterator
        insert(swig_dummy_type_isample_vector self, std::vector< ISample * >::iterator pos, std::vector< ISample * >::size_type n, ISample x)
        """
        return _libBornAgainCore.swig_dummy_type_isample_vector_insert(self, *args)


    def reserve(self, n):
        """reserve(swig_dummy_type_isample_vector self, std::vector< ISample * >::size_type n)"""
        return _libBornAgainCore.swig_dummy_type_isample_vector_reserve(self, n)


    def capacity(self):
        """capacity(swig_dummy_type_isample_vector self) -> std::vector< ISample * >::size_type"""
        return _libBornAgainCore.swig_dummy_type_isample_vector_capacity(self)

    __swig_destroy__ = _libBornAgainCore.delete_swig_dummy_type_isample_vector
    __del__ = lambda self: None
swig_dummy_type_isample_vector_swigregister = _libBornAgainCore.swig_dummy_type_isample_vector_swigregister
swig_dummy_type_isample_vector_swigregister(swig_dummy_type_isample_vector)

class swig_dummy_type_const_isample_vector(_object):
    """Proxy of C++ std::vector<(p.q(const).ISample)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, swig_dummy_type_const_isample_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, swig_dummy_type_const_isample_vector, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(swig_dummy_type_const_isample_vector self) -> SwigPyIterator"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(swig_dummy_type_const_isample_vector self) -> bool"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector___nonzero__(self)


    def __bool__(self):
        """__bool__(swig_dummy_type_const_isample_vector self) -> bool"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector___bool__(self)


    def __len__(self):
        """__len__(swig_dummy_type_const_isample_vector self) -> std::vector< ISample const * >::size_type"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(swig_dummy_type_const_isample_vector self, std::vector< ISample const * >::difference_type i, std::vector< ISample const * >::difference_type j) -> swig_dummy_type_const_isample_vector"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(swig_dummy_type_const_isample_vector self, std::vector< ISample const * >::difference_type i, std::vector< ISample const * >::difference_type j)
        __setslice__(swig_dummy_type_const_isample_vector self, std::vector< ISample const * >::difference_type i, std::vector< ISample const * >::difference_type j, swig_dummy_type_const_isample_vector v)
        """
        return _libBornAgainCore.swig_dummy_type_const_isample_vector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(swig_dummy_type_const_isample_vector self, std::vector< ISample const * >::difference_type i, std::vector< ISample const * >::difference_type j)"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(swig_dummy_type_const_isample_vector self, std::vector< ISample const * >::difference_type i)
        __delitem__(swig_dummy_type_const_isample_vector self, PySliceObject * slice)
        """
        return _libBornAgainCore.swig_dummy_type_const_isample_vector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(swig_dummy_type_const_isample_vector self, PySliceObject * slice) -> swig_dummy_type_const_isample_vector
        __getitem__(swig_dummy_type_const_isample_vector self, std::vector< ISample const * >::difference_type i) -> ISample
        """
        return _libBornAgainCore.swig_dummy_type_const_isample_vector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(swig_dummy_type_const_isample_vector self, PySliceObject * slice, swig_dummy_type_const_isample_vector v)
        __setitem__(swig_dummy_type_const_isample_vector self, PySliceObject * slice)
        __setitem__(swig_dummy_type_const_isample_vector self, std::vector< ISample const * >::difference_type i, ISample x)
        """
        return _libBornAgainCore.swig_dummy_type_const_isample_vector___setitem__(self, *args)


    def pop(self):
        """pop(swig_dummy_type_const_isample_vector self) -> ISample"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_pop(self)


    def append(self, x):
        """append(swig_dummy_type_const_isample_vector self, ISample x)"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_append(self, x)


    def empty(self):
        """empty(swig_dummy_type_const_isample_vector self) -> bool"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_empty(self)


    def size(self):
        """size(swig_dummy_type_const_isample_vector self) -> std::vector< ISample const * >::size_type"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_size(self)


    def swap(self, v):
        """
        swap(swig_dummy_type_const_isample_vector self, swig_dummy_type_const_isample_vector v)

        void swap(OutputDataIterator< TValue, TContainer > &left, OutputDataIterator< TValue, TContainer > &right)

        make Swappable 

        """
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_swap(self, v)


    def begin(self):
        """begin(swig_dummy_type_const_isample_vector self) -> std::vector< ISample const * >::iterator"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_begin(self)


    def end(self):
        """end(swig_dummy_type_const_isample_vector self) -> std::vector< ISample const * >::iterator"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_end(self)


    def rbegin(self):
        """rbegin(swig_dummy_type_const_isample_vector self) -> std::vector< ISample const * >::reverse_iterator"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_rbegin(self)


    def rend(self):
        """rend(swig_dummy_type_const_isample_vector self) -> std::vector< ISample const * >::reverse_iterator"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_rend(self)


    def clear(self):
        """clear(swig_dummy_type_const_isample_vector self)"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_clear(self)


    def get_allocator(self):
        """get_allocator(swig_dummy_type_const_isample_vector self) -> std::vector< ISample const * >::allocator_type"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_get_allocator(self)


    def pop_back(self):
        """pop_back(swig_dummy_type_const_isample_vector self)"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_pop_back(self)


    def erase(self, *args):
        """
        erase(swig_dummy_type_const_isample_vector self, std::vector< ISample const * >::iterator pos) -> std::vector< ISample const * >::iterator
        erase(swig_dummy_type_const_isample_vector self, std::vector< ISample const * >::iterator first, std::vector< ISample const * >::iterator last) -> std::vector< ISample const * >::iterator
        """
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(p.q(const).ISample)> self) -> swig_dummy_type_const_isample_vector
        __init__(std::vector<(p.q(const).ISample)> self, swig_dummy_type_const_isample_vector arg2) -> swig_dummy_type_const_isample_vector
        __init__(std::vector<(p.q(const).ISample)> self, std::vector< ISample const * >::size_type size) -> swig_dummy_type_const_isample_vector
        __init__(std::vector<(p.q(const).ISample)> self, std::vector< ISample const * >::size_type size, ISample value) -> swig_dummy_type_const_isample_vector
        """
        this = _libBornAgainCore.new_swig_dummy_type_const_isample_vector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        """push_back(swig_dummy_type_const_isample_vector self, ISample x)"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_push_back(self, x)


    def front(self):
        """front(swig_dummy_type_const_isample_vector self) -> ISample"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_front(self)


    def back(self):
        """back(swig_dummy_type_const_isample_vector self) -> ISample"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_back(self)


    def assign(self, n, x):
        """assign(swig_dummy_type_const_isample_vector self, std::vector< ISample const * >::size_type n, ISample x)"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(swig_dummy_type_const_isample_vector self, std::vector< ISample const * >::size_type new_size)
        resize(swig_dummy_type_const_isample_vector self, std::vector< ISample const * >::size_type new_size, ISample x)
        """
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_resize(self, *args)


    def insert(self, *args):
        """
        insert(swig_dummy_type_const_isample_vector self, std::vector< ISample const * >::iterator pos, ISample x) -> std::vector< ISample const * >::iterator
        insert(swig_dummy_type_const_isample_vector self, std::vector< ISample const * >::iterator pos, std::vector< ISample const * >::size_type n, ISample x)
        """
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_insert(self, *args)


    def reserve(self, n):
        """reserve(swig_dummy_type_const_isample_vector self, std::vector< ISample const * >::size_type n)"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_reserve(self, n)


    def capacity(self):
        """capacity(swig_dummy_type_const_isample_vector self) -> std::vector< ISample const * >::size_type"""
        return _libBornAgainCore.swig_dummy_type_const_isample_vector_capacity(self)

    __swig_destroy__ = _libBornAgainCore.delete_swig_dummy_type_const_isample_vector
    __del__ = lambda self: None
swig_dummy_type_const_isample_vector_swigregister = _libBornAgainCore.swig_dummy_type_const_isample_vector_swigregister
swig_dummy_type_const_isample_vector_swigregister(swig_dummy_type_const_isample_vector)

class IChiSquaredModule(ICloneable):
    """


    Interface for  ChiSquaredModule for chi2 calculations.

    Until BornAgain-1.1, there was another child, ChiSquaredFrequency.

    C++ includes: IChiSquaredModule.h

    """

    __swig_setmethods__ = {}
    for _s in [ICloneable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IChiSquaredModule, name, value)
    __swig_getmethods__ = {}
    for _s in [ICloneable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IChiSquaredModule, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_IChiSquaredModule
    __del__ = lambda self: None

    def clone(self):
        """
        clone(IChiSquaredModule self) -> IChiSquaredModule

        virtual IChiSquaredModule* IChiSquaredModule::clone() const =0

        clone method 

        """
        return _libBornAgainCore.IChiSquaredModule_clone(self)


    def getSquaredFunction(self):
        """
        getSquaredFunction(IChiSquaredModule self) -> ISquaredFunction

        const ISquaredFunction* IChiSquaredModule::getSquaredFunction() const

        Returns squared function. 

        """
        return _libBornAgainCore.IChiSquaredModule_getSquaredFunction(self)


    def setChiSquaredFunction(self, *args):
        """
        setChiSquaredFunction(IChiSquaredModule self, ISquaredFunction squared_function)
        setChiSquaredFunction(IChiSquaredModule self, ISquaredFunction squared_function)

        void IChiSquaredModule::setChiSquaredFunction(const ISquaredFunction &squared_function)

        """
        return _libBornAgainCore.IChiSquaredModule_setChiSquaredFunction(self, *args)


    def getIntensityNormalizer(self, *args):
        """
        getIntensityNormalizer(IChiSquaredModule self) -> IIntensityNormalizer
        getIntensityNormalizer(IChiSquaredModule self) -> IIntensityNormalizer

        virtual IIntensityNormalizer* IChiSquaredModule::getIntensityNormalizer()

        Returns data normalizer, non-const version needed to set internals. 

        """
        return _libBornAgainCore.IChiSquaredModule_getIntensityNormalizer(self, *args)


    def setIntensityNormalizer(self, data_normalizer):
        """
        setIntensityNormalizer(IChiSquaredModule self, IIntensityNormalizer data_normalizer)

        void IChiSquaredModule::setIntensityNormalizer(const IIntensityNormalizer &data_normalizer)

        Sets data normalizer. 

        """
        return _libBornAgainCore.IChiSquaredModule_setIntensityNormalizer(self, data_normalizer)


    def getIntensityFunction(self):
        """
        getIntensityFunction(IChiSquaredModule self) -> IIntensityFunction

        virtual const IIntensityFunction* IChiSquaredModule::getIntensityFunction() const

        Returns data rescaler. 

        """
        return _libBornAgainCore.IChiSquaredModule_getIntensityFunction(self)


    def setIntensityFunction(self, intensity_function):
        """
        setIntensityFunction(IChiSquaredModule self, IIntensityFunction intensity_function)

        void IChiSquaredModule::setIntensityFunction(const IIntensityFunction &intensity_function)

        Sets data rescaler. 

        """
        return _libBornAgainCore.IChiSquaredModule_setIntensityFunction(self, intensity_function)


    def processFitElements(self, arg2, arg3):
        """
        processFitElements(IChiSquaredModule self, std::vector< FitElement,std::allocator< FitElement > >::iterator arg2, std::vector< FitElement,std::allocator< FitElement > >::iterator arg3)

        virtual void IChiSquaredModule::processFitElements(std::vector< FitElement >::iterator, std::vector< FitElement >::iterator)

        """
        return _libBornAgainCore.IChiSquaredModule_processFitElements(self, arg2, arg3)

IChiSquaredModule_swigregister = _libBornAgainCore.IChiSquaredModule_swigregister
IChiSquaredModule_swigregister(IChiSquaredModule)

class IObserver(_object):
    """


    Observer interface from Observer pattern, for 1:n object dependencies.

    C++ includes: IObserver.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IObserver, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IObserver, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_IObserver
    __del__ = lambda self: None

    def notify(self, subject):
        """
        notify(IObserver self, IObservable subject)

        virtual void IObserver::notify(IObservable *subject)=0

        method which is used by observable subject to notify change in status 

        """
        return _libBornAgainCore.IObserver_notify(self, subject)

IObserver_swigregister = _libBornAgainCore.IObserver_swigregister
IObserver_swigregister(IObserver)

class IObservable(_object):
    """


    Observable interface from Observer pattern, for 1:n object dependencies.

    C++ includes: IObserver.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IObservable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IObservable, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_IObservable
    __del__ = lambda self: None

    def attachObserver(self, obj):
        """
        attachObserver(IObservable self, IObservable::observer_t obj)

        void IObservable::attachObserver(observer_t obj)

        attach observer to the list of observers 

        """
        return _libBornAgainCore.IObservable_attachObserver(self, obj)


    def notifyObservers(self):
        """
        notifyObservers(IObservable self)

        void IObservable::notifyObservers()

        notify observers about change in status 

        """
        return _libBornAgainCore.IObservable_notifyObservers(self)


    def __init__(self):
        """
        __init__(IObservable self) -> IObservable



        Observable interface from Observer pattern, for 1:n object dependencies.

        C++ includes: IObserver.h

        """
        if self.__class__ == IObservable:
            _self = None
        else:
            _self = self
        this = _libBornAgainCore.new_IObservable(_self, )
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _libBornAgainCore.disown_IObservable(self)
        return weakref_proxy(self)
IObservable_swigregister = _libBornAgainCore.IObservable_swigregister
IObservable_swigregister(IObservable)

class IFitObserver(IObserver):
    """


    Base class for all fit observers. Calls update method in following cases: first iteration, every n-th iteration, last iteration and when fit strategy has changed.

    C++ includes: IFitObserver.h

    """

    __swig_setmethods__ = {}
    for _s in [IObserver]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFitObserver, name, value)
    __swig_getmethods__ = {}
    for _s in [IObserver]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFitObserver, name)
    __repr__ = _swig_repr

    def __init__(self, update_every_nth):
        """
        __init__(IFitObserver self, int update_every_nth) -> IFitObserver

        IFitObserver::IFitObserver(int update_every_nth)

        """
        if self.__class__ == IFitObserver:
            _self = None
        else:
            _self = self
        this = _libBornAgainCore.new_IFitObserver(_self, update_every_nth)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def notify(self, subject):
        """
        notify(IFitObserver self, IObservable subject)

        void IFitObserver::notify(IObservable *subject)

        The method used by Ovservable when he wants to be observed by this. 

        """
        return _libBornAgainCore.IFitObserver_notify(self, subject)


    def update(self, fit_suite):
        """
        update(IFitObserver self, FitSuite fit_suite)

        void IFitObserver::update(FitSuite *fit_suite)

        Here Onserver will do actuall job when he thinks that it is a right moment. 

        """
        return _libBornAgainCore.IFitObserver_update(self, fit_suite)

    __swig_destroy__ = _libBornAgainCore.delete_IFitObserver
    __del__ = lambda self: None
    def __disown__(self):
        self.this.disown()
        _libBornAgainCore.disown_IFitObserver(self)
        return weakref_proxy(self)
IFitObserver_swigregister = _libBornAgainCore.IFitObserver_swigregister
IFitObserver_swigregister(IFitObserver)

class IFitStrategy(INamed):
    """


    Interface to concrete fit strategy.

    Concrete implementation should manipulate with fit parameters/data and then call minimizer.

    C++ includes: IFitStrategy.h

    """

    __swig_setmethods__ = {}
    for _s in [INamed]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFitStrategy, name, value)
    __swig_getmethods__ = {}
    for _s in [INamed]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFitStrategy, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_IFitStrategy
    __del__ = lambda self: None

    def clone(self):
        """
        clone(IFitStrategy self) -> IFitStrategy

        virtual IFitStrategy* IFitStrategy::clone() const =0

        """
        return _libBornAgainCore.IFitStrategy_clone(self)


    def init(self, fit_suite):
        """
        init(IFitStrategy self, FitSuiteImpl * fit_suite)

        void IFitStrategy::init(FitSuiteImpl *fit_suite)

        """
        return _libBornAgainCore.IFitStrategy_init(self, fit_suite)


    def execute(self):
        """
        execute(IFitStrategy self)

        virtual void IFitStrategy::execute()=0

        """
        return _libBornAgainCore.IFitStrategy_execute(self)

IFitStrategy_swigregister = _libBornAgainCore.IFitStrategy_swigregister
IFitStrategy_swigregister(IFitStrategy)

class FitStrategyDefault(IFitStrategy):
    """


    Default fit strategy just let  FitSuite to run it's minimization round.

    C++ includes: IFitStrategy.h

    """

    __swig_setmethods__ = {}
    for _s in [IFitStrategy]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FitStrategyDefault, name, value)
    __swig_getmethods__ = {}
    for _s in [IFitStrategy]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FitStrategyDefault, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(FitStrategyDefault self) -> FitStrategyDefault

        FitStrategyDefault::FitStrategyDefault()

        """
        this = _libBornAgainCore.new_FitStrategyDefault()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FitStrategyDefault self) -> FitStrategyDefault

        FitStrategyDefault * FitStrategyDefault::clone() const

        """
        return _libBornAgainCore.FitStrategyDefault_clone(self)


    def execute(self):
        """
        execute(FitStrategyDefault self)

        void FitStrategyDefault::execute()

        """
        return _libBornAgainCore.FitStrategyDefault_execute(self)

    __swig_destroy__ = _libBornAgainCore.delete_FitStrategyDefault
    __del__ = lambda self: None
FitStrategyDefault_swigregister = _libBornAgainCore.FitStrategyDefault_swigregister
FitStrategyDefault_swigregister(FitStrategyDefault)

class IIntensityFunction(_object):
    """


    Interface for applying arbitrary function to the measured intensity.

    C++ includes: IIntensityFunction.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IIntensityFunction, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IIntensityFunction, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_IIntensityFunction
    __del__ = lambda self: None

    def clone(self):
        """
        clone(IIntensityFunction self) -> IIntensityFunction

        virtual IIntensityFunction* IIntensityFunction::clone() const =0

        """
        return _libBornAgainCore.IIntensityFunction_clone(self)


    def evaluate(self, value):
        """
        evaluate(IIntensityFunction self, double value) -> double

        virtual double IIntensityFunction::evaluate(double value) const =0

        """
        return _libBornAgainCore.IIntensityFunction_evaluate(self, value)

IIntensityFunction_swigregister = _libBornAgainCore.IIntensityFunction_swigregister
IIntensityFunction_swigregister(IIntensityFunction)

class IntensityFunctionLog(IIntensityFunction):
    """


    Algorithm for applying log function to the measured intensity.

    C++ includes: IIntensityFunction.h

    """

    __swig_setmethods__ = {}
    for _s in [IIntensityFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntensityFunctionLog, name, value)
    __swig_getmethods__ = {}
    for _s in [IIntensityFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntensityFunctionLog, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_IntensityFunctionLog
    __del__ = lambda self: None

    def clone(self):
        """
        clone(IntensityFunctionLog self) -> IntensityFunctionLog

        virtual IntensityFunctionLog* IntensityFunctionLog::clone() const

        """
        return _libBornAgainCore.IntensityFunctionLog_clone(self)


    def evaluate(self, value):
        """
        evaluate(IntensityFunctionLog self, double value) -> double

        double IntensityFunctionLog::evaluate(double value) const

        """
        return _libBornAgainCore.IntensityFunctionLog_evaluate(self, value)


    def __init__(self):
        """
        __init__(IntensityFunctionLog self) -> IntensityFunctionLog



        Algorithm for applying log function to the measured intensity.

        C++ includes: IIntensityFunction.h

        """
        this = _libBornAgainCore.new_IntensityFunctionLog()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
IntensityFunctionLog_swigregister = _libBornAgainCore.IntensityFunctionLog_swigregister
IntensityFunctionLog_swigregister(IntensityFunctionLog)

class IntensityFunctionSqrt(IIntensityFunction):
    """


    Algorithm for applying sqrt function to the measured intensity.

    C++ includes: IIntensityFunction.h

    """

    __swig_setmethods__ = {}
    for _s in [IIntensityFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntensityFunctionSqrt, name, value)
    __swig_getmethods__ = {}
    for _s in [IIntensityFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntensityFunctionSqrt, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_IntensityFunctionSqrt
    __del__ = lambda self: None

    def clone(self):
        """
        clone(IntensityFunctionSqrt self) -> IntensityFunctionSqrt

        virtual IntensityFunctionSqrt* IntensityFunctionSqrt::clone() const

        """
        return _libBornAgainCore.IntensityFunctionSqrt_clone(self)


    def evaluate(self, value):
        """
        evaluate(IntensityFunctionSqrt self, double value) -> double

        double IntensityFunctionSqrt::evaluate(double value) const

        """
        return _libBornAgainCore.IntensityFunctionSqrt_evaluate(self, value)


    def __init__(self):
        """
        __init__(IntensityFunctionSqrt self) -> IntensityFunctionSqrt



        Algorithm for applying sqrt function to the measured intensity.

        C++ includes: IIntensityFunction.h

        """
        this = _libBornAgainCore.new_IntensityFunctionSqrt()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
IntensityFunctionSqrt_swigregister = _libBornAgainCore.IntensityFunctionSqrt_swigregister
IntensityFunctionSqrt_swigregister(IntensityFunctionSqrt)

class IIntensityNormalizer(IParameterized):
    """


    Interface to  OutputData normalizers.

    C++ includes: IIntensityNormalizer.h

    """

    __swig_setmethods__ = {}
    for _s in [IParameterized]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IIntensityNormalizer, name, value)
    __swig_getmethods__ = {}
    for _s in [IParameterized]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IIntensityNormalizer, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_IIntensityNormalizer
    __del__ = lambda self: None

    def clone(self):
        """
        clone(IIntensityNormalizer self) -> IIntensityNormalizer

        virtual IIntensityNormalizer* IIntensityNormalizer::clone() const =0

        """
        return _libBornAgainCore.IIntensityNormalizer_clone(self)


    def createNormalizedData(self, data):
        """
        createNormalizedData(IIntensityNormalizer self, IntensityData data) -> IntensityData

        virtual OutputData<double>* IIntensityNormalizer::createNormalizedData(const OutputData< double > &data) const =0

        """
        return _libBornAgainCore.IIntensityNormalizer_createNormalizedData(self, data)


    def apply(self, data):
        """
        apply(IIntensityNormalizer self, IntensityData data)

        virtual void IIntensityNormalizer::apply(OutputData< double > &data) const =0

        """
        return _libBornAgainCore.IIntensityNormalizer_apply(self, data)


    def setMaximumIntensity(self, arg2):
        """
        setMaximumIntensity(IIntensityNormalizer self, double arg2)

        virtual void IIntensityNormalizer::setMaximumIntensity(double)=0

        """
        return _libBornAgainCore.IIntensityNormalizer_setMaximumIntensity(self, arg2)

IIntensityNormalizer_swigregister = _libBornAgainCore.IIntensityNormalizer_swigregister
IIntensityNormalizer_swigregister(IIntensityNormalizer)

class IntensityNormalizer(IIntensityNormalizer):
    """


    Standard  OutputData normalizer, with configurable max_intensity.

    C++ includes: IIntensityNormalizer.h

    """

    __swig_setmethods__ = {}
    for _s in [IIntensityNormalizer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntensityNormalizer, name, value)
    __swig_getmethods__ = {}
    for _s in [IIntensityNormalizer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntensityNormalizer, name)
    __repr__ = _swig_repr

    def __init__(self, scale=1.0, shift=0.0):
        """
        __init__(IntensityNormalizer self, double scale=1.0, double shift=0.0) -> IntensityNormalizer
        __init__(IntensityNormalizer self, double scale=1.0) -> IntensityNormalizer
        __init__(IntensityNormalizer self) -> IntensityNormalizer

        IntensityNormalizer::IntensityNormalizer(double scale=1.0, double shift=0.0)

        """
        this = _libBornAgainCore.new_IntensityNormalizer(scale, shift)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_IntensityNormalizer
    __del__ = lambda self: None

    def clone(self):
        """
        clone(IntensityNormalizer self) -> IntensityNormalizer

        IntensityNormalizer * IntensityNormalizer::clone() const

        """
        return _libBornAgainCore.IntensityNormalizer_clone(self)


    def createNormalizedData(self, data):
        """
        createNormalizedData(IntensityNormalizer self, IntensityData data) -> IntensityData

        OutputData< double > * IntensityNormalizer::createNormalizedData(const OutputData< double > &data) const

        """
        return _libBornAgainCore.IntensityNormalizer_createNormalizedData(self, data)


    def apply(self, data):
        """
        apply(IntensityNormalizer self, IntensityData data)

        void IntensityNormalizer::apply(OutputData< double > &data) const final

        """
        return _libBornAgainCore.IntensityNormalizer_apply(self, data)


    def setMaximumIntensity(self, max_intensity):
        """
        setMaximumIntensity(IntensityNormalizer self, double max_intensity)

        virtual void IntensityNormalizer::setMaximumIntensity(double max_intensity)

        """
        return _libBornAgainCore.IntensityNormalizer_setMaximumIntensity(self, max_intensity)

IntensityNormalizer_swigregister = _libBornAgainCore.IntensityNormalizer_swigregister
IntensityNormalizer_swigregister(IntensityNormalizer)

class IntensityScaleAndShiftNormalizer(IntensityNormalizer):
    """


    Simplified  OutputData normalizer, with max_intensity=1.

    C++ includes: IIntensityNormalizer.h

    """

    __swig_setmethods__ = {}
    for _s in [IntensityNormalizer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntensityScaleAndShiftNormalizer, name, value)
    __swig_getmethods__ = {}
    for _s in [IntensityNormalizer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntensityScaleAndShiftNormalizer, name)
    __repr__ = _swig_repr

    def __init__(self, scale=1.0, shift=0.0):
        """
        __init__(IntensityScaleAndShiftNormalizer self, double scale=1.0, double shift=0.0) -> IntensityScaleAndShiftNormalizer
        __init__(IntensityScaleAndShiftNormalizer self, double scale=1.0) -> IntensityScaleAndShiftNormalizer
        __init__(IntensityScaleAndShiftNormalizer self) -> IntensityScaleAndShiftNormalizer

        IntensityScaleAndShiftNormalizer::IntensityScaleAndShiftNormalizer(double scale=1.0, double shift=0.0)

        """
        this = _libBornAgainCore.new_IntensityScaleAndShiftNormalizer(scale, shift)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_IntensityScaleAndShiftNormalizer
    __del__ = lambda self: None

    def setMaximumIntensity(self, arg2):
        """
        setMaximumIntensity(IntensityScaleAndShiftNormalizer self, double arg2)

        void IntensityScaleAndShiftNormalizer::setMaximumIntensity(double) final

        """
        return _libBornAgainCore.IntensityScaleAndShiftNormalizer_setMaximumIntensity(self, arg2)


    def clone(self):
        """
        clone(IntensityScaleAndShiftNormalizer self) -> IntensityScaleAndShiftNormalizer

        IntensityScaleAndShiftNormalizer* IntensityScaleAndShiftNormalizer::clone() const final

        """
        return _libBornAgainCore.IntensityScaleAndShiftNormalizer_clone(self)

IntensityScaleAndShiftNormalizer_swigregister = _libBornAgainCore.IntensityScaleAndShiftNormalizer_swigregister
IntensityScaleAndShiftNormalizer_swigregister(IntensityScaleAndShiftNormalizer)

class ISquaredFunction(_object):
    """


    Interface providing measures for deviation between two values.

    Used By  ChiSquaredModule for chi2 calculations

    C++ includes: ISquaredFunction.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ISquaredFunction, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ISquaredFunction, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_ISquaredFunction
    __del__ = lambda self: None

    def clone(self):
        """
        clone(ISquaredFunction self) -> ISquaredFunction

        virtual ISquaredFunction* ISquaredFunction::clone() const =0

        """
        return _libBornAgainCore.ISquaredFunction_clone(self)


    def calculateSquaredDifference(self, real_value, simulated_value):
        """
        calculateSquaredDifference(ISquaredFunction self, double real_value, double simulated_value) -> double

        virtual double ISquaredFunction::calculateSquaredDifference(double real_value, double simulated_value) const =0

        """
        return _libBornAgainCore.ISquaredFunction_calculateSquaredDifference(self, real_value, simulated_value)


    def calculateSquaredError(self, real_value, simulated_value=0.0):
        """
        calculateSquaredError(ISquaredFunction self, double real_value, double simulated_value=0.0) -> double
        calculateSquaredError(ISquaredFunction self, double real_value) -> double

        virtual double ISquaredFunction::calculateSquaredError(double real_value, double simulated_value=0.0) const =0

        """
        return _libBornAgainCore.ISquaredFunction_calculateSquaredError(self, real_value, simulated_value)

ISquaredFunction_swigregister = _libBornAgainCore.ISquaredFunction_swigregister
ISquaredFunction_swigregister(ISquaredFunction)

class SquaredFunctionDefault(ISquaredFunction):
    """


    Squared difference between two values.

    value = (a-b)*(a-b)/norm, where norm = max(b, 1.0) a - simulated values, b - real_values

    C++ includes: ISquaredFunction.h

    """

    __swig_setmethods__ = {}
    for _s in [ISquaredFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SquaredFunctionDefault, name, value)
    __swig_getmethods__ = {}
    for _s in [ISquaredFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SquaredFunctionDefault, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(SquaredFunctionDefault self) -> SquaredFunctionDefault

        SquaredFunctionDefault::SquaredFunctionDefault()

        """
        this = _libBornAgainCore.new_SquaredFunctionDefault()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_SquaredFunctionDefault
    __del__ = lambda self: None

    def clone(self):
        """
        clone(SquaredFunctionDefault self) -> SquaredFunctionDefault

        virtual SquaredFunctionDefault* SquaredFunctionDefault::clone() const

        """
        return _libBornAgainCore.SquaredFunctionDefault_clone(self)


    def calculateSquaredDifference(self, real_value, simulated_value):
        """
        calculateSquaredDifference(SquaredFunctionDefault self, double real_value, double simulated_value) -> double

        virtual double SquaredFunctionDefault::calculateSquaredDifference(double real_value, double simulated_value) const

        """
        return _libBornAgainCore.SquaredFunctionDefault_calculateSquaredDifference(self, real_value, simulated_value)


    def calculateSquaredError(self, real_value, simulated_value=0):
        """
        calculateSquaredError(SquaredFunctionDefault self, double real_value, double simulated_value=0) -> double
        calculateSquaredError(SquaredFunctionDefault self, double real_value) -> double

        virtual double SquaredFunctionDefault::calculateSquaredError(double real_value, double simulated_value=0) const

        """
        return _libBornAgainCore.SquaredFunctionDefault_calculateSquaredError(self, real_value, simulated_value)

SquaredFunctionDefault_swigregister = _libBornAgainCore.SquaredFunctionDefault_swigregister
SquaredFunctionDefault_swigregister(SquaredFunctionDefault)

class SquaredFunctionSimError(ISquaredFunction):
    """


    Squared difference between two values.

    value = (a-b)*(a-b)/norm, where norm = max(a, 1.0) a - simulated values, b - real_values

    C++ includes: ISquaredFunction.h

    """

    __swig_setmethods__ = {}
    for _s in [ISquaredFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SquaredFunctionSimError, name, value)
    __swig_getmethods__ = {}
    for _s in [ISquaredFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SquaredFunctionSimError, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_SquaredFunctionSimError
    __del__ = lambda self: None

    def clone(self):
        """
        clone(SquaredFunctionSimError self) -> SquaredFunctionSimError

        virtual SquaredFunctionSimError* SquaredFunctionSimError::clone() const

        """
        return _libBornAgainCore.SquaredFunctionSimError_clone(self)


    def calculateSquaredDifference(self, real_value, simulated_value):
        """
        calculateSquaredDifference(SquaredFunctionSimError self, double real_value, double simulated_value) -> double

        virtual double SquaredFunctionSimError::calculateSquaredDifference(double real_value, double simulated_value) const

        """
        return _libBornAgainCore.SquaredFunctionSimError_calculateSquaredDifference(self, real_value, simulated_value)


    def calculateSquaredError(self, arg2, simulated_value):
        """
        calculateSquaredError(SquaredFunctionSimError self, double arg2, double simulated_value) -> double

        virtual double SquaredFunctionSimError::calculateSquaredError(double, double simulated_value) const

        """
        return _libBornAgainCore.SquaredFunctionSimError_calculateSquaredError(self, arg2, simulated_value)

SquaredFunctionSimError_swigregister = _libBornAgainCore.SquaredFunctionSimError_swigregister
SquaredFunctionSimError_swigregister(SquaredFunctionSimError)

class SquaredFunctionMeanSquaredError(ISquaredFunction):
    """


    Squared difference between two values normalized by mean squared error.

    value = (a-b)*(a-b)/norm, where norm = sqrt(sigma1*sigma1 + sigma2*sigma2), sigma1=max(a, 1.0), sigma2=max(b,1.0)

    C++ includes: ISquaredFunction.h

    """

    __swig_setmethods__ = {}
    for _s in [ISquaredFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SquaredFunctionMeanSquaredError, name, value)
    __swig_getmethods__ = {}
    for _s in [ISquaredFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SquaredFunctionMeanSquaredError, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_SquaredFunctionMeanSquaredError
    __del__ = lambda self: None

    def clone(self):
        """
        clone(SquaredFunctionMeanSquaredError self) -> SquaredFunctionMeanSquaredError

        virtual SquaredFunctionMeanSquaredError* SquaredFunctionMeanSquaredError::clone() const

        """
        return _libBornAgainCore.SquaredFunctionMeanSquaredError_clone(self)


    def calculateSquaredDifference(self, real_value, simulated_value):
        """
        calculateSquaredDifference(SquaredFunctionMeanSquaredError self, double real_value, double simulated_value) -> double

        virtual double SquaredFunctionMeanSquaredError::calculateSquaredDifference(double real_value, double simulated_value) const

        """
        return _libBornAgainCore.SquaredFunctionMeanSquaredError_calculateSquaredDifference(self, real_value, simulated_value)


    def calculateSquaredError(self, real_value, simulated_value):
        """
        calculateSquaredError(SquaredFunctionMeanSquaredError self, double real_value, double simulated_value) -> double

        virtual double SquaredFunctionMeanSquaredError::calculateSquaredError(double real_value, double simulated_value) const

        """
        return _libBornAgainCore.SquaredFunctionMeanSquaredError_calculateSquaredError(self, real_value, simulated_value)

SquaredFunctionMeanSquaredError_swigregister = _libBornAgainCore.SquaredFunctionMeanSquaredError_swigregister
SquaredFunctionMeanSquaredError_swigregister(SquaredFunctionMeanSquaredError)

class SquaredFunctionSystematicError(ISquaredFunction):
    """


    Squared difference between two values normalized by systematic error.

    value = (a-b)*(a-b)/norm, where norm = max(error, 1.0), error = b + (epsilon*b)**2

    C++ includes: ISquaredFunction.h

    """

    __swig_setmethods__ = {}
    for _s in [ISquaredFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SquaredFunctionSystematicError, name, value)
    __swig_getmethods__ = {}
    for _s in [ISquaredFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SquaredFunctionSystematicError, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_SquaredFunctionSystematicError
    __del__ = lambda self: None

    def clone(self):
        """
        clone(SquaredFunctionSystematicError self) -> SquaredFunctionSystematicError

        virtual SquaredFunctionSystematicError* SquaredFunctionSystematicError::clone() const

        """
        return _libBornAgainCore.SquaredFunctionSystematicError_clone(self)


    def calculateSquaredDifference(self, real_value, simulated_value):
        """
        calculateSquaredDifference(SquaredFunctionSystematicError self, double real_value, double simulated_value) -> double

        virtual double SquaredFunctionSystematicError::calculateSquaredDifference(double real_value, double simulated_value) const

        """
        return _libBornAgainCore.SquaredFunctionSystematicError_calculateSquaredDifference(self, real_value, simulated_value)


    def calculateSquaredError(self, real_value, arg3):
        """
        calculateSquaredError(SquaredFunctionSystematicError self, double real_value, double arg3) -> double

        virtual double SquaredFunctionSystematicError::calculateSquaredError(double real_value, double) const

        """
        return _libBornAgainCore.SquaredFunctionSystematicError_calculateSquaredError(self, real_value, arg3)

SquaredFunctionSystematicError_swigregister = _libBornAgainCore.SquaredFunctionSystematicError_swigregister
SquaredFunctionSystematicError_swigregister(SquaredFunctionSystematicError)

class SquaredFunctionGaussianError(ISquaredFunction):
    """


    Squared difference between two values with gaussian error.

    value = (a-b)*(a-b)/norm, where norm = sigma*sigma, sigma - is set by user

    C++ includes: ISquaredFunction.h

    """

    __swig_setmethods__ = {}
    for _s in [ISquaredFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SquaredFunctionGaussianError, name, value)
    __swig_getmethods__ = {}
    for _s in [ISquaredFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SquaredFunctionGaussianError, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_SquaredFunctionGaussianError
    __del__ = lambda self: None

    def clone(self):
        """
        clone(SquaredFunctionGaussianError self) -> SquaredFunctionGaussianError

        virtual SquaredFunctionGaussianError* SquaredFunctionGaussianError::clone() const

        """
        return _libBornAgainCore.SquaredFunctionGaussianError_clone(self)


    def calculateSquaredDifference(self, real_value, simulated_value):
        """
        calculateSquaredDifference(SquaredFunctionGaussianError self, double real_value, double simulated_value) -> double

        virtual double SquaredFunctionGaussianError::calculateSquaredDifference(double real_value, double simulated_value) const

        """
        return _libBornAgainCore.SquaredFunctionGaussianError_calculateSquaredDifference(self, real_value, simulated_value)


    def calculateSquaredError(self, arg2, arg3):
        """
        calculateSquaredError(SquaredFunctionGaussianError self, double arg2, double arg3) -> double

        virtual double SquaredFunctionGaussianError::calculateSquaredError(double, double) const

        """
        return _libBornAgainCore.SquaredFunctionGaussianError_calculateSquaredError(self, arg2, arg3)

SquaredFunctionGaussianError_swigregister = _libBornAgainCore.SquaredFunctionGaussianError_swigregister
SquaredFunctionGaussianError_swigregister(SquaredFunctionGaussianError)

class ChiSquaredModule(IChiSquaredModule):
    """


    Calculation of chi2 between two data sets.

    C++ includes: ChiSquaredModule.h

    """

    __swig_setmethods__ = {}
    for _s in [IChiSquaredModule]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChiSquaredModule, name, value)
    __swig_getmethods__ = {}
    for _s in [IChiSquaredModule]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ChiSquaredModule, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ChiSquaredModule self) -> ChiSquaredModule
        __init__(ChiSquaredModule self, ChiSquaredModule other) -> ChiSquaredModule

        ChiSquaredModule::ChiSquaredModule(const ChiSquaredModule &other)

        """
        this = _libBornAgainCore.new_ChiSquaredModule(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_ChiSquaredModule
    __del__ = lambda self: None

    def clone(self):
        """
        clone(ChiSquaredModule self) -> ChiSquaredModule

        virtual ChiSquaredModule* ChiSquaredModule::clone() const

        clone method 

        """
        return _libBornAgainCore.ChiSquaredModule_clone(self)


    def processFitElements(self, first, last):
        """
        processFitElements(ChiSquaredModule self, std::vector< FitElement,std::allocator< FitElement > >::iterator first, std::vector< FitElement,std::allocator< FitElement > >::iterator last)

        void ChiSquaredModule::processFitElements(std::vector< FitElement >::iterator first, std::vector< FitElement >::iterator last)

        """
        return _libBornAgainCore.ChiSquaredModule_processFitElements(self, first, last)

ChiSquaredModule_swigregister = _libBornAgainCore.ChiSquaredModule_swigregister
ChiSquaredModule_swigregister(ChiSquaredModule)

class FitObject(IParameterized, INoncopyable):
    """


    Holds simulation description and real data to run the fit.

    C++ includes: FitObject.h

    """

    __swig_setmethods__ = {}
    for _s in [IParameterized, INoncopyable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FitObject, name, value)
    __swig_getmethods__ = {}
    for _s in [IParameterized, INoncopyable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FitObject, name)
    __repr__ = _swig_repr

    def __init__(self, simulation, real_data, weight=1):
        """
        __init__(FitObject self, GISASSimulation simulation, IntensityData real_data, double weight=1) -> FitObject
        __init__(FitObject self, GISASSimulation simulation, IntensityData real_data) -> FitObject

        FitObject::FitObject(const GISASSimulation &simulation, const OutputData< double > &real_data, double weight=1)

        FitObject constructor

        Parameters:
        -----------

        simulation: 
        The simulation to run

        real_data: 
        The real data

        weight: 
        Weight of dataset in chi2 calculations

        adjust_detector_to_data: 
        Detector axes will be adjusted to real data axes, if true 

        """
        this = _libBornAgainCore.new_FitObject(simulation, real_data, weight)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_FitObject
    __del__ = lambda self: None

    def realData(self):
        """
        realData(FitObject self) -> IntensityData

        const OutputData< double > & FitObject::realData() const

        Returns real (experimental) data. 

        """
        return _libBornAgainCore.FitObject_realData(self)


    def simulationData(self):
        """
        simulationData(FitObject self) -> IntensityData

        const OutputData< double > & FitObject::simulationData() const

        Returns simulated data. 

        """
        return _libBornAgainCore.FitObject_simulationData(self)


    def chiSquaredMap(self):
        """
        chiSquaredMap(FitObject self) -> IntensityData

        const OutputData< double > & FitObject::chiSquaredMap() const

        Returns chi2 map. 

        """
        return _libBornAgainCore.FitObject_chiSquaredMap(self)


    def simulation(self):
        """
        simulation(FitObject self) -> GISASSimulation

        const GISASSimulation & FitObject::simulation() const

        Returns simulation. 

        """
        return _libBornAgainCore.FitObject_simulation(self)


    def weight(self):
        """
        weight(FitObject self) -> double

        double FitObject::weight() const

        Returns weight of data set in chi2 calculations. 

        """
        return _libBornAgainCore.FitObject_weight(self)


    def numberOfFitElements(self):
        """
        numberOfFitElements(FitObject self) -> size_t

        size_t FitObject::numberOfFitElements() const

        Returns the size of the data. It is equal to the number of non-masked detector channels which will participate in chi2 calculations. 

        """
        return _libBornAgainCore.FitObject_numberOfFitElements(self)


    def prepareFitElements(self, fit_elements, weight, normalizer=None):
        """
        prepareFitElements(FitObject self, std::vector< FitElement,std::allocator< FitElement > > & fit_elements, double weight, IIntensityNormalizer normalizer=None)
        prepareFitElements(FitObject self, std::vector< FitElement,std::allocator< FitElement > > & fit_elements, double weight)

        void FitObject::prepareFitElements(std::vector< FitElement > &fit_elements, double weight, IIntensityNormalizer *normalizer=0)

        Runs simulation and put results (the real and simulated intensities) into external vector. Masked channels will be excluded from the vector. 

        """
        return _libBornAgainCore.FitObject_prepareFitElements(self, fit_elements, weight, normalizer)


    def transferToChi2Map(self, first, last):
        """
        transferToChi2Map(FitObject self, std::vector< FitElement,std::allocator< FitElement > >::const_iterator first, std::vector< FitElement,std::allocator< FitElement > >::const_iterator last)

        void FitObject::transferToChi2Map(std::vector< FitElement >::const_iterator first, std::vector< FitElement >::const_iterator last) const

        Updates ChiSquared map from external vector and returns const reference to it. Used from Python in FitSuiteDrawObserver. 

        """
        return _libBornAgainCore.FitObject_transferToChi2Map(self, first, last)

FitObject_swigregister = _libBornAgainCore.FitObject_swigregister
FitObject_swigregister(FitObject)

class FitOptions(_object):
    """Proxy of C++ FitOptions class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FitOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FitOptions, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(FitOptions self) -> FitOptions"""
        this = _libBornAgainCore.new_FitOptions()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_FitOptions
    __del__ = lambda self: None

    def derivEpsilon(self):
        """derivEpsilon(FitOptions self) -> double"""
        return _libBornAgainCore.FitOptions_derivEpsilon(self)


    def setDerivEpsilon(self, deriv_epsilon):
        """setDerivEpsilon(FitOptions self, double deriv_epsilon)"""
        return _libBornAgainCore.FitOptions_setDerivEpsilon(self, deriv_epsilon)


    def stepFactor(self):
        """stepFactor(FitOptions self) -> double"""
        return _libBornAgainCore.FitOptions_stepFactor(self)


    def setStepFactor(self, step_factor):
        """setStepFactor(FitOptions self, double step_factor)"""
        return _libBornAgainCore.FitOptions_setStepFactor(self, step_factor)

FitOptions_swigregister = _libBornAgainCore.FitOptions_swigregister
FitOptions_swigregister(FitOptions)

class FitParameterLinked(libBornAgainFit.FitParameter):
    """


    Fittable parameter, linked to other parameters from pools.

    C++ includes: FitParameterLinked.h

    """

    __swig_setmethods__ = {}
    for _s in [libBornAgainFit.FitParameter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FitParameterLinked, name, value)
    __swig_getmethods__ = {}
    for _s in [libBornAgainFit.FitParameter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FitParameterLinked, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FitParameterLinked self) -> FitParameterLinked
        __init__(FitParameterLinked self, std::string const & name, double value, AttLimits lim, double step=0.0) -> FitParameterLinked
        __init__(FitParameterLinked self, std::string const & name, double value, AttLimits lim) -> FitParameterLinked
        __init__(FitParameterLinked self, std::string const & name, double value) -> FitParameterLinked

        FitParameterLinked::FitParameterLinked(const std::string &name, double value, const AttLimits &lim=AttLimits::limitless(), double step=0.0)

        """
        this = _libBornAgainCore.new_FitParameterLinked(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_FitParameterLinked
    __del__ = lambda self: None

    def clone(self):
        """
        clone(FitParameterLinked self) -> FitParameterLinked

        FitParameterLinked * FitParameterLinked::clone() const

        """
        return _libBornAgainCore.FitParameterLinked_clone(self)


    def setValue(self, value):
        """
        setValue(FitParameterLinked self, double value)

        void FitParameterLinked::setValue(double value) final

        Sets given value for all bound parameters. 

        """
        return _libBornAgainCore.FitParameterLinked_setValue(self, value)


    def addParameter(self, par):
        """
        addParameter(FitParameterLinked self, RealParameter par)

        void FitParameterLinked::addParameter(RealParameter *par)

        Adds real parameter to the collection. 

        """
        return _libBornAgainCore.FitParameterLinked_addParameter(self, par)


    def addMatchedParametersFromPool(self, *args):
        """
        addMatchedParametersFromPool(FitParameterLinked self, ParameterPool pool, std::string const & wildcard)
        addMatchedParametersFromPool(FitParameterLinked self, ParameterPool pool)

        void FitParameterLinked::addMatchedParametersFromPool(const ParameterPool *pool, const std::string &wildcard=std::string())

        Adds parameters from pool which match given wildcard. 

        """
        return _libBornAgainCore.FitParameterLinked_addMatchedParametersFromPool(self, *args)

FitParameterLinked_swigregister = _libBornAgainCore.FitParameterLinked_swigregister
FitParameterLinked_swigregister(FitParameterLinked)

class FitSuite(IObservable):
    """


    User interface class that wraps all fit methods.

    C++ includes: FitSuite.h

    """

    __swig_setmethods__ = {}
    for _s in [IObservable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FitSuite, name, value)
    __swig_getmethods__ = {}
    for _s in [IObservable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FitSuite, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(FitSuite self) -> FitSuite

        FitSuite::FitSuite(const FitSuite &)=delete

        """
        this = _libBornAgainCore.new_FitSuite()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_FitSuite
    __del__ = lambda self: None

    def addSimulationAndRealData(self, *args):
        """
        addSimulationAndRealData(FitSuite self, GISASSimulation simulation, IntensityData real_data, double weight=1)
        addSimulationAndRealData(FitSuite self, GISASSimulation simulation, IntensityData real_data)
        addSimulationAndRealData(FitSuite self, GISASSimulation simulation, IHistogram real_data, double weight=1)
        addSimulationAndRealData(FitSuite self, GISASSimulation simulation, IHistogram real_data)
        addSimulationAndRealData(FitSuite self, GISASSimulation simulation, vdouble2d_t real_data, double weight=1)
        addSimulationAndRealData(FitSuite self, GISASSimulation simulation, vdouble2d_t real_data)

        void FitSuite::addSimulationAndRealData(const GISASSimulation &simulation, const std::vector< std::vector< double >> &real_data, double weight=1)

        Assigns pair of (simulation, real data) for fitting. Numpy array is used to provide intensities. Shape of array (nrows, ncols) should coinside with detector's axes (n_alpha, n_phi). 

        """
        return _libBornAgainCore.FitSuite_addSimulationAndRealData(self, *args)


    def addFitParameter(self, *args):
        """
        addFitParameter(FitSuite self, std::string const & name, double value, AttLimits limits, double step=0.0) -> FitParameterLinked
        addFitParameter(FitSuite self, std::string const & name, double value, AttLimits limits) -> FitParameterLinked
        addFitParameter(FitSuite self, std::string const & name, double value) -> FitParameterLinked

        FitParameterLinked * FitSuite::addFitParameter(const std::string &name, double value, const AttLimits &limits=AttLimits::limitless(), double step=0.0)

        Adds fit parameter

        Parameters:
        -----------

        name: 
        The name of fit parameter

        value: 
        Parameter's starting value

        limits: 
        Limits attribute

        step: 
        Initial parameter's step (some minimizers don't use it) 

        """
        return _libBornAgainCore.FitSuite_addFitParameter(self, *args)


    def setChiSquaredModule(self, chi2_module):
        """
        setChiSquaredModule(FitSuite self, IChiSquaredModule chi2_module)

        void FitSuite::setChiSquaredModule(const IChiSquaredModule &chi2_module)

        Replaces default  ChiSquaredModule with new one. 

        """
        return _libBornAgainCore.FitSuite_setChiSquaredModule(self, chi2_module)


    def addFitStrategy(self, strategy):
        """
        addFitStrategy(FitSuite self, IFitStrategy strategy)

        void FitSuite::addFitStrategy(const IFitStrategy &strategy)

        Adds fit strategy. 

        """
        return _libBornAgainCore.FitSuite_addFitStrategy(self, strategy)


    def setMinimizer(self, *args):
        """
        setMinimizer(FitSuite self, std::string const & minimizer_name, std::string const & algorithm_name, std::string const & minimizer_options)
        setMinimizer(FitSuite self, std::string const & minimizer_name, std::string const & algorithm_name)
        setMinimizer(FitSuite self, std::string const & minimizer_name)
        setMinimizer(FitSuite self, IMinimizer * minimizer)

        void FitSuite::setMinimizer(IMinimizer *minimizer)

        Sets minimizer. 

        """
        return _libBornAgainCore.FitSuite_setMinimizer(self, *args)


    def minimizer(self):
        """
        minimizer(FitSuite self) -> IMinimizer const *

        const IMinimizer * FitSuite::minimizer() const

        Returns minimizer. 

        """
        return _libBornAgainCore.FitSuite_minimizer(self)


    def initPrint(self, print_every_nth):
        """
        initPrint(FitSuite self, int print_every_nth)

        void FitSuite::initPrint(int print_every_nth)

        Initializes printing to standard output during the fitting. Prints also the summary when completed.

        Parameters:
        -----------

        print_every_nth: 
        Print every n'th iteration 

        """
        return _libBornAgainCore.FitSuite_initPrint(self, print_every_nth)


    def runFit(self):
        """
        runFit(FitSuite self)

        void FitSuite::runFit()

        main method to run the fitting 

        """
        return _libBornAgainCore.FitSuite_runFit(self)


    def numberOfFitObjects(self):
        """
        numberOfFitObjects(FitSuite self) -> int

        int FitSuite::numberOfFitObjects() const

        Returns number of fit objects, where fit object stands for (real, simulated) pair. 

        """
        return _libBornAgainCore.FitSuite_numberOfFitObjects(self)


    def getRealData(self, i_item=0):
        """
        getRealData(FitSuite self, size_t i_item=0) -> IHistogram
        getRealData(FitSuite self) -> IHistogram

        IHistogram * FitSuite::getRealData(size_t i_item=0) const

        returns real data histogram

        Parameters:
        -----------

        i_item: 
        The index of fit object 

        """
        return _libBornAgainCore.FitSuite_getRealData(self, i_item)


    def getSimulationData(self, i_item=0):
        """
        getSimulationData(FitSuite self, size_t i_item=0) -> IHistogram
        getSimulationData(FitSuite self) -> IHistogram

        IHistogram * FitSuite::getSimulationData(size_t i_item=0) const

        returns simulated data histogram

        Parameters:
        -----------

        i_item: 
        The index of fit object 

        """
        return _libBornAgainCore.FitSuite_getSimulationData(self, i_item)


    def getChiSquaredMap(self, i_item=0):
        """
        getChiSquaredMap(FitSuite self, size_t i_item=0) -> IHistogram
        getChiSquaredMap(FitSuite self) -> IHistogram

        IHistogram * FitSuite::getChiSquaredMap(size_t i_item=0) const

        returns chi2 histogram calculated for (real, simulated) data pair

        Parameters:
        -----------

        i_item: 
        The index of fit object 

        """
        return _libBornAgainCore.FitSuite_getChiSquaredMap(self, i_item)


    def fitObjects(self):
        """
        fitObjects(FitSuite self) -> FitSuiteObjects

        FitSuiteObjects * FitSuite::fitObjects()

        returns  FitObject (pair of simulation/real data) 

        """
        return _libBornAgainCore.FitSuite_fitObjects(self)


    def fitParameters(self):
        """
        fitParameters(FitSuite self) -> FitParameterSet *

        FitParameterSet * FitSuite::fitParameters()

        Returns reference to fit parameters. 

        """
        return _libBornAgainCore.FitSuite_fitParameters(self)


    def fitStrategies(self):
        """
        fitStrategies(FitSuite self) -> FitSuiteStrategies *

        FitSuiteStrategies * FitSuite::fitStrategies()

        Returns reference to fit parameters. 

        """
        return _libBornAgainCore.FitSuite_fitStrategies(self)


    def isLastIteration(self):
        """
        isLastIteration(FitSuite self) -> bool

        bool FitSuite::isLastIteration() const

        if the last iteration is done (used by observers to print summary) 

        """
        return _libBornAgainCore.FitSuite_isLastIteration(self)


    def numberOfIterations(self):
        """
        numberOfIterations(FitSuite self) -> size_t

        size_t FitSuite::numberOfIterations() const

        Returns current number of minimization function calls. 

        """
        return _libBornAgainCore.FitSuite_numberOfIterations(self)


    def currentStrategyIndex(self):
        """
        currentStrategyIndex(FitSuite self) -> size_t

        size_t FitSuite::currentStrategyIndex() const

        Returns the number of current strategy. 

        """
        return _libBornAgainCore.FitSuite_currentStrategyIndex(self)


    def printResults(self):
        """
        printResults(FitSuite self)

        void FitSuite::printResults() const

        Prints results of the minimization to the standard output. 

        """
        return _libBornAgainCore.FitSuite_printResults(self)


    def reportResults(self):
        """
        reportResults(FitSuite self) -> std::string

        std::string FitSuite::reportResults() const

        Reports results of minimization in the form of multi-line string. 

        """
        return _libBornAgainCore.FitSuite_reportResults(self)


    def getChi2(self):
        """
        getChi2(FitSuite self) -> double

        double FitSuite::getChi2() const

        Returns minimum chi squared value found. 

        """
        return _libBornAgainCore.FitSuite_getChi2(self)


    def interruptFitting(self):
        """
        interruptFitting(FitSuite self)

        void FitSuite::interruptFitting()

        """
        return _libBornAgainCore.FitSuite_interruptFitting(self)


    def resetInterrupt(self):
        """
        resetInterrupt(FitSuite self)

        void FitSuite::resetInterrupt()

        """
        return _libBornAgainCore.FitSuite_resetInterrupt(self)


    def isInterrupted(self):
        """
        isInterrupted(FitSuite self) -> bool

        bool FitSuite::isInterrupted()

        """
        return _libBornAgainCore.FitSuite_isInterrupted(self)


    def getRealOutputData(self, i_item=0):
        """
        getRealOutputData(FitSuite self, size_t i_item=0) -> IntensityData
        getRealOutputData(FitSuite self) -> IntensityData

        const OutputData< double > * FitSuite::getRealOutputData(size_t i_item=0) const

        """
        return _libBornAgainCore.FitSuite_getRealOutputData(self, i_item)


    def getSimulationOutputData(self, i_item=0):
        """
        getSimulationOutputData(FitSuite self, size_t i_item=0) -> IntensityData
        getSimulationOutputData(FitSuite self) -> IntensityData

        const OutputData< double > * FitSuite::getSimulationOutputData(size_t i_item=0) const

        """
        return _libBornAgainCore.FitSuite_getSimulationOutputData(self, i_item)


    def getChiSquaredOutputData(self, i_item=0):
        """
        getChiSquaredOutputData(FitSuite self, size_t i_item=0) -> IntensityData
        getChiSquaredOutputData(FitSuite self) -> IntensityData

        const OutputData< double > * FitSuite::getChiSquaredOutputData(size_t i_item=0) const

        """
        return _libBornAgainCore.FitSuite_getChiSquaredOutputData(self, i_item)

FitSuite_swigregister = _libBornAgainCore.FitSuite_swigregister
FitSuite_swigregister(FitSuite)

class FitSuiteObjects(IParameterized, INoncopyable):
    """


    Holds vector of  FitObject's (simulation and real data) to fit

    C++ includes: FitSuiteObjects.h

    """

    __swig_setmethods__ = {}
    for _s in [IParameterized, INoncopyable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FitSuiteObjects, name, value)
    __swig_getmethods__ = {}
    for _s in [IParameterized, INoncopyable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FitSuiteObjects, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(FitSuiteObjects self) -> FitSuiteObjects

        FitSuiteObjects::FitSuiteObjects()

        """
        this = _libBornAgainCore.new_FitSuiteObjects()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_FitSuiteObjects
    __del__ = lambda self: None

    def add(self, simulation, real_data, weight=1.0):
        """
        add(FitSuiteObjects self, GISASSimulation simulation, IntensityData real_data, double weight=1.0)
        add(FitSuiteObjects self, GISASSimulation simulation, IntensityData real_data)

        void FitSuiteObjects::add(const GISASSimulation &simulation, const OutputData< double > &real_data, double weight=1.0)

        Adds to kit pair of (simulation, real data) for consecutive simulation. 

        """
        return _libBornAgainCore.FitSuiteObjects_add(self, simulation, real_data, weight)


    def getNumberOfFitObjects(self):
        """
        getNumberOfFitObjects(FitSuiteObjects self) -> size_t

        size_t FitSuiteObjects::getNumberOfFitObjects() const

        Returns number of fit objects (simulation/real data pairs) 

        """
        return _libBornAgainCore.FitSuiteObjects_getNumberOfFitObjects(self)


    def getSizeOfDataSet(self):
        """
        getSizeOfDataSet(FitSuiteObjects self) -> size_t

        size_t FitSuiteObjects::getSizeOfDataSet() const

        Returns total number of data points (number of all non-masked channels in all fit objects)

        Returns total number of data points. 

        """
        return _libBornAgainCore.FitSuiteObjects_getSizeOfDataSet(self)


    def setChiSquaredModule(self, chi2_module):
        """
        setChiSquaredModule(FitSuiteObjects self, IChiSquaredModule chi2_module)

        void FitSuiteObjects::setChiSquaredModule(const IChiSquaredModule &chi2_module)

        Replaces default  ChiSquaredModule with new one. 

        """
        return _libBornAgainCore.FitSuiteObjects_setChiSquaredModule(self, chi2_module)


    def getRealData(self, i_item=0):
        """
        getRealData(FitSuiteObjects self, size_t i_item=0) -> IntensityData
        getRealData(FitSuiteObjects self) -> IntensityData

        const OutputData< double > & FitSuiteObjects::getRealData(size_t i_item=0) const

        Returns real data from corresponding  FitObject

        Parameters:
        -----------

        i_item: 
        Index of  FitObject

        """
        return _libBornAgainCore.FitSuiteObjects_getRealData(self, i_item)


    def getSimulationData(self, i_item=0):
        """
        getSimulationData(FitSuiteObjects self, size_t i_item=0) -> IntensityData
        getSimulationData(FitSuiteObjects self) -> IntensityData

        const OutputData< double > & FitSuiteObjects::getSimulationData(size_t i_item=0) const

        Returns simulated data from corresponding  FitObject

        Parameters:
        -----------

        i_item: 
        Index of  FitObject

        """
        return _libBornAgainCore.FitSuiteObjects_getSimulationData(self, i_item)


    def getChiSquaredMap(self, i_item=0):
        """
        getChiSquaredMap(FitSuiteObjects self, size_t i_item=0) -> IntensityData
        getChiSquaredMap(FitSuiteObjects self) -> IntensityData

        const OutputData< double > & FitSuiteObjects::getChiSquaredMap(size_t i_item=0) const

        Returns new chi-squared map from corresponding  FitObject

        Parameters:
        -----------

        i_item: 
        Index of  FitObject

        """
        return _libBornAgainCore.FitSuiteObjects_getChiSquaredMap(self, i_item)


    def runSimulations(self):
        """
        runSimulations(FitSuiteObjects self)

        void FitSuiteObjects::runSimulations()

        run all simulation defined in fit pairs

        loop through all defined simulations and run them 

        """
        return _libBornAgainCore.FitSuiteObjects_runSimulations(self)


    def getChiSquaredValue(self):
        """
        getChiSquaredValue(FitSuiteObjects self) -> double

        double FitSuiteObjects::getChiSquaredValue() const

        Returns chi2 calculated over whole dataset. 

        """
        return _libBornAgainCore.FitSuiteObjects_getChiSquaredValue(self)


    def getResidualValue(self, global_index):
        """
        getResidualValue(FitSuiteObjects self, size_t global_index) -> double

        double FitSuiteObjects::getResidualValue(size_t global_index)

        Returns residuals for single data element

        Parameters:
        -----------

        global_index: 
        index accross all element in  FitElement vector 

        """
        return _libBornAgainCore.FitSuiteObjects_getResidualValue(self, global_index)


    def setNfreeParameters(self, nfree_parameters):
        """
        setNfreeParameters(FitSuiteObjects self, int nfree_parameters)

        void FitSuiteObjects::setNfreeParameters(int nfree_parameters)

        """
        return _libBornAgainCore.FitSuiteObjects_setNfreeParameters(self, nfree_parameters)


    def clear(self):
        """
        clear(FitSuiteObjects self)

        void FitSuiteObjects::clear()

        clear all data 

        """
        return _libBornAgainCore.FitSuiteObjects_clear(self)

FitSuiteObjects_swigregister = _libBornAgainCore.FitSuiteObjects_swigregister
FitSuiteObjects_swigregister(FitSuiteObjects)


def StandardNormal(x):
    """
    StandardNormal(double x) -> double

    double MathFunctions::StandardNormal(double x)

    """
    return _libBornAgainCore.StandardNormal(x)

def Gaussian(x, average, std_dev):
    """
    Gaussian(double x, double average, double std_dev) -> double

    double MathFunctions::Gaussian(double x, double average, double std_dev)

    """
    return _libBornAgainCore.Gaussian(x, average, std_dev)

def IntegratedGaussian(x, average, std_dev):
    """
    IntegratedGaussian(double x, double average, double std_dev) -> double

    double MathFunctions::IntegratedGaussian(double x, double average, double std_dev)

    """
    return _libBornAgainCore.IntegratedGaussian(x, average, std_dev)

def cot(x):
    """
    cot(double x) -> double

    double MathFunctions::cot(double x)

    cotangent function:  $cot(x)\\equiv1/tan(x)$

    """
    return _libBornAgainCore.cot(x)

def Si(x):
    """
    Si(double x) -> double

    double MathFunctions::Si(double x)

    Sine integral function:  $Si(x)\\equiv\\int_0^x du \\sin(u)/u$. 

    """
    return _libBornAgainCore.Si(x)

def sinc(*args):
    """
    sinc(double x) -> double
    sinc(complex_t const z) -> complex_t

    complex_t MathFunctions::sinc(const complex_t z)

    Complex sinc function:  $sinc(x)\\equiv\\sin(x)/x$. 

    """
    return _libBornAgainCore.sinc(*args)

def tanhc(z):
    """
    tanhc(complex_t const z) -> complex_t

    complex_t MathFunctions::tanhc(const complex_t z)

    Complex tanhc function:  $tanhc(x)\\equiv\\tanh(x)/x$. 

    """
    return _libBornAgainCore.tanhc(z)

def Laue(z, N):
    """
    Laue(complex_t const z, size_t N) -> complex_t

    complex_t MathFunctions::Laue(const complex_t z, size_t N)

    """
    return _libBornAgainCore.Laue(z, N)

def Bessel_J0(*args):
    """
    Bessel_J0(double x) -> double
    Bessel_J0(complex_t const z) -> complex_t

    complex_t MathFunctions::Bessel_J0(const complex_t z)

    Complex Bessel function of the first kind and order 0. 

    """
    return _libBornAgainCore.Bessel_J0(*args)

def Bessel_J1(*args):
    """
    Bessel_J1(double x) -> double
    Bessel_J1(complex_t const z) -> complex_t

    complex_t MathFunctions::Bessel_J1(const complex_t z)

    Complex Bessel function of the first kind and order 1. 

    """
    return _libBornAgainCore.Bessel_J1(*args)

def Bessel_J1c(*args):
    """
    Bessel_J1c(double x) -> double
    Bessel_J1c(complex_t const z) -> complex_t

    complex_t MathFunctions::Bessel_J1c(const complex_t z)

    Complex Bessel function Bessel_J1(x)/x. 

    """
    return _libBornAgainCore.Bessel_J1c(*args)

_libBornAgainCore.FORWARD_FFT_swigconstant(_libBornAgainCore)
FORWARD_FFT = _libBornAgainCore.FORWARD_FFT

_libBornAgainCore.BACKWARD_FFT_swigconstant(_libBornAgainCore)
BACKWARD_FFT = _libBornAgainCore.BACKWARD_FFT

def FastFourierTransform(*args):
    """
    FastFourierTransform(vector_complex_t data, MathFunctions::EFFTDirection tcase) -> vector_complex_t
    FastFourierTransform(vdouble1d_t data, MathFunctions::EFFTDirection tcase) -> vector_complex_t

    std::vector< complex_t > MathFunctions::FastFourierTransform(const std::vector< double > &data, EFFTDirection tcase)

    simple (and unoptimized) wrapper function for the discrete fast Fourier transformation library (fftw3); transforms real to complex 

    """
    return _libBornAgainCore.FastFourierTransform(*args)

def ConvolveFFT(signal, resfunc):
    """
    ConvolveFFT(vdouble1d_t signal, vdouble1d_t resfunc) -> vector_complex_t

    std::vector< complex_t > MathFunctions::ConvolveFFT(const std::vector< double > &signal, const std::vector< double > &resfunc)

    convolution of two real vectors of equal size 

    """
    return _libBornAgainCore.ConvolveFFT(signal, resfunc)

def GenerateUniformRandom():
    """
    GenerateUniformRandom() -> double

    double MathFunctions::GenerateUniformRandom()

    """
    return _libBornAgainCore.GenerateUniformRandom()

def GenerateStandardNormalRandom():
    """
    GenerateStandardNormalRandom() -> double

    double MathFunctions::GenerateStandardNormalRandom()

    """
    return _libBornAgainCore.GenerateStandardNormalRandom()

def GenerateNormalRandom(average, std_dev):
    """
    GenerateNormalRandom(double average, double std_dev) -> double

    double MathFunctions::GenerateNormalRandom(double average, double std_dev)

    """
    return _libBornAgainCore.GenerateNormalRandom(average, std_dev)
class AdjustMinimizerStrategy(IFitStrategy):
    """


    Strategy modifies mimimizer settings before running minimization round.

    C++ includes: AdjustMinimizerStrategy.h

    """

    __swig_setmethods__ = {}
    for _s in [IFitStrategy]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AdjustMinimizerStrategy, name, value)
    __swig_getmethods__ = {}
    for _s in [IFitStrategy]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AdjustMinimizerStrategy, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AdjustMinimizerStrategy self) -> AdjustMinimizerStrategy
        __init__(AdjustMinimizerStrategy self, std::string const & minimizerName, std::string const & algorithmName, std::string const & optionString) -> AdjustMinimizerStrategy
        __init__(AdjustMinimizerStrategy self, std::string const & minimizerName, std::string const & algorithmName) -> AdjustMinimizerStrategy
        __init__(AdjustMinimizerStrategy self, std::string const & minimizerName) -> AdjustMinimizerStrategy

        AdjustMinimizerStrategy::AdjustMinimizerStrategy(const std::string &minimizerName, const std::string &algorithmName=std::string(), const std::string &optionString=std::string())

        """
        this = _libBornAgainCore.new_AdjustMinimizerStrategy(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(AdjustMinimizerStrategy self) -> AdjustMinimizerStrategy

        AdjustMinimizerStrategy * AdjustMinimizerStrategy::clone() const

        """
        return _libBornAgainCore.AdjustMinimizerStrategy_clone(self)


    def setMinimizer(self, *args):
        """
        setMinimizer(AdjustMinimizerStrategy self, std::string const & minimizerName, std::string const & algorithmName, std::string const & optionString)
        setMinimizer(AdjustMinimizerStrategy self, std::string const & minimizerName, std::string const & algorithmName)
        setMinimizer(AdjustMinimizerStrategy self, std::string const & minimizerName)

        void AdjustMinimizerStrategy::setMinimizer(const std::string &minimizerName, const std::string &algorithmName=std::string(), const std::string &optionString=std::string())

        """
        return _libBornAgainCore.AdjustMinimizerStrategy_setMinimizer(self, *args)


    def execute(self):
        """
        execute(AdjustMinimizerStrategy self)

        void AdjustMinimizerStrategy::execute()

        """
        return _libBornAgainCore.AdjustMinimizerStrategy_execute(self)

    __swig_destroy__ = _libBornAgainCore.delete_AdjustMinimizerStrategy
    __del__ = lambda self: None
AdjustMinimizerStrategy_swigregister = _libBornAgainCore.AdjustMinimizerStrategy_swigregister
AdjustMinimizerStrategy_swigregister(AdjustMinimizerStrategy)

class IMultiLayerBuilder(IParameterized):
    """


    Interface to the class capable to build samples to simulate.

    C++ includes: IMultiLayerBuilder.h

    """

    __swig_setmethods__ = {}
    for _s in [IParameterized]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IMultiLayerBuilder, name, value)
    __swig_getmethods__ = {}
    for _s in [IParameterized]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IMultiLayerBuilder, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(IMultiLayerBuilder self) -> IMultiLayerBuilder

        IMultiLayerBuilder::IMultiLayerBuilder()

        """
        if self.__class__ == IMultiLayerBuilder:
            _self = None
        else:
            _self = self
        this = _libBornAgainCore.new_IMultiLayerBuilder(_self, )
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_IMultiLayerBuilder
    __del__ = lambda self: None

    def buildSample(self):
        """
        buildSample(IMultiLayerBuilder self) -> MultiLayer

        virtual MultiLayer* IMultiLayerBuilder::buildSample() const =0

        """
        return _libBornAgainCore.IMultiLayerBuilder_buildSample(self)


    def set_subtest(self, subtest_item):
        """
        set_subtest(IMultiLayerBuilder self, IParameterized subtest_item)

        void IMultiLayerBuilder::set_subtest(const IParameterized *subtest_item)

        """
        return _libBornAgainCore.IMultiLayerBuilder_set_subtest(self, subtest_item)

    __swig_setmethods__["m_subtest_item"] = _libBornAgainCore.IMultiLayerBuilder_m_subtest_item_set
    __swig_getmethods__["m_subtest_item"] = _libBornAgainCore.IMultiLayerBuilder_m_subtest_item_get
    if _newclass:
        m_subtest_item = _swig_property(_libBornAgainCore.IMultiLayerBuilder_m_subtest_item_get, _libBornAgainCore.IMultiLayerBuilder_m_subtest_item_set)

    def getFormFactor(self):
        """
        getFormFactor(IMultiLayerBuilder self) -> IFormFactor

        const IFormFactor * IMultiLayerBuilder::getFormFactor() const

        """
        return _libBornAgainCore.IMultiLayerBuilder_getFormFactor(self)


    def getFTDistribution2D(self):
        """
        getFTDistribution2D(IMultiLayerBuilder self) -> IFTDistribution2D

        const IFTDistribution2D * IMultiLayerBuilder::getFTDistribution2D() const

        """
        return _libBornAgainCore.IMultiLayerBuilder_getFTDistribution2D(self)


    def registerParameter(self, name, parpointer):
        """registerParameter(IMultiLayerBuilder self, std::string const & name, int64_t parpointer) -> RealParameter"""
        return _libBornAgainCore.IMultiLayerBuilder_registerParameter(self, name, parpointer)


    def setParameterValue(self, name, value):
        """setParameterValue(IMultiLayerBuilder self, std::string const & name, double value)"""
        return _libBornAgainCore.IMultiLayerBuilder_setParameterValue(self, name, value)


    def isPythonBuilder():
        """isPythonBuilder() -> bool"""
        return _libBornAgainCore.IMultiLayerBuilder_isPythonBuilder()

    if _newclass:
        isPythonBuilder = staticmethod(isPythonBuilder)
    __swig_getmethods__["isPythonBuilder"] = lambda x: isPythonBuilder
    def __disown__(self):
        self.this.disown()
        _libBornAgainCore.disown_IMultiLayerBuilder(self)
        return weakref_proxy(self)

    def onChange(self):
        """onChange(IMultiLayerBuilder self)"""
        return _libBornAgainCore.IMultiLayerBuilder_onChange(self)


    def _print(self, ostr):
        """_print(IMultiLayerBuilder self, std::ostream & ostr)"""
        return _libBornAgainCore.IMultiLayerBuilder__print(self, ostr)

IMultiLayerBuilder_swigregister = _libBornAgainCore.IMultiLayerBuilder_swigregister
IMultiLayerBuilder_swigregister(IMultiLayerBuilder)

def IMultiLayerBuilder_isPythonBuilder():
    """IMultiLayerBuilder_isPythonBuilder() -> bool"""
    return _libBornAgainCore.IMultiLayerBuilder_isPythonBuilder()

class ISampleVisitor(_object):
    """


    From visitor pattern to achieve double dispatch.

    Visitor interface to visit  ISample objects.

    C++ includes: ISampleVisitor.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ISampleVisitor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ISampleVisitor, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(ISampleVisitor self) -> ISampleVisitor

        ISampleVisitor::ISampleVisitor()

        """
        this = _libBornAgainCore.new_ISampleVisitor()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_ISampleVisitor
    __del__ = lambda self: None

    def visit(self, *args):
        """
        visit(ISampleVisitor self, ISample arg2)
        visit(ISampleVisitor self, ICompositeSample arg2)
        visit(ISampleVisitor self, IClusteredParticles arg2)
        visit(ISampleVisitor self, Crystal arg2)
        visit(ISampleVisitor self, ILayout arg2)
        visit(ISampleVisitor self, ParticleLayout arg2)
        visit(ISampleVisitor self, Layer arg2)
        visit(ISampleVisitor self, LayerInterface const * arg2)
        visit(ISampleVisitor self, MultiLayer arg2)
        visit(ISampleVisitor self, IAbstractParticle arg2)
        visit(ISampleVisitor self, IParticle arg2)
        visit(ISampleVisitor self, Particle arg2)
        visit(ISampleVisitor self, ParticleDistribution arg2)
        visit(ISampleVisitor self, ParticleComposition arg2)
        visit(ISampleVisitor self, MesoCrystal arg2)
        visit(ISampleVisitor self, ParticleCoreShell arg2)
        visit(ISampleVisitor self, IFormFactor arg2)
        visit(ISampleVisitor self, IFormFactorBorn arg2)
        visit(ISampleVisitor self, IFormFactorDecorator arg2)
        visit(ISampleVisitor self, FormFactorAnisoPyramid arg2)
        visit(ISampleVisitor self, FormFactorBox arg2)
        visit(ISampleVisitor self, FormFactorCone arg2)
        visit(ISampleVisitor self, FormFactorCone6 arg2)
        visit(ISampleVisitor self, FormFactorCuboctahedron arg2)
        visit(ISampleVisitor self, FormFactorCrystal arg2)
        visit(ISampleVisitor self, FormFactorCylinder arg2)
        visit(ISampleVisitor self, FormFactorDodecahedron arg2)
        visit(ISampleVisitor self, FormFactorEllipsoidalCylinder arg2)
        visit(ISampleVisitor self, FormFactorFullSphere arg2)
        visit(ISampleVisitor self, FormFactorFullSpheroid arg2)
        visit(ISampleVisitor self, FormFactorGauss arg2)
        visit(ISampleVisitor self, FormFactorHemiEllipsoid arg2)
        visit(ISampleVisitor self, FormFactorIcosahedron arg2)
        visit(ISampleVisitor self, FormFactorLongBoxGauss arg2)
        visit(ISampleVisitor self, FormFactorLongBoxLorentz arg2)
        visit(ISampleVisitor self, FormFactorLorentz arg2)
        visit(ISampleVisitor self, FormFactorPrism3 arg2)
        visit(ISampleVisitor self, FormFactorPrism6 arg2)
        visit(ISampleVisitor self, FormFactorPyramid arg2)
        visit(ISampleVisitor self, FormFactorRipple1 arg2)
        visit(ISampleVisitor self, FormFactorRipple2 arg2)
        visit(ISampleVisitor self, FormFactorSphereGaussianRadius arg2)
        visit(ISampleVisitor self, FormFactorSphereLogNormalRadius arg2)
        visit(ISampleVisitor self, FormFactorTetrahedron arg2)
        visit(ISampleVisitor self, FormFactorTrivial arg2)
        visit(ISampleVisitor self, FormFactorTruncatedCube arg2)
        visit(ISampleVisitor self, FormFactorTruncatedSphere arg2)
        visit(ISampleVisitor self, FormFactorTruncatedSpheroid arg2)
        visit(ISampleVisitor self, FormFactorWeighted arg2)
        visit(ISampleVisitor self, FormFactorDecoratorDebyeWaller arg2)
        visit(ISampleVisitor self, FormFactorDecoratorFactor const * arg2)
        visit(ISampleVisitor self, FormFactorDecoratorMaterial const * arg2)
        visit(ISampleVisitor self, FormFactorDecoratorPositionFactor const * arg2)
        visit(ISampleVisitor self, FormFactorDecoratorRotation const * arg2)
        visit(ISampleVisitor self, IInterferenceFunction arg2)
        visit(ISampleVisitor self, InterferenceFunction1DLattice arg2)
        visit(ISampleVisitor self, InterferenceFunctionRadialParaCrystal arg2)
        visit(ISampleVisitor self, InterferenceFunction2DLattice arg2)
        visit(ISampleVisitor self, InterferenceFunction2DParaCrystal arg2)
        visit(ISampleVisitor self, InterferenceFunctionNone arg2)
        visit(ISampleVisitor self, IRoughness arg2)
        visit(ISampleVisitor self, LayerRoughness arg2)
        visit(ISampleVisitor self, IRotation arg2)
        visit(ISampleVisitor self, RotationX arg2)
        visit(ISampleVisitor self, RotationY arg2)
        visit(ISampleVisitor self, RotationZ arg2)
        visit(ISampleVisitor self, RotationEuler arg2)

        void ISampleVisitor::visit(const RotationEuler *)

        """
        return _libBornAgainCore.ISampleVisitor_visit(self, *args)


    def visitEnter(self, arg2):
        """
        visitEnter(ISampleVisitor self, ICompositeSample arg2) -> bool

        bool ISampleVisitor::visitEnter(const ICompositeSample *)

        """
        return _libBornAgainCore.ISampleVisitor_visitEnter(self, arg2)


    def visitLeave(self, arg2):
        """
        visitLeave(ISampleVisitor self, ICompositeSample arg2) -> bool

        bool ISampleVisitor::visitLeave(const ICompositeSample *)

        """
        return _libBornAgainCore.ISampleVisitor_visitLeave(self, arg2)


    def depth(self):
        """depth(ISampleVisitor self) -> int"""
        return _libBornAgainCore.ISampleVisitor_depth(self)


    def setDepth(self, depth):
        """setDepth(ISampleVisitor self, int depth)"""
        return _libBornAgainCore.ISampleVisitor_setDepth(self, depth)

ISampleVisitor_swigregister = _libBornAgainCore.ISampleVisitor_swigregister
ISampleVisitor_swigregister(ISampleVisitor)


def VisitSampleTreePreorder(sample, visitor):
    """
    VisitSampleTreePreorder(ISample sample, ISampleVisitor visitor)

    BA_CORE_API_ void VisitSampleTreePreorder(const ISample &sample, ISampleVisitor &visitor)

    """
    return _libBornAgainCore.VisitSampleTreePreorder(sample, visitor)

def VisitSampleTreePostorder(sample, visitor):
    """
    VisitSampleTreePostorder(ISample sample, ISampleVisitor visitor)

    BA_CORE_API_ void VisitSampleTreePostorder(const ISample &sample, ISampleVisitor &visitor)

    """
    return _libBornAgainCore.VisitSampleTreePostorder(sample, visitor)
class ICompositeSample(ISample):
    """


    Pure virtual base class for tree-like composite samples.

    Inherited by  IAbstractParticle, IClusteredParticle,  ILayout, ILayer, IMultiLayer.

    C++ includes: ICompositeSample.h

    """

    __swig_setmethods__ = {}
    for _s in [ISample]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICompositeSample, name, value)
    __swig_getmethods__ = {}
    for _s in [ISample]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ICompositeSample, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_ICompositeSample
    __del__ = lambda self: None

    def clone(self):
        """
        clone(ICompositeSample self) -> ICompositeSample

        virtual ICompositeSample* ICompositeSample::clone() const =0

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.ICompositeSample_clone(self)


    def accept(self, visitor):
        """
        accept(ICompositeSample self, ISampleVisitor visitor)

        virtual void ICompositeSample::accept(ISampleVisitor *visitor) const =0

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.ICompositeSample_accept(self, visitor)


    def registerChild(self, sample):
        """
        registerChild(ICompositeSample self, ISample sample)

        void ICompositeSample::registerChild(ISample *sample)

        Registers child in the container. 

        """
        return _libBornAgainCore.ICompositeSample_registerChild(self, sample)


    def deregisterChild(self, sample):
        """
        deregisterChild(ICompositeSample self, ISample sample)

        void ICompositeSample::deregisterChild(ISample *sample)

        Removes registered child from the container.

        remove registered child from the container 

        """
        return _libBornAgainCore.ICompositeSample_deregisterChild(self, sample)


    def getChildren(self):
        """
        getChildren(ICompositeSample self) -> swig_dummy_type_const_isample_vector

        std::vector< const ISample * > ICompositeSample::getChildren() const final

        Returns a vector of children (const). 

        """
        return _libBornAgainCore.ICompositeSample_getChildren(self)


    def size(self):
        """
        size(ICompositeSample self) -> size_t

        size_t ICompositeSample::size() const final

        Returns number of children. 

        """
        return _libBornAgainCore.ICompositeSample_size(self)

ICompositeSample_swigregister = _libBornAgainCore.ICompositeSample_swigregister
ICompositeSample_swigregister(ICompositeSample)

class IClusteredParticles(ICompositeSample):
    """


    An ordered assembly of particles. Currently, the only child class is  Crystal.

    C++ includes: IClusteredParticles.h

    """

    __swig_setmethods__ = {}
    for _s in [ICompositeSample]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IClusteredParticles, name, value)
    __swig_getmethods__ = {}
    for _s in [ICompositeSample]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IClusteredParticles, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self):
        """
        clone(IClusteredParticles self) -> IClusteredParticles

        virtual IClusteredParticles* IClusteredParticles::clone() const =0

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.IClusteredParticles_clone(self)


    def cloneInvertB(self):
        """
        cloneInvertB(IClusteredParticles self) -> IClusteredParticles

        virtual IClusteredParticles* IClusteredParticles::cloneInvertB() const =0

        Returns a clone with inverted magnetic fields. 

        """
        return _libBornAgainCore.IClusteredParticles_cloneInvertB(self)


    def accept(self, visitor):
        """
        accept(IClusteredParticles self, ISampleVisitor visitor)

        virtual void IClusteredParticles::accept(ISampleVisitor *visitor) const =0

        calls the  ISampleVisitor's visit method 

        """
        return _libBornAgainCore.IClusteredParticles_accept(self, visitor)


    def setAmbientMaterial(self, material):
        """
        setAmbientMaterial(IClusteredParticles self, IMaterial material)

        virtual void IClusteredParticles::setAmbientMaterial(const IMaterial &material)=0

        """
        return _libBornAgainCore.IClusteredParticles_setAmbientMaterial(self, material)


    def getAmbientMaterial(self):
        """
        getAmbientMaterial(IClusteredParticles self) -> IMaterial

        virtual const IMaterial* IClusteredParticles::getAmbientMaterial() const =0

        Returns nullptr, unless overwritten to return a specific material. 

        """
        return _libBornAgainCore.IClusteredParticles_getAmbientMaterial(self)


    def createTotalFormFactor(self, arg2, arg3, arg4):
        """
        createTotalFormFactor(IClusteredParticles self, IFormFactor arg2, IRotation arg3, kvector_t arg4) -> IFormFactor

        virtual IFormFactor* IClusteredParticles::createTotalFormFactor(const IFormFactor &, const IRotation *, const kvector_t &) const =0

        Creates a total form factor for the mesocrystal with a specific shape and content The bulk content of the mesocrystal is encapsulated by the  IClusteredParticles object itself 

        """
        return _libBornAgainCore.IClusteredParticles_createTotalFormFactor(self, arg2, arg3, arg4)

    __swig_destroy__ = _libBornAgainCore.delete_IClusteredParticles
    __del__ = lambda self: None
IClusteredParticles_swigregister = _libBornAgainCore.IClusteredParticles_swigregister
IClusteredParticles_swigregister(IClusteredParticles)

class Crystal(IClusteredParticles):
    """


    A crystal structure with a  ParticleComposition as a basis. Used in  MesoCrystal, where it is given an outer shape.

    C++ includes: Crystal.h

    """

    __swig_setmethods__ = {}
    for _s in [IClusteredParticles]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Crystal, name, value)
    __swig_getmethods__ = {}
    for _s in [IClusteredParticles]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Crystal, name)
    __repr__ = _swig_repr

    def __init__(self, lattice_basis, lattice):
        """
        __init__(Crystal self, ParticleComposition lattice_basis, Lattice lattice) -> Crystal

        Crystal::Crystal(const ParticleComposition &lattice_basis, const Lattice &lattice)

        """
        this = _libBornAgainCore.new_Crystal(lattice_basis, lattice)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_Crystal
    __del__ = lambda self: None

    def clone(self):
        """
        clone(Crystal self) -> Crystal

        Crystal * Crystal::clone() const final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.Crystal_clone(self)


    def cloneInvertB(self):
        """
        cloneInvertB(Crystal self) -> Crystal

        Crystal * Crystal::cloneInvertB() const final

        Returns a clone with inverted magnetic fields. 

        """
        return _libBornAgainCore.Crystal_cloneInvertB(self)


    def accept(self, visitor):
        """
        accept(Crystal self, ISampleVisitor visitor)

        void Crystal::accept(ISampleVisitor *visitor) const final

        calls the  ISampleVisitor's visit method 

        """
        return _libBornAgainCore.Crystal_accept(self, visitor)


    def setAmbientMaterial(self, material):
        """
        setAmbientMaterial(Crystal self, IMaterial material)

        void Crystal::setAmbientMaterial(const IMaterial &material) final

        """
        return _libBornAgainCore.Crystal_setAmbientMaterial(self, material)


    def getAmbientMaterial(self):
        """
        getAmbientMaterial(Crystal self) -> IMaterial

        const IMaterial * Crystal::getAmbientMaterial() const final

        Returns nullptr, unless overwritten to return a specific material. 

        """
        return _libBornAgainCore.Crystal_getAmbientMaterial(self)


    def createTotalFormFactor(self, meso_crystal_form_factor, p_rotation, translation):
        """
        createTotalFormFactor(Crystal self, IFormFactor meso_crystal_form_factor, IRotation p_rotation, kvector_t translation) -> IFormFactor

        IFormFactor * Crystal::createTotalFormFactor(const IFormFactor &meso_crystal_form_factor, const IRotation *p_rotation, const kvector_t &translation) const

        Creates a total form factor for the mesocrystal with a specific shape and content The bulk content of the mesocrystal is encapsulated by the  IClusteredParticles object itself 

        """
        return _libBornAgainCore.Crystal_createTotalFormFactor(self, meso_crystal_form_factor, p_rotation, translation)


    def getLatticeBasis(self):
        """
        getLatticeBasis(Crystal self) -> ParticleComposition

        const ParticleComposition* Crystal::getLatticeBasis() const

        """
        return _libBornAgainCore.Crystal_getLatticeBasis(self)


    def setDWFactor(self, dw_factor):
        """
        setDWFactor(Crystal self, double dw_factor)

        void Crystal::setDWFactor(double dw_factor)

        """
        return _libBornAgainCore.Crystal_setDWFactor(self, dw_factor)

Crystal_swigregister = _libBornAgainCore.Crystal_swigregister
Crystal_swigregister(Crystal)

class IDistribution1D(IParameterized):
    """


    Interface for 1 dimensional distributions.

    C++ includes: Distributions.h

    """

    __swig_setmethods__ = {}
    for _s in [IParameterized]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IDistribution1D, name, value)
    __swig_getmethods__ = {}
    for _s in [IParameterized]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IDistribution1D, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_IDistribution1D
    __del__ = lambda self: None

    def clone(self):
        """
        clone(IDistribution1D self) -> IDistribution1D

        IDistribution1D * IDistribution1D::clone() const

        """
        return _libBornAgainCore.IDistribution1D_clone(self)


    def probabilityDensity(self, x):
        """
        probabilityDensity(IDistribution1D self, double x) -> double

        virtual double IDistribution1D::probabilityDensity(double x) const =0

        get the probability density for value x 

        """
        return _libBornAgainCore.IDistribution1D_probabilityDensity(self, x)


    def getMean(self):
        """
        getMean(IDistribution1D self) -> double

        virtual double IDistribution1D::getMean() const =0

        get the mean of the distribution 

        """
        return _libBornAgainCore.IDistribution1D_getMean(self)


    def equidistantSamples(self, *args):
        """
        equidistantSamples(IDistribution1D self, size_t nbr_samples, double sigma_factor=0., RealLimits limits) -> std::vector< ParameterSample,std::allocator< ParameterSample > >
        equidistantSamples(IDistribution1D self, size_t nbr_samples, double sigma_factor=0.) -> std::vector< ParameterSample,std::allocator< ParameterSample > >
        equidistantSamples(IDistribution1D self, size_t nbr_samples) -> std::vector< ParameterSample,std::allocator< ParameterSample > >
        """
        return _libBornAgainCore.IDistribution1D_equidistantSamples(self, *args)


    def equidistantSamplesInRange(self, nbr_samples, xmin, xmax):
        """equidistantSamplesInRange(IDistribution1D self, size_t nbr_samples, double xmin, double xmax) -> std::vector< ParameterSample,std::allocator< ParameterSample > >"""
        return _libBornAgainCore.IDistribution1D_equidistantSamplesInRange(self, nbr_samples, xmin, xmax)


    def equidistantPoints(self, *args):
        """
        equidistantPoints(IDistribution1D self, size_t nbr_samples, double sigma_factor, RealLimits limits) -> vdouble1d_t
        equidistantPoints(IDistribution1D self, size_t nbr_samples, double sigma_factor) -> vdouble1d_t
        """
        return _libBornAgainCore.IDistribution1D_equidistantPoints(self, *args)


    def equidistantPointsInRange(self, nbr_samples, xmin, xmax):
        """equidistantPointsInRange(IDistribution1D self, size_t nbr_samples, double xmin, double xmax) -> vdouble1d_t"""
        return _libBornAgainCore.IDistribution1D_equidistantPointsInRange(self, nbr_samples, xmin, xmax)


    def isDelta(self):
        """
        isDelta(IDistribution1D self) -> bool

        virtual bool IDistribution1D::isDelta() const =0

        signals that the distribution is in the limit case of a delta distribution 

        """
        return _libBornAgainCore.IDistribution1D_isDelta(self)

IDistribution1D_swigregister = _libBornAgainCore.IDistribution1D_swigregister
IDistribution1D_swigregister(IDistribution1D)

class DistributionGate(IDistribution1D):
    """


    Uniform distribution function with half width hwhm.

    C++ includes: Distributions.h

    """

    __swig_setmethods__ = {}
    for _s in [IDistribution1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DistributionGate, name, value)
    __swig_getmethods__ = {}
    for _s in [IDistribution1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DistributionGate, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(DistributionGate self) -> DistributionGate
        __init__(DistributionGate self, double min, double max) -> DistributionGate

        DistributionGate::DistributionGate(double min, double max)

        """
        this = _libBornAgainCore.new_DistributionGate(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_DistributionGate
    __del__ = lambda self: None

    def clone(self):
        """
        clone(DistributionGate self) -> DistributionGate

        virtual DistributionGate* DistributionGate::clone() const

        clone method 

        """
        return _libBornAgainCore.DistributionGate_clone(self)


    def probabilityDensity(self, x):
        """
        probabilityDensity(DistributionGate self, double x) -> double

        double DistributionGate::probabilityDensity(double x) const

        get the probability density for value x 

        """
        return _libBornAgainCore.DistributionGate_probabilityDensity(self, x)


    def getMean(self):
        """
        getMean(DistributionGate self) -> double

        virtual double DistributionGate::getMean() const

        get the mean of the distribution 

        """
        return _libBornAgainCore.DistributionGate_getMean(self)


    def getMin(self):
        """
        getMin(DistributionGate self) -> double

        double DistributionGate::getMin() const

        Returns the minimum value of the distribution. 

        """
        return _libBornAgainCore.DistributionGate_getMin(self)


    def getMax(self):
        """
        getMax(DistributionGate self) -> double

        double DistributionGate::getMax() const

        Returns the maximum value of the distribution. 

        """
        return _libBornAgainCore.DistributionGate_getMax(self)


    def equidistantPoints(self, *args):
        """
        equidistantPoints(DistributionGate self, size_t nbr_samples, double sigma_factor, RealLimits limits) -> vdouble1d_t
        equidistantPoints(DistributionGate self, size_t nbr_samples, double sigma_factor) -> vdouble1d_t
        """
        return _libBornAgainCore.DistributionGate_equidistantPoints(self, *args)


    def isDelta(self):
        """
        isDelta(DistributionGate self) -> bool

        bool DistributionGate::isDelta() const

        signals that the distribution is in the limit case of a delta distribution 

        """
        return _libBornAgainCore.DistributionGate_isDelta(self)

DistributionGate_swigregister = _libBornAgainCore.DistributionGate_swigregister
DistributionGate_swigregister(DistributionGate)

class DistributionLorentz(IDistribution1D):
    """


    Lorentz distribution with half width hwhm.

    C++ includes: Distributions.h

    """

    __swig_setmethods__ = {}
    for _s in [IDistribution1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DistributionLorentz, name, value)
    __swig_getmethods__ = {}
    for _s in [IDistribution1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DistributionLorentz, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(DistributionLorentz self) -> DistributionLorentz
        __init__(DistributionLorentz self, double mean, double hwhm) -> DistributionLorentz

        DistributionLorentz::DistributionLorentz(double mean, double hwhm)

        """
        this = _libBornAgainCore.new_DistributionLorentz(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_DistributionLorentz
    __del__ = lambda self: None

    def clone(self):
        """
        clone(DistributionLorentz self) -> DistributionLorentz

        virtual DistributionLorentz* DistributionLorentz::clone() const

        """
        return _libBornAgainCore.DistributionLorentz_clone(self)


    def probabilityDensity(self, x):
        """
        probabilityDensity(DistributionLorentz self, double x) -> double

        double DistributionLorentz::probabilityDensity(double x) const

        get the probability density for value x 

        """
        return _libBornAgainCore.DistributionLorentz_probabilityDensity(self, x)


    def getMean(self):
        """
        getMean(DistributionLorentz self) -> double

        virtual double DistributionLorentz::getMean() const

        Returns the mean of the distribution. 

        """
        return _libBornAgainCore.DistributionLorentz_getMean(self)


    def getHWHM(self):
        """
        getHWHM(DistributionLorentz self) -> double

        double DistributionLorentz::getHWHM() const

        Returns the half width at half maximum. 

        """
        return _libBornAgainCore.DistributionLorentz_getHWHM(self)


    def equidistantPoints(self, *args):
        """
        equidistantPoints(DistributionLorentz self, size_t nbr_samples, double sigma_factor, RealLimits limits) -> vdouble1d_t
        equidistantPoints(DistributionLorentz self, size_t nbr_samples, double sigma_factor) -> vdouble1d_t
        """
        return _libBornAgainCore.DistributionLorentz_equidistantPoints(self, *args)


    def isDelta(self):
        """
        isDelta(DistributionLorentz self) -> bool

        bool DistributionLorentz::isDelta() const

        signals that the distribution is in the limit case of a delta distribution 

        """
        return _libBornAgainCore.DistributionLorentz_isDelta(self)

DistributionLorentz_swigregister = _libBornAgainCore.DistributionLorentz_swigregister
DistributionLorentz_swigregister(DistributionLorentz)

class DistributionGaussian(IDistribution1D):
    """


    Gaussian distribution with standard deviation std_dev.

    C++ includes: Distributions.h

    """

    __swig_setmethods__ = {}
    for _s in [IDistribution1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DistributionGaussian, name, value)
    __swig_getmethods__ = {}
    for _s in [IDistribution1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DistributionGaussian, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(DistributionGaussian self) -> DistributionGaussian
        __init__(DistributionGaussian self, double mean, double std_dev) -> DistributionGaussian

        DistributionGaussian::DistributionGaussian(double mean, double std_dev)

        """
        this = _libBornAgainCore.new_DistributionGaussian(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_DistributionGaussian
    __del__ = lambda self: None

    def clone(self):
        """
        clone(DistributionGaussian self) -> DistributionGaussian

        virtual DistributionGaussian* DistributionGaussian::clone() const

        clone method 

        """
        return _libBornAgainCore.DistributionGaussian_clone(self)


    def probabilityDensity(self, x):
        """
        probabilityDensity(DistributionGaussian self, double x) -> double

        double DistributionGaussian::probabilityDensity(double x) const

        get the probability density for value x 

        """
        return _libBornAgainCore.DistributionGaussian_probabilityDensity(self, x)


    def getMean(self):
        """
        getMean(DistributionGaussian self) -> double

        virtual double DistributionGaussian::getMean() const

        Returns the mean of the distribution. 

        """
        return _libBornAgainCore.DistributionGaussian_getMean(self)


    def getStdDev(self):
        """
        getStdDev(DistributionGaussian self) -> double

        double DistributionGaussian::getStdDev() const

        Returns the standard deviation. 

        """
        return _libBornAgainCore.DistributionGaussian_getStdDev(self)


    def equidistantPoints(self, *args):
        """
        equidistantPoints(DistributionGaussian self, size_t nbr_samples, double sigma_factor, RealLimits limits) -> vdouble1d_t
        equidistantPoints(DistributionGaussian self, size_t nbr_samples, double sigma_factor) -> vdouble1d_t
        """
        return _libBornAgainCore.DistributionGaussian_equidistantPoints(self, *args)


    def isDelta(self):
        """
        isDelta(DistributionGaussian self) -> bool

        bool DistributionGaussian::isDelta() const

        signals that the distribution is in the limit case of a delta distribution 

        """
        return _libBornAgainCore.DistributionGaussian_isDelta(self)

DistributionGaussian_swigregister = _libBornAgainCore.DistributionGaussian_swigregister
DistributionGaussian_swigregister(DistributionGaussian)

class DistributionLogNormal(IDistribution1D):
    """


    Log-normal distribution.

    C++ includes: Distributions.h

    """

    __swig_setmethods__ = {}
    for _s in [IDistribution1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DistributionLogNormal, name, value)
    __swig_getmethods__ = {}
    for _s in [IDistribution1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DistributionLogNormal, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(DistributionLogNormal self, double scale_param) -> DistributionLogNormal
        __init__(DistributionLogNormal self, double median, double scale_param) -> DistributionLogNormal

        DistributionLogNormal::DistributionLogNormal(double median, double scale_param)

        """
        this = _libBornAgainCore.new_DistributionLogNormal(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_DistributionLogNormal
    __del__ = lambda self: None

    def clone(self):
        """
        clone(DistributionLogNormal self) -> DistributionLogNormal

        virtual DistributionLogNormal* DistributionLogNormal::clone() const

        clone method 

        """
        return _libBornAgainCore.DistributionLogNormal_clone(self)


    def probabilityDensity(self, x):
        """
        probabilityDensity(DistributionLogNormal self, double x) -> double

        double DistributionLogNormal::probabilityDensity(double x) const

        get the probability density for value x 

        """
        return _libBornAgainCore.DistributionLogNormal_probabilityDensity(self, x)


    def getMean(self):
        """
        getMean(DistributionLogNormal self) -> double

        double DistributionLogNormal::getMean() const

        get the mean of the distribution 

        """
        return _libBornAgainCore.DistributionLogNormal_getMean(self)


    def getMedian(self):
        """
        getMedian(DistributionLogNormal self) -> double

        double DistributionLogNormal::getMedian() const

        Returns the median of the distribution. 

        """
        return _libBornAgainCore.DistributionLogNormal_getMedian(self)


    def getScalePar(self):
        """
        getScalePar(DistributionLogNormal self) -> double

        double DistributionLogNormal::getScalePar() const

        Returns the scale parameter of the distribution. 

        """
        return _libBornAgainCore.DistributionLogNormal_getScalePar(self)


    def equidistantPoints(self, *args):
        """
        equidistantPoints(DistributionLogNormal self, size_t nbr_samples, double sigma_factor, RealLimits limits) -> vdouble1d_t
        equidistantPoints(DistributionLogNormal self, size_t nbr_samples, double sigma_factor) -> vdouble1d_t
        """
        return _libBornAgainCore.DistributionLogNormal_equidistantPoints(self, *args)


    def isDelta(self):
        """
        isDelta(DistributionLogNormal self) -> bool

        bool DistributionLogNormal::isDelta() const

        signals that the distribution is in the limit case of a delta distribution 

        """
        return _libBornAgainCore.DistributionLogNormal_isDelta(self)

DistributionLogNormal_swigregister = _libBornAgainCore.DistributionLogNormal_swigregister
DistributionLogNormal_swigregister(DistributionLogNormal)

class DistributionCosine(IDistribution1D):
    """


    Cosine distribution.

    C++ includes: Distributions.h

    """

    __swig_setmethods__ = {}
    for _s in [IDistribution1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DistributionCosine, name, value)
    __swig_getmethods__ = {}
    for _s in [IDistribution1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DistributionCosine, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(DistributionCosine self) -> DistributionCosine
        __init__(DistributionCosine self, double mean, double sigma) -> DistributionCosine

        DistributionCosine::DistributionCosine(double mean, double sigma)

        """
        this = _libBornAgainCore.new_DistributionCosine(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_DistributionCosine
    __del__ = lambda self: None

    def clone(self):
        """
        clone(DistributionCosine self) -> DistributionCosine

        virtual DistributionCosine* DistributionCosine::clone() const

        clone method 

        """
        return _libBornAgainCore.DistributionCosine_clone(self)


    def probabilityDensity(self, x):
        """
        probabilityDensity(DistributionCosine self, double x) -> double

        double DistributionCosine::probabilityDensity(double x) const

        get the probability density for value x 

        """
        return _libBornAgainCore.DistributionCosine_probabilityDensity(self, x)


    def getMean(self):
        """
        getMean(DistributionCosine self) -> double

        virtual double DistributionCosine::getMean() const

        Returns the mean of the distribution. 

        """
        return _libBornAgainCore.DistributionCosine_getMean(self)


    def getSigma(self):
        """
        getSigma(DistributionCosine self) -> double

        double DistributionCosine::getSigma() const

        Returns the sigma parameter of the distribution. 

        """
        return _libBornAgainCore.DistributionCosine_getSigma(self)


    def equidistantPoints(self, *args):
        """
        equidistantPoints(DistributionCosine self, size_t nbr_samples, double sigma_factor, RealLimits limits) -> vdouble1d_t
        equidistantPoints(DistributionCosine self, size_t nbr_samples, double sigma_factor) -> vdouble1d_t
        """
        return _libBornAgainCore.DistributionCosine_equidistantPoints(self, *args)


    def isDelta(self):
        """
        isDelta(DistributionCosine self) -> bool

        bool DistributionCosine::isDelta() const

        signals that the distribution is in the limit case of a delta distribution 

        """
        return _libBornAgainCore.DistributionCosine_isDelta(self)

DistributionCosine_swigregister = _libBornAgainCore.DistributionCosine_swigregister
DistributionCosine_swigregister(DistributionCosine)

class DetectorMask(_object):
    """


    Collection of detector masks.

    C++ includes: DetectorMask.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DetectorMask, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DetectorMask, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(DetectorMask self) -> DetectorMask
        __init__(DetectorMask self, DetectorMask other) -> DetectorMask

        DetectorMask::DetectorMask(const DetectorMask &other)

        """
        this = _libBornAgainCore.new_DetectorMask(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def addMask(self, shape, mask_value):
        """
        addMask(DetectorMask self, IShape2D shape, bool mask_value)

        void DetectorMask::addMask(const Geometry::IShape2D &shape, bool mask_value)

        Add mask to the stack of detector masks. The value "true" means that the area will be excluded from the analysis.

        Parameters:
        -----------

        shape: 
        The shape of mask.

        mask_value: 
        The value of mask 

        """
        return _libBornAgainCore.DetectorMask_addMask(self, shape, mask_value)


    def initMaskData(self, *args):
        """
        initMaskData(DetectorMask self, IDetector2D detector)
        initMaskData(DetectorMask self, IntensityData data)

        void DetectorMask::initMaskData(const OutputData< double > &data)

        """
        return _libBornAgainCore.DetectorMask_initMaskData(self, *args)


    def isMasked(self, index):
        """
        isMasked(DetectorMask self, size_t index) -> bool

        bool DetectorMask::isMasked(size_t index) const

        """
        return _libBornAgainCore.DetectorMask_isMasked(self, index)


    def getMaskData(self):
        """
        getMaskData(DetectorMask self) -> OutputData< bool > const *

        const OutputData<bool>* DetectorMask::getMaskData() const

        """
        return _libBornAgainCore.DetectorMask_getMaskData(self)


    def createHistogram(self):
        """
        createHistogram(DetectorMask self) -> Histogram2D

        Histogram2D * DetectorMask::createHistogram() const

        """
        return _libBornAgainCore.DetectorMask_createHistogram(self)


    def removeMasks(self):
        """
        removeMasks(DetectorMask self)

        void DetectorMask::removeMasks()

        remove all masks and return object to initial state 

        """
        return _libBornAgainCore.DetectorMask_removeMasks(self)


    def hasMasks(self):
        """
        hasMasks(DetectorMask self) -> bool

        bool DetectorMask::hasMasks() const

        returns true if has masks 

        """
        return _libBornAgainCore.DetectorMask_hasMasks(self)


    def numberOfMaskedChannels(self):
        """
        numberOfMaskedChannels(DetectorMask self) -> int

        int DetectorMask::numberOfMaskedChannels() const

        """
        return _libBornAgainCore.DetectorMask_numberOfMaskedChannels(self)


    def numberOfMasks(self):
        """
        numberOfMasks(DetectorMask self) -> size_t

        size_t DetectorMask::numberOfMasks() const

        """
        return _libBornAgainCore.DetectorMask_numberOfMasks(self)


    def getMaskShape(self, mask_index, mask_value):
        """
        getMaskShape(DetectorMask self, size_t mask_index, bool & mask_value) -> IShape2D

        const Geometry::IShape2D * DetectorMask::getMaskShape(size_t mask_index, bool &mask_value) const

        """
        return _libBornAgainCore.DetectorMask_getMaskShape(self, mask_index, mask_value)

    __swig_destroy__ = _libBornAgainCore.delete_DetectorMask
    __del__ = lambda self: None
DetectorMask_swigregister = _libBornAgainCore.DetectorMask_swigregister
DetectorMask_swigregister(DetectorMask)

class Ellipse(IShape2D):
    """Proxy of C++ Ellipse class."""

    __swig_setmethods__ = {}
    for _s in [IShape2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Ellipse, name, value)
    __swig_getmethods__ = {}
    for _s in [IShape2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Ellipse, name)
    __repr__ = _swig_repr

    def __init__(self, xcenter, ycenter, xradius, yradius, theta=0.0):
        """
        __init__(Ellipse self, double xcenter, double ycenter, double xradius, double yradius, double theta=0.0) -> Ellipse
        __init__(Ellipse self, double xcenter, double ycenter, double xradius, double yradius) -> Ellipse
        """
        this = _libBornAgainCore.new_Ellipse(xcenter, ycenter, xradius, yradius, theta)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(Ellipse self) -> Ellipse

        virtual ICloneable* ICloneable::clone() const =0

        """
        return _libBornAgainCore.Ellipse_clone(self)


    def contains(self, *args):
        """
        contains(Ellipse self, double x, double y) -> bool
        contains(Ellipse self, Bin1D binx, Bin1D biny) -> bool
        """
        return _libBornAgainCore.Ellipse_contains(self, *args)


    def getCenterX(self):
        """getCenterX(Ellipse self) -> double"""
        return _libBornAgainCore.Ellipse_getCenterX(self)


    def getCenterY(self):
        """getCenterY(Ellipse self) -> double"""
        return _libBornAgainCore.Ellipse_getCenterY(self)


    def getRadiusX(self):
        """getRadiusX(Ellipse self) -> double"""
        return _libBornAgainCore.Ellipse_getRadiusX(self)


    def getRadiusY(self):
        """getRadiusY(Ellipse self) -> double"""
        return _libBornAgainCore.Ellipse_getRadiusY(self)


    def getTheta(self):
        """getTheta(Ellipse self) -> double"""
        return _libBornAgainCore.Ellipse_getTheta(self)

    __swig_destroy__ = _libBornAgainCore.delete_Ellipse
    __del__ = lambda self: None
Ellipse_swigregister = _libBornAgainCore.Ellipse_swigregister
Ellipse_swigregister(Ellipse)

class IFTDecayFunction1D(IParameterized):
    """


    Interface for a one-dimensional decay function, with evaluate(q) returning the Fourier transform, normalized to  $\\int dq\\; {\\rm evaluate}(q) = 1$.

    C++ includes: FTDecayFunctions.h

    """

    __swig_setmethods__ = {}
    for _s in [IParameterized]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFTDecayFunction1D, name, value)
    __swig_getmethods__ = {}
    for _s in [IParameterized]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFTDecayFunction1D, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self):
        """
        clone(IFTDecayFunction1D self) -> IFTDecayFunction1D

        virtual IFTDecayFunction1D* IFTDecayFunction1D::clone() const =0

        """
        return _libBornAgainCore.IFTDecayFunction1D_clone(self)


    def evaluate(self, q):
        """
        evaluate(IFTDecayFunction1D self, double q) -> double

        virtual double IFTDecayFunction1D::evaluate(double q) const =0

        """
        return _libBornAgainCore.IFTDecayFunction1D_evaluate(self, q)


    def setOmega(self, omega):
        """
        setOmega(IFTDecayFunction1D self, double omega)

        void IFTDecayFunction1D::setOmega(double omega)

        """
        return _libBornAgainCore.IFTDecayFunction1D_setOmega(self, omega)


    def getOmega(self):
        """
        getOmega(IFTDecayFunction1D self) -> double

        double IFTDecayFunction1D::getOmega() const

        """
        return _libBornAgainCore.IFTDecayFunction1D_getOmega(self)

    __swig_destroy__ = _libBornAgainCore.delete_IFTDecayFunction1D
    __del__ = lambda self: None
IFTDecayFunction1D_swigregister = _libBornAgainCore.IFTDecayFunction1D_swigregister
IFTDecayFunction1D_swigregister(IFTDecayFunction1D)

class FTDecayFunction1DCauchy(IFTDecayFunction1D):
    """


    One-dimensional Cauchy decay function in reciprocal space; corresponds to exp(-|x|/omega) in real space.

    C++ includes: FTDecayFunctions.h

    """

    __swig_setmethods__ = {}
    for _s in [IFTDecayFunction1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FTDecayFunction1DCauchy, name, value)
    __swig_getmethods__ = {}
    for _s in [IFTDecayFunction1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FTDecayFunction1DCauchy, name)
    __repr__ = _swig_repr

    def __init__(self, omega):
        """
        __init__(FTDecayFunction1DCauchy self, double omega) -> FTDecayFunction1DCauchy

        FTDecayFunction1DCauchy::FTDecayFunction1DCauchy(double omega)

        """
        this = _libBornAgainCore.new_FTDecayFunction1DCauchy(omega)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FTDecayFunction1DCauchy self) -> FTDecayFunction1DCauchy

        virtual FTDecayFunction1DCauchy* FTDecayFunction1DCauchy::clone() const

        """
        return _libBornAgainCore.FTDecayFunction1DCauchy_clone(self)


    def evaluate(self, q):
        """
        evaluate(FTDecayFunction1DCauchy self, double q) -> double

        double FTDecayFunction1DCauchy::evaluate(double q) const final

        """
        return _libBornAgainCore.FTDecayFunction1DCauchy_evaluate(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FTDecayFunction1DCauchy
    __del__ = lambda self: None
FTDecayFunction1DCauchy_swigregister = _libBornAgainCore.FTDecayFunction1DCauchy_swigregister
FTDecayFunction1DCauchy_swigregister(FTDecayFunction1DCauchy)

class FTDecayFunction1DGauss(IFTDecayFunction1D):
    """


    One-dimensional Gauss decay function in reciprocal space; corresponds to exp[-x^2/(2*omega^2)] in real space.

    C++ includes: FTDecayFunctions.h

    """

    __swig_setmethods__ = {}
    for _s in [IFTDecayFunction1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FTDecayFunction1DGauss, name, value)
    __swig_getmethods__ = {}
    for _s in [IFTDecayFunction1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FTDecayFunction1DGauss, name)
    __repr__ = _swig_repr

    def __init__(self, omega):
        """
        __init__(FTDecayFunction1DGauss self, double omega) -> FTDecayFunction1DGauss

        FTDecayFunction1DGauss::FTDecayFunction1DGauss(double omega)

        """
        this = _libBornAgainCore.new_FTDecayFunction1DGauss(omega)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FTDecayFunction1DGauss self) -> FTDecayFunction1DGauss

        virtual FTDecayFunction1DGauss* FTDecayFunction1DGauss::clone() const

        """
        return _libBornAgainCore.FTDecayFunction1DGauss_clone(self)


    def evaluate(self, q):
        """
        evaluate(FTDecayFunction1DGauss self, double q) -> double

        double FTDecayFunction1DGauss::evaluate(double q) const final

        """
        return _libBornAgainCore.FTDecayFunction1DGauss_evaluate(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FTDecayFunction1DGauss
    __del__ = lambda self: None
FTDecayFunction1DGauss_swigregister = _libBornAgainCore.FTDecayFunction1DGauss_swigregister
FTDecayFunction1DGauss_swigregister(FTDecayFunction1DGauss)

class FTDecayFunction1DTriangle(IFTDecayFunction1D):
    """


    One-dimensional triangle decay function in reciprocal space; corresponds to 1-|x|/omega if |x|<omega (and 0 otherwise) in real space.

    C++ includes: FTDecayFunctions.h

    """

    __swig_setmethods__ = {}
    for _s in [IFTDecayFunction1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FTDecayFunction1DTriangle, name, value)
    __swig_getmethods__ = {}
    for _s in [IFTDecayFunction1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FTDecayFunction1DTriangle, name)
    __repr__ = _swig_repr

    def __init__(self, omega):
        """
        __init__(FTDecayFunction1DTriangle self, double omega) -> FTDecayFunction1DTriangle

        FTDecayFunction1DTriangle::FTDecayFunction1DTriangle(double omega)

        """
        this = _libBornAgainCore.new_FTDecayFunction1DTriangle(omega)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FTDecayFunction1DTriangle self) -> FTDecayFunction1DTriangle

        virtual FTDecayFunction1DTriangle* FTDecayFunction1DTriangle::clone() const

        """
        return _libBornAgainCore.FTDecayFunction1DTriangle_clone(self)


    def evaluate(self, q):
        """
        evaluate(FTDecayFunction1DTriangle self, double q) -> double

        double FTDecayFunction1DTriangle::evaluate(double q) const final

        """
        return _libBornAgainCore.FTDecayFunction1DTriangle_evaluate(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FTDecayFunction1DTriangle
    __del__ = lambda self: None
FTDecayFunction1DTriangle_swigregister = _libBornAgainCore.FTDecayFunction1DTriangle_swigregister
FTDecayFunction1DTriangle_swigregister(FTDecayFunction1DTriangle)

class FTDecayFunction1DVoigt(IFTDecayFunction1D):
    """


    One-dimensional pseudo-Voigt decay function in reciprocal space; corresponds to eta*Gauss + (1-eta)*Cauchy.

    C++ includes: FTDecayFunctions.h

    """

    __swig_setmethods__ = {}
    for _s in [IFTDecayFunction1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FTDecayFunction1DVoigt, name, value)
    __swig_getmethods__ = {}
    for _s in [IFTDecayFunction1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FTDecayFunction1DVoigt, name)
    __repr__ = _swig_repr

    def __init__(self, omega, eta):
        """
        __init__(FTDecayFunction1DVoigt self, double omega, double eta) -> FTDecayFunction1DVoigt

        FTDecayFunction1DVoigt::FTDecayFunction1DVoigt(double omega, double eta)

        """
        this = _libBornAgainCore.new_FTDecayFunction1DVoigt(omega, eta)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FTDecayFunction1DVoigt self) -> FTDecayFunction1DVoigt

        virtual FTDecayFunction1DVoigt* FTDecayFunction1DVoigt::clone() const

        """
        return _libBornAgainCore.FTDecayFunction1DVoigt_clone(self)


    def evaluate(self, q):
        """
        evaluate(FTDecayFunction1DVoigt self, double q) -> double

        double FTDecayFunction1DVoigt::evaluate(double q) const final

        """
        return _libBornAgainCore.FTDecayFunction1DVoigt_evaluate(self, q)


    def getEta(self):
        """
        getEta(FTDecayFunction1DVoigt self) -> double

        double FTDecayFunction1DVoigt::getEta() const

        """
        return _libBornAgainCore.FTDecayFunction1DVoigt_getEta(self)

    __swig_destroy__ = _libBornAgainCore.delete_FTDecayFunction1DVoigt
    __del__ = lambda self: None
FTDecayFunction1DVoigt_swigregister = _libBornAgainCore.FTDecayFunction1DVoigt_swigregister
FTDecayFunction1DVoigt_swigregister(FTDecayFunction1DVoigt)

class IFTDecayFunction2D(IParameterized):
    """


    Interface for two-dimensional decay function in reciprocal space.

    C++ includes: FTDecayFunctions.h

    """

    __swig_setmethods__ = {}
    for _s in [IParameterized]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFTDecayFunction2D, name, value)
    __swig_getmethods__ = {}
    for _s in [IParameterized]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFTDecayFunction2D, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self):
        """
        clone(IFTDecayFunction2D self) -> IFTDecayFunction2D

        virtual IFTDecayFunction2D* IFTDecayFunction2D::clone() const =0

        """
        return _libBornAgainCore.IFTDecayFunction2D_clone(self)


    def setGamma(self, gamma):
        """
        setGamma(IFTDecayFunction2D self, double gamma)

        void IFTDecayFunction2D::setGamma(double gamma)

        set angle between first lattice vector and X-axis of distribution (both in direct space) 

        """
        return _libBornAgainCore.IFTDecayFunction2D_setGamma(self, gamma)


    def getGamma(self):
        """
        getGamma(IFTDecayFunction2D self) -> double

        double IFTDecayFunction2D::getGamma() const

        get angle between first lattice vector and X-axis of distribution (both in direct space) 

        """
        return _libBornAgainCore.IFTDecayFunction2D_getGamma(self)


    def getDelta(self):
        """
        getDelta(IFTDecayFunction2D self) -> double

        double IFTDecayFunction2D::getDelta() const

        get angle between X- and Y-axis of distribution (in direct space) 

        """
        return _libBornAgainCore.IFTDecayFunction2D_getDelta(self)


    def getDecayLengthX(self):
        """
        getDecayLengthX(IFTDecayFunction2D self) -> double

        double IFTDecayFunction2D::getDecayLengthX() const

        get coherence length in X-direction 

        """
        return _libBornAgainCore.IFTDecayFunction2D_getDecayLengthX(self)


    def getDecayLengthY(self):
        """
        getDecayLengthY(IFTDecayFunction2D self) -> double

        double IFTDecayFunction2D::getDecayLengthY() const

        get coherence length in Y-direction 

        """
        return _libBornAgainCore.IFTDecayFunction2D_getDecayLengthY(self)


    def evaluate(self, qx, qy):
        """
        evaluate(IFTDecayFunction2D self, double qx, double qy) -> double

        virtual double IFTDecayFunction2D::evaluate(double qx, double qy) const =0

        evaluate Fourier transformed decay function for q in X,Y coordinates 

        """
        return _libBornAgainCore.IFTDecayFunction2D_evaluate(self, qx, qy)


    def transformToStarBasis(self, qX, qY, alpha, a, b, qa, qb):
        """
        transformToStarBasis(IFTDecayFunction2D self, double qX, double qY, double alpha, double a, double b, double & qa, double & qb)

        void IFTDecayFunction2D::transformToStarBasis(double qX, double qY, double alpha, double a, double b, double &qa, double &qb) const

        transform back to a*, b* basis: 

        """
        return _libBornAgainCore.IFTDecayFunction2D_transformToStarBasis(self, qX, qY, alpha, a, b, qa, qb)

    __swig_destroy__ = _libBornAgainCore.delete_IFTDecayFunction2D
    __del__ = lambda self: None
IFTDecayFunction2D_swigregister = _libBornAgainCore.IFTDecayFunction2D_swigregister
IFTDecayFunction2D_swigregister(IFTDecayFunction2D)

class FTDecayFunction2DCauchy(IFTDecayFunction2D):
    """


    Two-dimensional Cauchy decay function in reciprocal space; corresponds to exp(-r) in real space, with  $r=\\sqrt{(\\frac{x}{\\omega_x})^2 + (\\frac{y}{\\omega_y})^2}$.

    C++ includes: FTDecayFunctions.h

    """

    __swig_setmethods__ = {}
    for _s in [IFTDecayFunction2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FTDecayFunction2DCauchy, name, value)
    __swig_getmethods__ = {}
    for _s in [IFTDecayFunction2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FTDecayFunction2DCauchy, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FTDecayFunction2DCauchy self, double decay_length_x, double decay_length_y, double gamma=0, double delta) -> FTDecayFunction2DCauchy
        __init__(FTDecayFunction2DCauchy self, double decay_length_x, double decay_length_y, double gamma=0) -> FTDecayFunction2DCauchy
        __init__(FTDecayFunction2DCauchy self, double decay_length_x, double decay_length_y) -> FTDecayFunction2DCauchy

        FTDecayFunction2DCauchy::FTDecayFunction2DCauchy(double decay_length_x, double decay_length_y, double gamma=0, double delta=M_PI_2)

        """
        this = _libBornAgainCore.new_FTDecayFunction2DCauchy(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FTDecayFunction2DCauchy self) -> FTDecayFunction2DCauchy

        virtual FTDecayFunction2DCauchy* FTDecayFunction2DCauchy::clone() const

        """
        return _libBornAgainCore.FTDecayFunction2DCauchy_clone(self)


    def evaluate(self, qx, qy):
        """
        evaluate(FTDecayFunction2DCauchy self, double qx, double qy) -> double

        double FTDecayFunction2DCauchy::evaluate(double qx, double qy) const final

        evaluate Fourier transformed decay function for q in X,Y coordinates 

        """
        return _libBornAgainCore.FTDecayFunction2DCauchy_evaluate(self, qx, qy)

    __swig_destroy__ = _libBornAgainCore.delete_FTDecayFunction2DCauchy
    __del__ = lambda self: None
FTDecayFunction2DCauchy_swigregister = _libBornAgainCore.FTDecayFunction2DCauchy_swigregister
FTDecayFunction2DCauchy_swigregister(FTDecayFunction2DCauchy)

class FTDecayFunction2DGauss(IFTDecayFunction2D):
    """


    Two-dimensional Gauss decay function in reciprocal space; corresponds to exp(-r^2/2) in real space, with  $r=\\sqrt{(\\frac{x}{\\omega_x})^2 + (\\frac{y}{\\omega_y})^2}$.

    C++ includes: FTDecayFunctions.h

    """

    __swig_setmethods__ = {}
    for _s in [IFTDecayFunction2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FTDecayFunction2DGauss, name, value)
    __swig_getmethods__ = {}
    for _s in [IFTDecayFunction2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FTDecayFunction2DGauss, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FTDecayFunction2DGauss self, double decay_length_x, double decay_length_y, double gamma=0, double delta) -> FTDecayFunction2DGauss
        __init__(FTDecayFunction2DGauss self, double decay_length_x, double decay_length_y, double gamma=0) -> FTDecayFunction2DGauss
        __init__(FTDecayFunction2DGauss self, double decay_length_x, double decay_length_y) -> FTDecayFunction2DGauss

        FTDecayFunction2DGauss::FTDecayFunction2DGauss(double decay_length_x, double decay_length_y, double gamma=0, double delta=M_PI_2)

        """
        this = _libBornAgainCore.new_FTDecayFunction2DGauss(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FTDecayFunction2DGauss self) -> FTDecayFunction2DGauss

        virtual FTDecayFunction2DGauss* FTDecayFunction2DGauss::clone() const

        """
        return _libBornAgainCore.FTDecayFunction2DGauss_clone(self)


    def evaluate(self, qx, qy):
        """
        evaluate(FTDecayFunction2DGauss self, double qx, double qy) -> double

        double FTDecayFunction2DGauss::evaluate(double qx, double qy) const final

        evaluate Fourier transformed decay function for q in X,Y coordinates 

        """
        return _libBornAgainCore.FTDecayFunction2DGauss_evaluate(self, qx, qy)

    __swig_destroy__ = _libBornAgainCore.delete_FTDecayFunction2DGauss
    __del__ = lambda self: None
FTDecayFunction2DGauss_swigregister = _libBornAgainCore.FTDecayFunction2DGauss_swigregister
FTDecayFunction2DGauss_swigregister(FTDecayFunction2DGauss)

class FTDecayFunction2DVoigt(IFTDecayFunction2D):
    """


    Two-dimensional pseudo-Voigt decay function in reciprocal space; corresponds to eta*Gauss + (1-eta)*Cauchy.

    C++ includes: FTDecayFunctions.h

    """

    __swig_setmethods__ = {}
    for _s in [IFTDecayFunction2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FTDecayFunction2DVoigt, name, value)
    __swig_getmethods__ = {}
    for _s in [IFTDecayFunction2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FTDecayFunction2DVoigt, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FTDecayFunction2DVoigt self, double decay_length_x, double decay_length_y, double eta, double gamma=0, double delta) -> FTDecayFunction2DVoigt
        __init__(FTDecayFunction2DVoigt self, double decay_length_x, double decay_length_y, double eta, double gamma=0) -> FTDecayFunction2DVoigt
        __init__(FTDecayFunction2DVoigt self, double decay_length_x, double decay_length_y, double eta) -> FTDecayFunction2DVoigt

        FTDecayFunction2DVoigt::FTDecayFunction2DVoigt(double decay_length_x, double decay_length_y, double eta, double gamma=0, double delta=M_PI_2)

        """
        this = _libBornAgainCore.new_FTDecayFunction2DVoigt(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FTDecayFunction2DVoigt self) -> FTDecayFunction2DVoigt

        virtual FTDecayFunction2DVoigt* FTDecayFunction2DVoigt::clone() const

        """
        return _libBornAgainCore.FTDecayFunction2DVoigt_clone(self)


    def evaluate(self, qx, qy):
        """
        evaluate(FTDecayFunction2DVoigt self, double qx, double qy) -> double

        double FTDecayFunction2DVoigt::evaluate(double qx, double qy) const final

        evaluate Fourier transformed decay function for q in X,Y coordinates 

        """
        return _libBornAgainCore.FTDecayFunction2DVoigt_evaluate(self, qx, qy)


    def getEta(self):
        """
        getEta(FTDecayFunction2DVoigt self) -> double

        virtual double FTDecayFunction2DVoigt::getEta() const

        """
        return _libBornAgainCore.FTDecayFunction2DVoigt_getEta(self)

    __swig_destroy__ = _libBornAgainCore.delete_FTDecayFunction2DVoigt
    __del__ = lambda self: None
FTDecayFunction2DVoigt_swigregister = _libBornAgainCore.FTDecayFunction2DVoigt_swigregister
FTDecayFunction2DVoigt_swigregister(FTDecayFunction2DVoigt)

class IFTDistribution1D(IParameterized):
    """


    Interface for a one-dimensional distribution, with normalization adjusted so that the Fourier transform evaluate(q) is a decay function that starts at evaluate(0)=1.

    C++ includes: FTDistributions1D.h

    """

    __swig_setmethods__ = {}
    for _s in [IParameterized]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFTDistribution1D, name, value)
    __swig_getmethods__ = {}
    for _s in [IParameterized]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFTDistribution1D, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self):
        """
        clone(IFTDistribution1D self) -> IFTDistribution1D

        virtual IFTDistribution1D* IFTDistribution1D::clone() const =0

        """
        return _libBornAgainCore.IFTDistribution1D_clone(self)


    def evaluate(self, q):
        """
        evaluate(IFTDistribution1D self, double q) -> double

        virtual double IFTDistribution1D::evaluate(double q) const =0

        Returns Fourier transform of this distribution; is a decay function starting at evaluate(0)=1. 

        """
        return _libBornAgainCore.IFTDistribution1D_evaluate(self, q)


    def setOmega(self, omega):
        """
        setOmega(IFTDistribution1D self, double omega)

        void IFTDistribution1D::setOmega(double omega)

        """
        return _libBornAgainCore.IFTDistribution1D_setOmega(self, omega)


    def getOmega(self):
        """
        getOmega(IFTDistribution1D self) -> double

        double IFTDistribution1D::getOmega() const

        """
        return _libBornAgainCore.IFTDistribution1D_getOmega(self)

    __swig_destroy__ = _libBornAgainCore.delete_IFTDistribution1D
    __del__ = lambda self: None
IFTDistribution1D_swigregister = _libBornAgainCore.IFTDistribution1D_swigregister
IFTDistribution1D_swigregister(IFTDistribution1D)

class FTDistribution1DCauchy(IFTDistribution1D):
    """


    Exponential  IFTDistribution1D exp(-|omega*x|); its Fourier transform evaluate(q) is a Cauchy-Lorentzian starting at evaluate(0)=1.

    C++ includes: FTDistributions1D.h

    """

    __swig_setmethods__ = {}
    for _s in [IFTDistribution1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FTDistribution1DCauchy, name, value)
    __swig_getmethods__ = {}
    for _s in [IFTDistribution1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FTDistribution1DCauchy, name)
    __repr__ = _swig_repr

    def __init__(self, omega):
        """
        __init__(FTDistribution1DCauchy self, double omega) -> FTDistribution1DCauchy

        FTDistribution1DCauchy::FTDistribution1DCauchy(double omega)

        """
        this = _libBornAgainCore.new_FTDistribution1DCauchy(omega)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FTDistribution1DCauchy self) -> FTDistribution1DCauchy

        FTDistribution1DCauchy* FTDistribution1DCauchy::clone() const final

        """
        return _libBornAgainCore.FTDistribution1DCauchy_clone(self)


    def evaluate(self, q):
        """
        evaluate(FTDistribution1DCauchy self, double q) -> double

        double FTDistribution1DCauchy::evaluate(double q) const final

        Returns Fourier transform of this distribution; is a decay function starting at evaluate(0)=1. 

        """
        return _libBornAgainCore.FTDistribution1DCauchy_evaluate(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FTDistribution1DCauchy
    __del__ = lambda self: None
FTDistribution1DCauchy_swigregister = _libBornAgainCore.FTDistribution1DCauchy_swigregister
FTDistribution1DCauchy_swigregister(FTDistribution1DCauchy)

class FTDistribution1DGauss(IFTDistribution1D):
    """


    Gaussian  IFTDistribution1D; its Fourier transform evaluate(q) is a Gaussian starting at evaluate(0)=1.

    C++ includes: FTDistributions1D.h

    """

    __swig_setmethods__ = {}
    for _s in [IFTDistribution1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FTDistribution1DGauss, name, value)
    __swig_getmethods__ = {}
    for _s in [IFTDistribution1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FTDistribution1DGauss, name)
    __repr__ = _swig_repr

    def __init__(self, omega):
        """
        __init__(FTDistribution1DGauss self, double omega) -> FTDistribution1DGauss

        FTDistribution1DGauss::FTDistribution1DGauss(double omega)

        """
        this = _libBornAgainCore.new_FTDistribution1DGauss(omega)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FTDistribution1DGauss self) -> FTDistribution1DGauss

        FTDistribution1DGauss* FTDistribution1DGauss::clone() const final

        """
        return _libBornAgainCore.FTDistribution1DGauss_clone(self)


    def evaluate(self, q):
        """
        evaluate(FTDistribution1DGauss self, double q) -> double

        double FTDistribution1DGauss::evaluate(double q) const final

        Returns Fourier transform of this distribution; is a decay function starting at evaluate(0)=1. 

        """
        return _libBornAgainCore.FTDistribution1DGauss_evaluate(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FTDistribution1DGauss
    __del__ = lambda self: None
FTDistribution1DGauss_swigregister = _libBornAgainCore.FTDistribution1DGauss_swigregister
FTDistribution1DGauss_swigregister(FTDistribution1DGauss)

class FTDistribution1DGate(IFTDistribution1D):
    """


    Square gate  IFTDistribution1D; its Fourier transform evaluate(q) is a sinc function starting at evaluate(0)=1.

    C++ includes: FTDistributions1D.h

    """

    __swig_setmethods__ = {}
    for _s in [IFTDistribution1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FTDistribution1DGate, name, value)
    __swig_getmethods__ = {}
    for _s in [IFTDistribution1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FTDistribution1DGate, name)
    __repr__ = _swig_repr

    def __init__(self, omega):
        """
        __init__(FTDistribution1DGate self, double omega) -> FTDistribution1DGate

        FTDistribution1DGate::FTDistribution1DGate(double omega)

        """
        this = _libBornAgainCore.new_FTDistribution1DGate(omega)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FTDistribution1DGate self) -> FTDistribution1DGate

        FTDistribution1DGate* FTDistribution1DGate::clone() const final

        """
        return _libBornAgainCore.FTDistribution1DGate_clone(self)


    def evaluate(self, q):
        """
        evaluate(FTDistribution1DGate self, double q) -> double

        double FTDistribution1DGate::evaluate(double q) const final

        Returns Fourier transform of this distribution; is a decay function starting at evaluate(0)=1. 

        """
        return _libBornAgainCore.FTDistribution1DGate_evaluate(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FTDistribution1DGate
    __del__ = lambda self: None
FTDistribution1DGate_swigregister = _libBornAgainCore.FTDistribution1DGate_swigregister
FTDistribution1DGate_swigregister(FTDistribution1DGate)

class FTDistribution1DTriangle(IFTDistribution1D):
    """


    Triangle  IFTDistribution1D [1-|x|/omega if |x|<omega, and 0 otherwise]; its Fourier transform evaluate(q) is a squared sinc function starting at evaluate(0)=1.

    C++ includes: FTDistributions1D.h

    """

    __swig_setmethods__ = {}
    for _s in [IFTDistribution1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FTDistribution1DTriangle, name, value)
    __swig_getmethods__ = {}
    for _s in [IFTDistribution1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FTDistribution1DTriangle, name)
    __repr__ = _swig_repr

    def __init__(self, omega):
        """
        __init__(FTDistribution1DTriangle self, double omega) -> FTDistribution1DTriangle

        FTDistribution1DTriangle::FTDistribution1DTriangle(double omega)

        """
        this = _libBornAgainCore.new_FTDistribution1DTriangle(omega)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_FTDistribution1DTriangle
    __del__ = lambda self: None

    def clone(self):
        """
        clone(FTDistribution1DTriangle self) -> FTDistribution1DTriangle

        FTDistribution1DTriangle* FTDistribution1DTriangle::clone() const final

        """
        return _libBornAgainCore.FTDistribution1DTriangle_clone(self)


    def evaluate(self, q):
        """
        evaluate(FTDistribution1DTriangle self, double q) -> double

        double FTDistribution1DTriangle::evaluate(double q) const final

        Returns Fourier transform of this distribution; is a decay function starting at evaluate(0)=1. 

        """
        return _libBornAgainCore.FTDistribution1DTriangle_evaluate(self, q)

FTDistribution1DTriangle_swigregister = _libBornAgainCore.FTDistribution1DTriangle_swigregister
FTDistribution1DTriangle_swigregister(FTDistribution1DTriangle)

class FTDistribution1DCosine(IFTDistribution1D):
    """


    IFTDistribution1D consisting of one cosine wave [1+cos(pi*x/omega) if |x|<omega, and 0 otherwise]; its Fourier transform evaluate(q) starts at evaluate(0)=1.

    C++ includes: FTDistributions1D.h

    """

    __swig_setmethods__ = {}
    for _s in [IFTDistribution1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FTDistribution1DCosine, name, value)
    __swig_getmethods__ = {}
    for _s in [IFTDistribution1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FTDistribution1DCosine, name)
    __repr__ = _swig_repr

    def __init__(self, omega):
        """
        __init__(FTDistribution1DCosine self, double omega) -> FTDistribution1DCosine

        FTDistribution1DCosine::FTDistribution1DCosine(double omega)

        """
        this = _libBornAgainCore.new_FTDistribution1DCosine(omega)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FTDistribution1DCosine self) -> FTDistribution1DCosine

        FTDistribution1DCosine* FTDistribution1DCosine::clone() const final

        """
        return _libBornAgainCore.FTDistribution1DCosine_clone(self)


    def evaluate(self, q):
        """
        evaluate(FTDistribution1DCosine self, double q) -> double

        double FTDistribution1DCosine::evaluate(double q) const final

        Returns Fourier transform of this distribution; is a decay function starting at evaluate(0)=1. 

        """
        return _libBornAgainCore.FTDistribution1DCosine_evaluate(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FTDistribution1DCosine
    __del__ = lambda self: None
FTDistribution1DCosine_swigregister = _libBornAgainCore.FTDistribution1DCosine_swigregister
FTDistribution1DCosine_swigregister(FTDistribution1DCosine)

class FTDistribution1DVoigt(IFTDistribution1D):
    """


    IFTDistribution1D that provides a Fourier transform evaluate(q) in form of a pseudo-Voigt decay function eta*Gauss + (1-eta)*Cauchy, with both components starting at 1 for q=0.

    C++ includes: FTDistributions1D.h

    """

    __swig_setmethods__ = {}
    for _s in [IFTDistribution1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FTDistribution1DVoigt, name, value)
    __swig_getmethods__ = {}
    for _s in [IFTDistribution1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FTDistribution1DVoigt, name)
    __repr__ = _swig_repr

    def __init__(self, omega, eta):
        """
        __init__(FTDistribution1DVoigt self, double omega, double eta) -> FTDistribution1DVoigt

        FTDistribution1DVoigt::FTDistribution1DVoigt(double omega, double eta)

        """
        this = _libBornAgainCore.new_FTDistribution1DVoigt(omega, eta)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FTDistribution1DVoigt self) -> FTDistribution1DVoigt

        FTDistribution1DVoigt* FTDistribution1DVoigt::clone() const final

        """
        return _libBornAgainCore.FTDistribution1DVoigt_clone(self)


    def evaluate(self, q):
        """
        evaluate(FTDistribution1DVoigt self, double q) -> double

        double FTDistribution1DVoigt::evaluate(double q) const final

        Returns Fourier transform of this distribution; is a decay function starting at evaluate(0)=1. 

        """
        return _libBornAgainCore.FTDistribution1DVoigt_evaluate(self, q)


    def getEta(self):
        """
        getEta(FTDistribution1DVoigt self) -> double

        double FTDistribution1DVoigt::getEta() const

        """
        return _libBornAgainCore.FTDistribution1DVoigt_getEta(self)

    __swig_destroy__ = _libBornAgainCore.delete_FTDistribution1DVoigt
    __del__ = lambda self: None
FTDistribution1DVoigt_swigregister = _libBornAgainCore.FTDistribution1DVoigt_swigregister
FTDistribution1DVoigt_swigregister(FTDistribution1DVoigt)

class IFTDistribution2D(IParameterized):
    """


    Interface for two-dimensional distributions in Fourier space.

    C++ includes: FTDistributions2D.h

    """

    __swig_setmethods__ = {}
    for _s in [IParameterized]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFTDistribution2D, name, value)
    __swig_getmethods__ = {}
    for _s in [IParameterized]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFTDistribution2D, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self):
        """
        clone(IFTDistribution2D self) -> IFTDistribution2D

        virtual IFTDistribution2D* IFTDistribution2D::clone() const =0

        """
        return _libBornAgainCore.IFTDistribution2D_clone(self)


    def setGamma(self, gamma):
        """
        setGamma(IFTDistribution2D self, double gamma)

        void IFTDistribution2D::setGamma(double gamma)

        """
        return _libBornAgainCore.IFTDistribution2D_setGamma(self, gamma)


    def getGamma(self):
        """
        getGamma(IFTDistribution2D self) -> double

        double IFTDistribution2D::getGamma() const

        """
        return _libBornAgainCore.IFTDistribution2D_getGamma(self)


    def getDelta(self):
        """
        getDelta(IFTDistribution2D self) -> double

        double IFTDistribution2D::getDelta() const

        """
        return _libBornAgainCore.IFTDistribution2D_getDelta(self)


    def getCoherenceLengthX(self):
        """
        getCoherenceLengthX(IFTDistribution2D self) -> double

        double IFTDistribution2D::getCoherenceLengthX() const

        """
        return _libBornAgainCore.IFTDistribution2D_getCoherenceLengthX(self)


    def getCoherenceLengthY(self):
        """
        getCoherenceLengthY(IFTDistribution2D self) -> double

        double IFTDistribution2D::getCoherenceLengthY() const

        """
        return _libBornAgainCore.IFTDistribution2D_getCoherenceLengthY(self)


    def evaluate(self, qx, qy):
        """
        evaluate(IFTDistribution2D self, double qx, double qy) -> double

        virtual double IFTDistribution2D::evaluate(double qx, double qy) const =0

        evaluate Fourier transformed distribution for q in X,Y coordinates the original distribution (in real space) is assumed to be normalized: total integral is equal to 1 

        """
        return _libBornAgainCore.IFTDistribution2D_evaluate(self, qx, qy)

    __swig_destroy__ = _libBornAgainCore.delete_IFTDistribution2D
    __del__ = lambda self: None
IFTDistribution2D_swigregister = _libBornAgainCore.IFTDistribution2D_swigregister
IFTDistribution2D_swigregister(IFTDistribution2D)

class FTDistribution2DCauchy(IFTDistribution2D):
    """


    Two-dimensional Cauchy distribution in Fourier space; corresponds to a normalized exp(-r) in real space, with  $r=\\sqrt{(\\frac{x}{\\omega_x})^2 + (\\frac{y}{\\omega_y})^2}$.

    C++ includes: FTDistributions2D.h

    """

    __swig_setmethods__ = {}
    for _s in [IFTDistribution2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FTDistribution2DCauchy, name, value)
    __swig_getmethods__ = {}
    for _s in [IFTDistribution2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FTDistribution2DCauchy, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FTDistribution2DCauchy self, double coherence_length_x, double coherence_length_y, double gamma=0, double delta) -> FTDistribution2DCauchy
        __init__(FTDistribution2DCauchy self, double coherence_length_x, double coherence_length_y, double gamma=0) -> FTDistribution2DCauchy
        __init__(FTDistribution2DCauchy self, double coherence_length_x, double coherence_length_y) -> FTDistribution2DCauchy

        FTDistribution2DCauchy::FTDistribution2DCauchy(double coherence_length_x, double coherence_length_y, double gamma=0, double delta=M_PI_2)

        """
        this = _libBornAgainCore.new_FTDistribution2DCauchy(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FTDistribution2DCauchy self) -> FTDistribution2DCauchy

        FTDistribution2DCauchy* FTDistribution2DCauchy::clone() const final

        """
        return _libBornAgainCore.FTDistribution2DCauchy_clone(self)


    def evaluate(self, qx, qy):
        """
        evaluate(FTDistribution2DCauchy self, double qx, double qy) -> double

        double FTDistribution2DCauchy::evaluate(double qx, double qy) const final

        evaluate Fourier transformed distribution for q in X,Y coordinates the original distribution (in real space) is assumed to be normalized: total integral is equal to 1 

        """
        return _libBornAgainCore.FTDistribution2DCauchy_evaluate(self, qx, qy)

    __swig_destroy__ = _libBornAgainCore.delete_FTDistribution2DCauchy
    __del__ = lambda self: None
FTDistribution2DCauchy_swigregister = _libBornAgainCore.FTDistribution2DCauchy_swigregister
FTDistribution2DCauchy_swigregister(FTDistribution2DCauchy)

class FTDistribution2DGauss(IFTDistribution2D):
    """


    Two-dimensional Gauss distribution in Fourier space; corresponds to normalized exp(-r^2/2) in real space with  $r=\\sqrt{(\\frac{x}{\\omega_x})^2 + (\\frac{y}{\\omega_y})^2}$.

    C++ includes: FTDistributions2D.h

    """

    __swig_setmethods__ = {}
    for _s in [IFTDistribution2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FTDistribution2DGauss, name, value)
    __swig_getmethods__ = {}
    for _s in [IFTDistribution2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FTDistribution2DGauss, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FTDistribution2DGauss self, double coherence_length_x, double coherence_length_y, double gamma=0, double delta) -> FTDistribution2DGauss
        __init__(FTDistribution2DGauss self, double coherence_length_x, double coherence_length_y, double gamma=0) -> FTDistribution2DGauss
        __init__(FTDistribution2DGauss self, double coherence_length_x, double coherence_length_y) -> FTDistribution2DGauss

        FTDistribution2DGauss::FTDistribution2DGauss(double coherence_length_x, double coherence_length_y, double gamma=0, double delta=M_PI_2)

        """
        this = _libBornAgainCore.new_FTDistribution2DGauss(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FTDistribution2DGauss self) -> FTDistribution2DGauss

        FTDistribution2DGauss* FTDistribution2DGauss::clone() const final

        """
        return _libBornAgainCore.FTDistribution2DGauss_clone(self)


    def evaluate(self, qx, qy):
        """
        evaluate(FTDistribution2DGauss self, double qx, double qy) -> double

        double FTDistribution2DGauss::evaluate(double qx, double qy) const final

        evaluate Fourier transformed distribution for q in X,Y coordinates the original distribution (in real space) is assumed to be normalized: total integral is equal to 1 

        """
        return _libBornAgainCore.FTDistribution2DGauss_evaluate(self, qx, qy)

    __swig_destroy__ = _libBornAgainCore.delete_FTDistribution2DGauss
    __del__ = lambda self: None
FTDistribution2DGauss_swigregister = _libBornAgainCore.FTDistribution2DGauss_swigregister
FTDistribution2DGauss_swigregister(FTDistribution2DGauss)

class FTDistribution2DGate(IFTDistribution2D):
    """


    Two-dimensional gate distribution in Fourier space; corresponds to normalized constant if r<1 (and 0 otherwise) in real space, with  $r=\\sqrt{(\\frac{x}{\\omega_x})^2 + (\\frac{y}{\\omega_y})^2}$.

    C++ includes: FTDistributions2D.h

    """

    __swig_setmethods__ = {}
    for _s in [IFTDistribution2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FTDistribution2DGate, name, value)
    __swig_getmethods__ = {}
    for _s in [IFTDistribution2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FTDistribution2DGate, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FTDistribution2DGate self, double coherence_length_x, double coherence_length_y, double gamma=0, double delta) -> FTDistribution2DGate
        __init__(FTDistribution2DGate self, double coherence_length_x, double coherence_length_y, double gamma=0) -> FTDistribution2DGate
        __init__(FTDistribution2DGate self, double coherence_length_x, double coherence_length_y) -> FTDistribution2DGate

        FTDistribution2DGate::FTDistribution2DGate(double coherence_length_x, double coherence_length_y, double gamma=0, double delta=M_PI_2)

        """
        this = _libBornAgainCore.new_FTDistribution2DGate(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FTDistribution2DGate self) -> FTDistribution2DGate

        FTDistribution2DGate* FTDistribution2DGate::clone() const final

        """
        return _libBornAgainCore.FTDistribution2DGate_clone(self)


    def evaluate(self, qx, qy):
        """
        evaluate(FTDistribution2DGate self, double qx, double qy) -> double

        double FTDistribution2DGate::evaluate(double qx, double qy) const final

        evaluate Fourier transformed distribution for q in X,Y coordinates the original distribution (in real space) is assumed to be normalized: total integral is equal to 1 

        """
        return _libBornAgainCore.FTDistribution2DGate_evaluate(self, qx, qy)

    __swig_destroy__ = _libBornAgainCore.delete_FTDistribution2DGate
    __del__ = lambda self: None
FTDistribution2DGate_swigregister = _libBornAgainCore.FTDistribution2DGate_swigregister
FTDistribution2DGate_swigregister(FTDistribution2DGate)

class FTDistribution2DCone(IFTDistribution2D):
    """


    Two-dimensional cone distribution in Fourier space; corresponds to 1-r if r<1 (and 0 otherwise) in real space with  $r=\\sqrt{(\\frac{x}{\\omega_x})^2 + (\\frac{y}{\\omega_y})^2}$.

    C++ includes: FTDistributions2D.h

    """

    __swig_setmethods__ = {}
    for _s in [IFTDistribution2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FTDistribution2DCone, name, value)
    __swig_getmethods__ = {}
    for _s in [IFTDistribution2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FTDistribution2DCone, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FTDistribution2DCone self, double coherence_length_x, double coherence_length_y, double gamma=0, double delta) -> FTDistribution2DCone
        __init__(FTDistribution2DCone self, double coherence_length_x, double coherence_length_y, double gamma=0) -> FTDistribution2DCone
        __init__(FTDistribution2DCone self, double coherence_length_x, double coherence_length_y) -> FTDistribution2DCone

        FTDistribution2DCone::FTDistribution2DCone(double coherence_length_x, double coherence_length_y, double gamma=0, double delta=M_PI_2)

        """
        this = _libBornAgainCore.new_FTDistribution2DCone(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FTDistribution2DCone self) -> FTDistribution2DCone

        FTDistribution2DCone* FTDistribution2DCone::clone() const final

        """
        return _libBornAgainCore.FTDistribution2DCone_clone(self)


    def evaluate(self, qx, qy):
        """
        evaluate(FTDistribution2DCone self, double qx, double qy) -> double

        double FTDistribution2DCone::evaluate(double qx, double qy) const final

        evaluate Fourier transformed distribution for q in X,Y coordinates the original distribution (in real space) is assumed to be normalized: total integral is equal to 1 

        """
        return _libBornAgainCore.FTDistribution2DCone_evaluate(self, qx, qy)

    __swig_destroy__ = _libBornAgainCore.delete_FTDistribution2DCone
    __del__ = lambda self: None
FTDistribution2DCone_swigregister = _libBornAgainCore.FTDistribution2DCone_swigregister
FTDistribution2DCone_swigregister(FTDistribution2DCone)

class FTDistribution2DVoigt(IFTDistribution2D):
    """


    Two-dimensional Voigt distribution in Fourier space; corresponds to eta*Gauss + (1-eta)*Cauchy

    C++ includes: FTDistributions2D.h

    """

    __swig_setmethods__ = {}
    for _s in [IFTDistribution2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FTDistribution2DVoigt, name, value)
    __swig_getmethods__ = {}
    for _s in [IFTDistribution2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FTDistribution2DVoigt, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FTDistribution2DVoigt self, double coherence_length_x, double coherence_length_y, double eta, double gamma=0, double delta) -> FTDistribution2DVoigt
        __init__(FTDistribution2DVoigt self, double coherence_length_x, double coherence_length_y, double eta, double gamma=0) -> FTDistribution2DVoigt
        __init__(FTDistribution2DVoigt self, double coherence_length_x, double coherence_length_y, double eta) -> FTDistribution2DVoigt

        FTDistribution2DVoigt::FTDistribution2DVoigt(double coherence_length_x, double coherence_length_y, double eta, double gamma=0, double delta=M_PI_2)

        """
        this = _libBornAgainCore.new_FTDistribution2DVoigt(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FTDistribution2DVoigt self) -> FTDistribution2DVoigt

        FTDistribution2DVoigt* FTDistribution2DVoigt::clone() const final

        """
        return _libBornAgainCore.FTDistribution2DVoigt_clone(self)


    def evaluate(self, qx, qy):
        """
        evaluate(FTDistribution2DVoigt self, double qx, double qy) -> double

        double FTDistribution2DVoigt::evaluate(double qx, double qy) const final

        evaluate Fourier transformed distribution for q in X,Y coordinates the original distribution (in real space) is assumed to be normalized: total integral is equal to 1 

        """
        return _libBornAgainCore.FTDistribution2DVoigt_evaluate(self, qx, qy)


    def getEta(self):
        """
        getEta(FTDistribution2DVoigt self) -> double

        double FTDistribution2DVoigt::getEta() const

        """
        return _libBornAgainCore.FTDistribution2DVoigt_getEta(self)

    __swig_destroy__ = _libBornAgainCore.delete_FTDistribution2DVoigt
    __del__ = lambda self: None
FTDistribution2DVoigt_swigregister = _libBornAgainCore.FTDistribution2DVoigt_swigregister
FTDistribution2DVoigt_swigregister(FTDistribution2DVoigt)

class FixedBinAxis(IAxis):
    """


    Axis with fixed bin size.

    C++ includes: FixedBinAxis.h

    """

    __swig_setmethods__ = {}
    for _s in [IAxis]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FixedBinAxis, name, value)
    __swig_getmethods__ = {}
    for _s in [IAxis]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FixedBinAxis, name)
    __repr__ = _swig_repr

    def __init__(self, name, nbins, start, end):
        """
        __init__(FixedBinAxis self, std::string const & name, size_t nbins, double start, double end) -> FixedBinAxis

        FixedBinAxis::FixedBinAxis(const std::string &name, size_t nbins, double start, double end)

        FixedBinAxis constructor.

        Parameters:
        -----------

        name: 
        Axis name

        nbins: 
        number of bins

        start: 
        low edge of first bin

        end: 
        upper edge of last bin 

        """
        this = _libBornAgainCore.new_FixedBinAxis(name, nbins, start, end)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_FixedBinAxis
    __del__ = lambda self: None

    def clone(self):
        """
        clone(FixedBinAxis self) -> FixedBinAxis

        FixedBinAxis * FixedBinAxis::clone() const

        clone function 

        """
        return _libBornAgainCore.FixedBinAxis_clone(self)


    def size(self):
        """
        size(FixedBinAxis self) -> size_t

        size_t FixedBinAxis::size() const

        retrieve the number of bins 

        """
        return _libBornAgainCore.FixedBinAxis_size(self)


    def getBin(self, index):
        """
        getBin(FixedBinAxis self, size_t index) -> Bin1D

        Bin1D FixedBinAxis::getBin(size_t index) const

        retrieve a 1d bin for the given index 

        """
        return _libBornAgainCore.FixedBinAxis_getBin(self, index)


    def getMin(self):
        """
        getMin(FixedBinAxis self) -> double

        double FixedBinAxis::getMin() const

        Returns value of first point of axis. 

        """
        return _libBornAgainCore.FixedBinAxis_getMin(self)


    def getMax(self):
        """
        getMax(FixedBinAxis self) -> double

        double FixedBinAxis::getMax() const

        Returns value of last point of axis. 

        """
        return _libBornAgainCore.FixedBinAxis_getMax(self)


    def getBinCenter(self, index):
        """
        getBinCenter(FixedBinAxis self, size_t index) -> double

        double FixedBinAxis::getBinCenter(size_t index) const

        """
        return _libBornAgainCore.FixedBinAxis_getBinCenter(self, index)


    def findClosestIndex(self, value):
        """
        findClosestIndex(FixedBinAxis self, double value) -> size_t

        size_t FixedBinAxis::findClosestIndex(double value) const

        find bin index which is best match for given value 

        """
        return _libBornAgainCore.FixedBinAxis_findClosestIndex(self, value)


    def getBinCenters(self):
        """
        getBinCenters(FixedBinAxis self) -> vdouble1d_t

        std::vector< double > FixedBinAxis::getBinCenters() const

        """
        return _libBornAgainCore.FixedBinAxis_getBinCenters(self)


    def getBinBoundaries(self):
        """
        getBinBoundaries(FixedBinAxis self) -> vdouble1d_t

        std::vector< double > FixedBinAxis::getBinBoundaries() const

        """
        return _libBornAgainCore.FixedBinAxis_getBinBoundaries(self)


    def createClippedAxis(self, left, right):
        """
        createClippedAxis(FixedBinAxis self, double left, double right) -> FixedBinAxis

        FixedBinAxis * FixedBinAxis::createClippedAxis(double left, double right) const

        Creates a new clipped axis. 

        """
        return _libBornAgainCore.FixedBinAxis_createClippedAxis(self, left, right)


    def __getitem__(self, i):
        """__getitem__(FixedBinAxis self, unsigned int i) -> double"""
        return _libBornAgainCore.FixedBinAxis___getitem__(self, i)

FixedBinAxis_swigregister = _libBornAgainCore.FixedBinAxis_swigregister
FixedBinAxis_swigregister(FixedBinAxis)

class IFormFactor(ISample):
    """


    Pure virtual base class for all form factors.

    The actual form factor is returned by the complex valued function  IFormFactor::evaluate, which depends on the incoming and outgoing wave vectors ki and kf. If it only depends on the scattering vector q=ki-kf, then it is a IBornFormFactor.

    Other children besides IBornFormFactor are  IFormFactorDecorator,  FormFactorWeighted,  FormFactorDWBA,  FormFactorDWBAPol and  FormFactorCrystal.

    C++ includes: IFormFactor.h

    """

    __swig_setmethods__ = {}
    for _s in [ISample]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFormFactor, name, value)
    __swig_getmethods__ = {}
    for _s in [ISample]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFormFactor, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(IFormFactor self) -> IFormFactor

        IFormFactor::IFormFactor()

        """
        if self.__class__ == IFormFactor:
            _self = None
        else:
            _self = self
        this = _libBornAgainCore.new_IFormFactor(_self, )
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_IFormFactor
    __del__ = lambda self: None

    def clone(self):
        """
        clone(IFormFactor self) -> IFormFactor

        IFormFactor* IFormFactor::clone() const override=0

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.IFormFactor_clone(self)


    def accept(self, visitor):
        """
        accept(IFormFactor self, ISampleVisitor visitor)

        void IFormFactor::accept(ISampleVisitor *visitor) const override=0

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.IFormFactor_accept(self, visitor)


    def setAmbientMaterial(self, arg0):
        """
        setAmbientMaterial(IFormFactor self, IMaterial arg0)

        virtual void IFormFactor::setAmbientMaterial(const IMaterial &)

        Passes the refractive index of the ambient material in which this particle is embedded. 

        """
        return _libBornAgainCore.IFormFactor_setAmbientMaterial(self, arg0)


    def evaluate(self, wavevectors):
        """
        evaluate(IFormFactor self, WavevectorInfo wavevectors) -> complex_t

        virtual complex_t IFormFactor::evaluate(const WavevectorInfo &wavevectors) const =0

        Returns scattering amplitude for complex wavevectors ki, kf. 

        """
        return _libBornAgainCore.IFormFactor_evaluate(self, wavevectors)


    def getVolume(self):
        """
        getVolume(IFormFactor self) -> double

        double IFormFactor::getVolume() const

        Returns the total volume of the particle of this form factor's shape. 

        """
        return _libBornAgainCore.IFormFactor_getVolume(self)


    def getRadialExtension(self):
        """
        getRadialExtension(IFormFactor self) -> double

        virtual double IFormFactor::getRadialExtension() const =0

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.IFormFactor_getRadialExtension(self)


    def setSpecularInfo(self, arg0, arg1):
        """
        setSpecularInfo(IFormFactor self, ILayerRTCoefficients const * arg0, ILayerRTCoefficients const * arg1)

        virtual void IFormFactor::setSpecularInfo(const ILayerRTCoefficients *, const ILayerRTCoefficients *)

        Sets reflection/transmission info. 

        """
        return _libBornAgainCore.IFormFactor_setSpecularInfo(self, arg0, arg1)

    def __disown__(self):
        self.this.disown()
        _libBornAgainCore.disown_IFormFactor(self)
        return weakref_proxy(self)

    def onChange(self):
        """onChange(IFormFactor self)"""
        return _libBornAgainCore.IFormFactor_onChange(self)


    def _print(self, ostr):
        """_print(IFormFactor self, std::ostream & ostr)"""
        return _libBornAgainCore.IFormFactor__print(self, ostr)

IFormFactor_swigregister = _libBornAgainCore.IFormFactor_swigregister
IFormFactor_swigregister(IFormFactor)

class vector_IFormFactorPtr_t(_object):
    """Proxy of C++ std::vector<(p.IFormFactor)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_IFormFactorPtr_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_IFormFactorPtr_t, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vector_IFormFactorPtr_t self) -> SwigPyIterator"""
        return _libBornAgainCore.vector_IFormFactorPtr_t_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vector_IFormFactorPtr_t self) -> bool"""
        return _libBornAgainCore.vector_IFormFactorPtr_t___nonzero__(self)


    def __bool__(self):
        """__bool__(vector_IFormFactorPtr_t self) -> bool"""
        return _libBornAgainCore.vector_IFormFactorPtr_t___bool__(self)


    def __len__(self):
        """__len__(vector_IFormFactorPtr_t self) -> std::vector< IFormFactor * >::size_type"""
        return _libBornAgainCore.vector_IFormFactorPtr_t___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::difference_type i, std::vector< IFormFactor * >::difference_type j) -> vector_IFormFactorPtr_t"""
        return _libBornAgainCore.vector_IFormFactorPtr_t___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::difference_type i, std::vector< IFormFactor * >::difference_type j)
        __setslice__(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::difference_type i, std::vector< IFormFactor * >::difference_type j, vector_IFormFactorPtr_t v)
        """
        return _libBornAgainCore.vector_IFormFactorPtr_t___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::difference_type i, std::vector< IFormFactor * >::difference_type j)"""
        return _libBornAgainCore.vector_IFormFactorPtr_t___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::difference_type i)
        __delitem__(vector_IFormFactorPtr_t self, PySliceObject * slice)
        """
        return _libBornAgainCore.vector_IFormFactorPtr_t___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vector_IFormFactorPtr_t self, PySliceObject * slice) -> vector_IFormFactorPtr_t
        __getitem__(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::difference_type i) -> IFormFactor
        """
        return _libBornAgainCore.vector_IFormFactorPtr_t___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vector_IFormFactorPtr_t self, PySliceObject * slice, vector_IFormFactorPtr_t v)
        __setitem__(vector_IFormFactorPtr_t self, PySliceObject * slice)
        __setitem__(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::difference_type i, IFormFactor x)
        """
        return _libBornAgainCore.vector_IFormFactorPtr_t___setitem__(self, *args)


    def pop(self):
        """pop(vector_IFormFactorPtr_t self) -> IFormFactor"""
        return _libBornAgainCore.vector_IFormFactorPtr_t_pop(self)


    def append(self, x):
        """append(vector_IFormFactorPtr_t self, IFormFactor x)"""
        return _libBornAgainCore.vector_IFormFactorPtr_t_append(self, x)


    def empty(self):
        """empty(vector_IFormFactorPtr_t self) -> bool"""
        return _libBornAgainCore.vector_IFormFactorPtr_t_empty(self)


    def size(self):
        """size(vector_IFormFactorPtr_t self) -> std::vector< IFormFactor * >::size_type"""
        return _libBornAgainCore.vector_IFormFactorPtr_t_size(self)


    def swap(self, v):
        """
        swap(vector_IFormFactorPtr_t self, vector_IFormFactorPtr_t v)

        void swap(OutputDataIterator< TValue, TContainer > &left, OutputDataIterator< TValue, TContainer > &right)

        make Swappable 

        """
        return _libBornAgainCore.vector_IFormFactorPtr_t_swap(self, v)


    def begin(self):
        """begin(vector_IFormFactorPtr_t self) -> std::vector< IFormFactor * >::iterator"""
        return _libBornAgainCore.vector_IFormFactorPtr_t_begin(self)


    def end(self):
        """end(vector_IFormFactorPtr_t self) -> std::vector< IFormFactor * >::iterator"""
        return _libBornAgainCore.vector_IFormFactorPtr_t_end(self)


    def rbegin(self):
        """rbegin(vector_IFormFactorPtr_t self) -> std::vector< IFormFactor * >::reverse_iterator"""
        return _libBornAgainCore.vector_IFormFactorPtr_t_rbegin(self)


    def rend(self):
        """rend(vector_IFormFactorPtr_t self) -> std::vector< IFormFactor * >::reverse_iterator"""
        return _libBornAgainCore.vector_IFormFactorPtr_t_rend(self)


    def clear(self):
        """clear(vector_IFormFactorPtr_t self)"""
        return _libBornAgainCore.vector_IFormFactorPtr_t_clear(self)


    def get_allocator(self):
        """get_allocator(vector_IFormFactorPtr_t self) -> std::vector< IFormFactor * >::allocator_type"""
        return _libBornAgainCore.vector_IFormFactorPtr_t_get_allocator(self)


    def pop_back(self):
        """pop_back(vector_IFormFactorPtr_t self)"""
        return _libBornAgainCore.vector_IFormFactorPtr_t_pop_back(self)


    def erase(self, *args):
        """
        erase(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::iterator pos) -> std::vector< IFormFactor * >::iterator
        erase(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::iterator first, std::vector< IFormFactor * >::iterator last) -> std::vector< IFormFactor * >::iterator
        """
        return _libBornAgainCore.vector_IFormFactorPtr_t_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(p.IFormFactor)> self) -> vector_IFormFactorPtr_t
        __init__(std::vector<(p.IFormFactor)> self, vector_IFormFactorPtr_t arg2) -> vector_IFormFactorPtr_t
        __init__(std::vector<(p.IFormFactor)> self, std::vector< IFormFactor * >::size_type size) -> vector_IFormFactorPtr_t
        __init__(std::vector<(p.IFormFactor)> self, std::vector< IFormFactor * >::size_type size, IFormFactor value) -> vector_IFormFactorPtr_t
        """
        this = _libBornAgainCore.new_vector_IFormFactorPtr_t(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vector_IFormFactorPtr_t self, IFormFactor x)"""
        return _libBornAgainCore.vector_IFormFactorPtr_t_push_back(self, x)


    def front(self):
        """front(vector_IFormFactorPtr_t self) -> IFormFactor"""
        return _libBornAgainCore.vector_IFormFactorPtr_t_front(self)


    def back(self):
        """back(vector_IFormFactorPtr_t self) -> IFormFactor"""
        return _libBornAgainCore.vector_IFormFactorPtr_t_back(self)


    def assign(self, n, x):
        """assign(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::size_type n, IFormFactor x)"""
        return _libBornAgainCore.vector_IFormFactorPtr_t_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::size_type new_size)
        resize(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::size_type new_size, IFormFactor x)
        """
        return _libBornAgainCore.vector_IFormFactorPtr_t_resize(self, *args)


    def insert(self, *args):
        """
        insert(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::iterator pos, IFormFactor x) -> std::vector< IFormFactor * >::iterator
        insert(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::iterator pos, std::vector< IFormFactor * >::size_type n, IFormFactor x)
        """
        return _libBornAgainCore.vector_IFormFactorPtr_t_insert(self, *args)


    def reserve(self, n):
        """reserve(vector_IFormFactorPtr_t self, std::vector< IFormFactor * >::size_type n)"""
        return _libBornAgainCore.vector_IFormFactorPtr_t_reserve(self, n)


    def capacity(self):
        """capacity(vector_IFormFactorPtr_t self) -> std::vector< IFormFactor * >::size_type"""
        return _libBornAgainCore.vector_IFormFactorPtr_t_capacity(self)

    __swig_destroy__ = _libBornAgainCore.delete_vector_IFormFactorPtr_t
    __del__ = lambda self: None
vector_IFormFactorPtr_t_swigregister = _libBornAgainCore.vector_IFormFactorPtr_t_swigregister
vector_IFormFactorPtr_t_swigregister(vector_IFormFactorPtr_t)

class IFormFactorBorn(IFormFactor):
    """


    Pure virtual base class for Born form factors.

    In contrast to the generic  IFormFactor, a Born form factor does not depend on the incoming and outgoing wave vectors ki and kf, except through their difference, the scattering vector q=ki-kf.

    C++ includes: IFormFactorBorn.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactor]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFormFactorBorn, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactor]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFormFactorBorn, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(IFormFactorBorn self) -> IFormFactorBorn

        IFormFactorBorn::IFormFactorBorn()

        """
        if self.__class__ == IFormFactorBorn:
            _self = None
        else:
            _self = self
        this = _libBornAgainCore.new_IFormFactorBorn(_self, )
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_IFormFactorBorn
    __del__ = lambda self: None

    def clone(self):
        """
        clone(IFormFactorBorn self) -> IFormFactorBorn

        IFormFactorBorn* IFormFactorBorn::clone() const override=0

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.IFormFactorBorn_clone(self)


    def evaluate(self, wavevectors):
        """
        evaluate(IFormFactorBorn self, WavevectorInfo wavevectors) -> complex_t

        complex_t IFormFactorBorn::evaluate(const WavevectorInfo &wavevectors) const override

        Returns scattering amplitude for complex wavevectors ki, kf. 

        """
        return _libBornAgainCore.IFormFactorBorn_evaluate(self, wavevectors)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(IFormFactorBorn self, cvector_t q) -> complex_t

        virtual complex_t IFormFactorBorn::evaluate_for_q(const cvector_t q) const =0

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainCore.IFormFactorBorn_evaluate_for_q(self, q)

    def __disown__(self):
        self.this.disown()
        _libBornAgainCore.disown_IFormFactorBorn(self)
        return weakref_proxy(self)

    def onChange(self):
        """onChange(IFormFactorBorn self)"""
        return _libBornAgainCore.IFormFactorBorn_onChange(self)


    def _print(self, ostr):
        """_print(IFormFactorBorn self, std::ostream & ostr)"""
        return _libBornAgainCore.IFormFactorBorn__print(self, ostr)

IFormFactorBorn_swigregister = _libBornAgainCore.IFormFactorBorn_swigregister
IFormFactorBorn_swigregister(IFormFactorBorn)

class IFormFactorDecorator(IFormFactor):
    """


    Encapsulates another formfactor and adds extra functionality (a scalar factor, a Debye-Waller factor, a position-dependent phase factor, ...).

    This class is designed according to the Decorator Pattern. It inherits from  IFormFactor and has a member of type IFormFactor*.

    C++ includes: IFormFactorDecorator.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactor]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFormFactorDecorator, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactor]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFormFactorDecorator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_IFormFactorDecorator
    __del__ = lambda self: None

    def clone(self):
        """
        clone(IFormFactorDecorator self) -> IFormFactorDecorator

        IFormFactorDecorator* IFormFactorDecorator::clone() const override=0

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.IFormFactorDecorator_clone(self)


    def accept(self, visitor):
        """
        accept(IFormFactorDecorator self, ISampleVisitor visitor)

        void IFormFactorDecorator::accept(ISampleVisitor *visitor) const override=0

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.IFormFactorDecorator_accept(self, visitor)


    def setAmbientMaterial(self, material):
        """
        setAmbientMaterial(IFormFactorDecorator self, IMaterial material)

        void IFormFactorDecorator::setAmbientMaterial(const IMaterial &material) override

        Passes the refractive index of the ambient material in which this particle is embedded. 

        """
        return _libBornAgainCore.IFormFactorDecorator_setAmbientMaterial(self, material)


    def getVolume(self):
        """
        getVolume(IFormFactorDecorator self) -> double

        double IFormFactorDecorator::getVolume() const override

        Returns the total volume of the particle of this form factor's shape. 

        """
        return _libBornAgainCore.IFormFactorDecorator_getVolume(self)


    def getRadialExtension(self):
        """
        getRadialExtension(IFormFactorDecorator self) -> double

        double IFormFactorDecorator::getRadialExtension() const override

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.IFormFactorDecorator_getRadialExtension(self)

IFormFactorDecorator_swigregister = _libBornAgainCore.IFormFactorDecorator_swigregister
IFormFactorDecorator_swigregister(IFormFactorDecorator)

class PolygonalTopology(_object):
    """


    For internal use in  PolyhedralFace.

    C++ includes: FormFactorPolyhedron.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolygonalTopology, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PolygonalTopology, name)
    __repr__ = _swig_repr
    __swig_setmethods__["vertexIndices"] = _libBornAgainCore.PolygonalTopology_vertexIndices_set
    __swig_getmethods__["vertexIndices"] = _libBornAgainCore.PolygonalTopology_vertexIndices_get
    if _newclass:
        vertexIndices = _swig_property(_libBornAgainCore.PolygonalTopology_vertexIndices_get, _libBornAgainCore.PolygonalTopology_vertexIndices_set)
    __swig_setmethods__["symmetry_S2"] = _libBornAgainCore.PolygonalTopology_symmetry_S2_set
    __swig_getmethods__["symmetry_S2"] = _libBornAgainCore.PolygonalTopology_symmetry_S2_get
    if _newclass:
        symmetry_S2 = _swig_property(_libBornAgainCore.PolygonalTopology_symmetry_S2_get, _libBornAgainCore.PolygonalTopology_symmetry_S2_set)

    def __init__(self):
        """
        __init__(PolygonalTopology self) -> PolygonalTopology



        For internal use in  PolyhedralFace.

        C++ includes: FormFactorPolyhedron.h

        """
        this = _libBornAgainCore.new_PolygonalTopology()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_PolygonalTopology
    __del__ = lambda self: None
PolygonalTopology_swigregister = _libBornAgainCore.PolygonalTopology_swigregister
PolygonalTopology_swigregister(PolygonalTopology)

class PolyhedralTopology(_object):
    """


    For internal use in  FormFactorPolyhedron.

    C++ includes: FormFactorPolyhedron.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolyhedralTopology, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PolyhedralTopology, name)
    __repr__ = _swig_repr
    __swig_setmethods__["faces"] = _libBornAgainCore.PolyhedralTopology_faces_set
    __swig_getmethods__["faces"] = _libBornAgainCore.PolyhedralTopology_faces_get
    if _newclass:
        faces = _swig_property(_libBornAgainCore.PolyhedralTopology_faces_get, _libBornAgainCore.PolyhedralTopology_faces_set)
    __swig_setmethods__["symmetry_Ci"] = _libBornAgainCore.PolyhedralTopology_symmetry_Ci_set
    __swig_getmethods__["symmetry_Ci"] = _libBornAgainCore.PolyhedralTopology_symmetry_Ci_get
    if _newclass:
        symmetry_Ci = _swig_property(_libBornAgainCore.PolyhedralTopology_symmetry_Ci_get, _libBornAgainCore.PolyhedralTopology_symmetry_Ci_set)

    def __init__(self):
        """
        __init__(PolyhedralTopology self) -> PolyhedralTopology



        For internal use in  FormFactorPolyhedron.

        C++ includes: FormFactorPolyhedron.h

        """
        this = _libBornAgainCore.new_PolyhedralTopology()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_PolyhedralTopology
    __del__ = lambda self: None
PolyhedralTopology_swigregister = _libBornAgainCore.PolyhedralTopology_swigregister
PolyhedralTopology_swigregister(PolyhedralTopology)

class PolyhedralEdge(_object):
    """


    One edge of a polygon, for form factor computation.

    C++ includes: FormFactorPolyhedron.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolyhedralEdge, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PolyhedralEdge, name)
    __repr__ = _swig_repr

    def __init__(self, _Vlow, _Vhig):
        """
        __init__(PolyhedralEdge self, kvector_t _Vlow, kvector_t _Vhig) -> PolyhedralEdge

        PolyhedralEdge::PolyhedralEdge(const kvector_t _Vlow, const kvector_t _Vhig)

        """
        this = _libBornAgainCore.new_PolyhedralEdge(_Vlow, _Vhig)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def E(self):
        """
        E(PolyhedralEdge self) -> kvector_t

        kvector_t PolyhedralEdge::E() const

        """
        return _libBornAgainCore.PolyhedralEdge_E(self)


    def R(self):
        """
        R(PolyhedralEdge self) -> kvector_t

        kvector_t PolyhedralEdge::R() const

        """
        return _libBornAgainCore.PolyhedralEdge_R(self)


    def qE(self, q):
        """
        qE(PolyhedralEdge self, cvector_t q) -> complex_t

        complex_t PolyhedralEdge::qE(cvector_t q) const

        """
        return _libBornAgainCore.PolyhedralEdge_qE(self, q)


    def qR(self, q):
        """
        qR(PolyhedralEdge self, cvector_t q) -> complex_t

        complex_t PolyhedralEdge::qR(cvector_t q) const

        """
        return _libBornAgainCore.PolyhedralEdge_qR(self, q)


    def contrib(self, m, qpa, qrperp):
        """
        contrib(PolyhedralEdge self, int m, cvector_t qpa, complex_t qrperp) -> complex_t

        complex_t PolyhedralEdge::contrib(int m, const cvector_t qpa, complex_t qrperp) const

        Returns sum_l=0^M/2 u^2l v^(M-2l) / (2l+1)!(M-2l)! - vperp^M/M! 

        """
        return _libBornAgainCore.PolyhedralEdge_contrib(self, m, qpa, qrperp)

    __swig_destroy__ = _libBornAgainCore.delete_PolyhedralEdge
    __del__ = lambda self: None
PolyhedralEdge_swigregister = _libBornAgainCore.PolyhedralEdge_swigregister
PolyhedralEdge_swigregister(PolyhedralEdge)

class PolyhedralFace(_object):
    """


    A polygon, for form factor computation.

    C++ includes: FormFactorPolyhedron.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolyhedralFace, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PolyhedralFace, name)
    __repr__ = _swig_repr

    def diameter(V):
        """diameter(vector_kvector_t V) -> double"""
        return _libBornAgainCore.PolyhedralFace_diameter(V)

    if _newclass:
        diameter = staticmethod(diameter)
    __swig_getmethods__["diameter"] = lambda x: diameter

    def __init__(self, *args):
        """
        __init__(PolyhedralFace self, vector_kvector_t _V, bool _sym_S2=False) -> PolyhedralFace
        __init__(PolyhedralFace self, vector_kvector_t _V) -> PolyhedralFace
        __init__(PolyhedralFace self) -> PolyhedralFace

        PolyhedralFace::PolyhedralFace(const std::vector< kvector_t > &_V=std::vector< kvector_t >(), bool _sym_S2=false)

        Sets internal variables for given vertex chain.

        Parameters:
        -----------

        V: 
        oriented vertex list

        _sym_S2: 
        true if face has a perpedicular two-fold symmetry axis 

        """
        this = _libBornAgainCore.new_PolyhedralFace(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def area(self):
        """
        area(PolyhedralFace self) -> double

        double PolyhedralFace::area() const

        """
        return _libBornAgainCore.PolyhedralFace_area(self)


    def center(self):
        """
        center(PolyhedralFace self) -> kvector_t

        kvector_t PolyhedralFace::center() const

        """
        return _libBornAgainCore.PolyhedralFace_center(self)


    def pyramidalVolume(self):
        """
        pyramidalVolume(PolyhedralFace self) -> double

        double PolyhedralFace::pyramidalVolume() const

        """
        return _libBornAgainCore.PolyhedralFace_pyramidalVolume(self)


    def radius3d(self):
        """
        radius3d(PolyhedralFace self) -> double

        double PolyhedralFace::radius3d() const

        """
        return _libBornAgainCore.PolyhedralFace_radius3d(self)


    def normalProjectionConj(self, q):
        """
        normalProjectionConj(PolyhedralFace self, cvector_t q) -> complex_t

        complex_t PolyhedralFace::normalProjectionConj(cvector_t q) const

        Returns conj(q)*normal [ BasicVector3D::dot is antilinear in 'this' argument]. 

        """
        return _libBornAgainCore.PolyhedralFace_normalProjectionConj(self, q)


    def ff_n(self, m, q):
        """
        ff_n(PolyhedralFace self, int m, cvector_t q) -> complex_t

        complex_t PolyhedralFace::ff_n(int m, const cvector_t q) const

        Returns contribution qn*f_n [of order q^(n+1)] from this face to the polyhedral form factor. 

        """
        return _libBornAgainCore.PolyhedralFace_ff_n(self, m, q)


    def ff(self, q, sym_Ci):
        """
        ff(PolyhedralFace self, cvector_t q, bool const sym_Ci) -> complex_t

        complex_t PolyhedralFace::ff(const cvector_t q, const bool sym_Ci) const

        Returns the contribution ff(q) of this face to the polyhedral form factor. 

        """
        return _libBornAgainCore.PolyhedralFace_ff(self, q, sym_Ci)


    def ff_2D(self, qpa):
        """
        ff_2D(PolyhedralFace self, cvector_t qpa) -> complex_t

        complex_t PolyhedralFace::ff_2D(const cvector_t qpa) const

        Returns the two-dimensional form factor of this face, for use in a prism. 

        """
        return _libBornAgainCore.PolyhedralFace_ff_2D(self, qpa)


    def assert_Ci(self, other):
        """
        assert_Ci(PolyhedralFace self, PolyhedralFace other)

        void PolyhedralFace::assert_Ci(const PolyhedralFace &other) const

        Throws if deviation from inversion symmetry is detected. Does not check vertices. 

        """
        return _libBornAgainCore.PolyhedralFace_assert_Ci(self, other)

    __swig_destroy__ = _libBornAgainCore.delete_PolyhedralFace
    __del__ = lambda self: None
PolyhedralFace_swigregister = _libBornAgainCore.PolyhedralFace_swigregister
PolyhedralFace_swigregister(PolyhedralFace)

def PolyhedralFace_diameter(V):
    """PolyhedralFace_diameter(vector_kvector_t V) -> double"""
    return _libBornAgainCore.PolyhedralFace_diameter(V)

class FormFactorPolyhedron(IFormFactorBorn):
    """


    A polyhedron, for form factor computation.

    C++ includes: FormFactorPolyhedron.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorPolyhedron, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorPolyhedron, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorPolyhedron self, cvector_t q) -> complex_t

        complex_t FormFactorPolyhedron::evaluate_for_q(const cvector_t q) const override final

        Returns the form factor F(q) of this polyhedron, respecting the offset z_origin. 

        """
        return _libBornAgainCore.FormFactorPolyhedron_evaluate_for_q(self, q)


    def evaluate_centered(self, q):
        """
        evaluate_centered(FormFactorPolyhedron self, cvector_t q) -> complex_t

        complex_t FormFactorPolyhedron::evaluate_centered(const cvector_t q) const

        Returns the form factor F(q) of this polyhedron, with origin at z=0. 

        """
        return _libBornAgainCore.FormFactorPolyhedron_evaluate_centered(self, q)


    def getVolume(self):
        """
        getVolume(FormFactorPolyhedron self) -> double

        double FormFactorPolyhedron::getVolume() const override final

        Returns the total volume of the particle of this form factor's shape. 

        """
        return _libBornAgainCore.FormFactorPolyhedron_getVolume(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorPolyhedron self) -> double

        double FormFactorPolyhedron::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorPolyhedron_getRadialExtension(self)


    def assert_platonic(self):
        """
        assert_platonic(FormFactorPolyhedron self)

        void FormFactorPolyhedron::assert_platonic() const

        Assertions for Platonic solid. 

        """
        return _libBornAgainCore.FormFactorPolyhedron_assert_platonic(self)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorPolyhedron
    __del__ = lambda self: None
FormFactorPolyhedron_swigregister = _libBornAgainCore.FormFactorPolyhedron_swigregister
FormFactorPolyhedron_swigregister(FormFactorPolyhedron)

class FormFactorPolygonalPrism(IFormFactorBorn):
    """


    A prism with a polygonal base, for form factor computation.

    C++ includes: FormFactorPolyhedron.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorPolygonalPrism, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorPolygonalPrism, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorPolygonalPrism self, cvector_t q) -> complex_t

        complex_t FormFactorPolygonalPrism::evaluate_for_q(const cvector_t q) const override final

        Returns the form factor F(q) of this polyhedron, respecting the offset height/2. 

        """
        return _libBornAgainCore.FormFactorPolygonalPrism_evaluate_for_q(self, q)


    def getVolume(self):
        """
        getVolume(FormFactorPolygonalPrism self) -> double

        double FormFactorPolygonalPrism::getVolume() const override final

        Returns the volume of this prism. 

        """
        return _libBornAgainCore.FormFactorPolygonalPrism_getVolume(self)


    def getHeight(self):
        """
        getHeight(FormFactorPolygonalPrism self) -> double

        double FormFactorPolygonalPrism::getHeight() const

        """
        return _libBornAgainCore.FormFactorPolygonalPrism_getHeight(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorPolygonalPrism self) -> double

        double FormFactorPolygonalPrism::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorPolygonalPrism_getRadialExtension(self)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorPolygonalPrism
    __del__ = lambda self: None
FormFactorPolygonalPrism_swigregister = _libBornAgainCore.FormFactorPolygonalPrism_swigregister
FormFactorPolygonalPrism_swigregister(FormFactorPolygonalPrism)

class FormFactorPolygonalSurface(IFormFactorBorn):
    """


    A polygonal surface, for testing form factor computations.

    C++ includes: FormFactorPolyhedron.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorPolygonalSurface, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorPolygonalSurface, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorPolygonalSurface self, cvector_t q) -> complex_t

        complex_t FormFactorPolygonalSurface::evaluate_for_q(const cvector_t q) const override final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainCore.FormFactorPolygonalSurface_evaluate_for_q(self, q)


    def getVolume(self):
        """
        getVolume(FormFactorPolygonalSurface self) -> double

        double FormFactorPolygonalSurface::getVolume() const override

        Returns the total volume of the particle of this form factor's shape. 

        """
        return _libBornAgainCore.FormFactorPolygonalSurface_getVolume(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorPolygonalSurface self) -> double

        double FormFactorPolygonalSurface::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorPolygonalSurface_getRadialExtension(self)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorPolygonalSurface
    __del__ = lambda self: None
FormFactorPolygonalSurface_swigregister = _libBornAgainCore.FormFactorPolygonalSurface_swigregister
FormFactorPolygonalSurface_swigregister(FormFactorPolygonalSurface)

class FormFactorAnisoPyramid(FormFactorPolyhedron):
    """


    A frustum (truncated pyramid) with rectangular base.

    C++ includes: FormFactorAnisoPyramid.h

    """

    __swig_setmethods__ = {}
    for _s in [FormFactorPolyhedron]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorAnisoPyramid, name, value)
    __swig_getmethods__ = {}
    for _s in [FormFactorPolyhedron]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorAnisoPyramid, name)
    __repr__ = _swig_repr

    def __init__(self, length, width, height, alpha):
        """
        __init__(FormFactorAnisoPyramid self, double length, double width, double height, double alpha) -> FormFactorAnisoPyramid

        FormFactorAnisoPyramid::FormFactorAnisoPyramid(double length, double width, double height, double alpha)

        Parameters:
        -----------

        length: 
        of one side of the rectangular base

        width: 
        of other side of the rectangular base

        height: 
        of frustum

        alpha: 
        dihedral angle in radians between base and facet 

        """
        this = _libBornAgainCore.new_FormFactorAnisoPyramid(length, width, height, alpha)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorAnisoPyramid self) -> FormFactorAnisoPyramid

        FormFactorAnisoPyramid* FormFactorAnisoPyramid::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorAnisoPyramid_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorAnisoPyramid self, ISampleVisitor visitor)

        void FormFactorAnisoPyramid::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorAnisoPyramid_accept(self, visitor)


    def getLength(self):
        """
        getLength(FormFactorAnisoPyramid self) -> double

        double FormFactorAnisoPyramid::getLength() const

        """
        return _libBornAgainCore.FormFactorAnisoPyramid_getLength(self)


    def getWidth(self):
        """
        getWidth(FormFactorAnisoPyramid self) -> double

        double FormFactorAnisoPyramid::getWidth() const

        """
        return _libBornAgainCore.FormFactorAnisoPyramid_getWidth(self)


    def getHeight(self):
        """
        getHeight(FormFactorAnisoPyramid self) -> double

        double FormFactorAnisoPyramid::getHeight() const

        """
        return _libBornAgainCore.FormFactorAnisoPyramid_getHeight(self)


    def getAlpha(self):
        """
        getAlpha(FormFactorAnisoPyramid self) -> double

        double FormFactorAnisoPyramid::getAlpha() const

        """
        return _libBornAgainCore.FormFactorAnisoPyramid_getAlpha(self)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorAnisoPyramid
    __del__ = lambda self: None
FormFactorAnisoPyramid_swigregister = _libBornAgainCore.FormFactorAnisoPyramid_swigregister
FormFactorAnisoPyramid_swigregister(FormFactorAnisoPyramid)

class FormFactorBox(IFormFactorBorn):
    """


    A rectangular prism (parallelepiped).

    C++ includes: FormFactorBox.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorBox, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorBox, name)
    __repr__ = _swig_repr

    def __init__(self, length, width, height):
        """
        __init__(FormFactorBox self, double length, double width, double height) -> FormFactorBox

        FormFactorBox::FormFactorBox(double length, double width, double height)

        Parameters:
        -----------

        length: 
        of rectangular base

        width: 
        of rectangular base

        height: 
        of prism 

        """
        this = _libBornAgainCore.new_FormFactorBox(length, width, height)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorBox self) -> FormFactorBox

        FormFactorBox* FormFactorBox::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorBox_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorBox self, ISampleVisitor visitor)

        void FormFactorBox::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorBox_accept(self, visitor)


    def getLength(self):
        """
        getLength(FormFactorBox self) -> double

        double FormFactorBox::getLength() const

        """
        return _libBornAgainCore.FormFactorBox_getLength(self)


    def getHeight(self):
        """
        getHeight(FormFactorBox self) -> double

        double FormFactorBox::getHeight() const

        """
        return _libBornAgainCore.FormFactorBox_getHeight(self)


    def getWidth(self):
        """
        getWidth(FormFactorBox self) -> double

        double FormFactorBox::getWidth() const

        """
        return _libBornAgainCore.FormFactorBox_getWidth(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorBox self) -> double

        double FormFactorBox::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorBox_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorBox self, cvector_t q) -> complex_t

        complex_t FormFactorBox::evaluate_for_q(const cvector_t q) const override final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainCore.FormFactorBox_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorBox
    __del__ = lambda self: None
FormFactorBox_swigregister = _libBornAgainCore.FormFactorBox_swigregister
FormFactorBox_swigregister(FormFactorBox)

class FormFactorCone(IFormFactorBorn):
    """


    A conical frustum (cone truncated parallel to the base) with circular base.

    C++ includes: FormFactorCone.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorCone, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorCone, name)
    __repr__ = _swig_repr

    def __init__(self, radius, height, alpha):
        """
        __init__(FormFactorCone self, double radius, double height, double alpha) -> FormFactorCone

        FormFactorCone::FormFactorCone(double radius, double height, double alpha)

        Parameters:
        -----------

        radius: 
        of circular base

        height: 
        of frustum

        alpha: 
        angle in radians between base and lateral surface 

        """
        this = _libBornAgainCore.new_FormFactorCone(radius, height, alpha)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorCone self) -> FormFactorCone

        FormFactorCone* FormFactorCone::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorCone_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorCone self, ISampleVisitor visitor)

        void FormFactorCone::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorCone_accept(self, visitor)


    def getHeight(self):
        """
        getHeight(FormFactorCone self) -> double

        double FormFactorCone::getHeight() const

        """
        return _libBornAgainCore.FormFactorCone_getHeight(self)


    def getAlpha(self):
        """
        getAlpha(FormFactorCone self) -> double

        double FormFactorCone::getAlpha() const

        """
        return _libBornAgainCore.FormFactorCone_getAlpha(self)


    def getRadius(self):
        """
        getRadius(FormFactorCone self) -> double

        double FormFactorCone::getRadius() const

        """
        return _libBornAgainCore.FormFactorCone_getRadius(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorCone self) -> double

        double FormFactorCone::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorCone_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorCone self, cvector_t q) -> complex_t

        complex_t FormFactorCone::evaluate_for_q(const cvector_t q) const override final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainCore.FormFactorCone_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorCone
    __del__ = lambda self: None
FormFactorCone_swigregister = _libBornAgainCore.FormFactorCone_swigregister
FormFactorCone_swigregister(FormFactorCone)

class FormFactorCone6(FormFactorPolyhedron):
    """


    A frustum (truncated pyramid) with regular hexagonal base.

    C++ includes: FormFactorCone6.h

    """

    __swig_setmethods__ = {}
    for _s in [FormFactorPolyhedron]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorCone6, name, value)
    __swig_getmethods__ = {}
    for _s in [FormFactorPolyhedron]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorCone6, name)
    __repr__ = _swig_repr

    def __init__(self, base_edge, height, alpha):
        """
        __init__(FormFactorCone6 self, double base_edge, double height, double alpha) -> FormFactorCone6

        FormFactorCone6::FormFactorCone6(double base_edge, double height, double alpha)

        Parameters:
        -----------

        base_edge: 
        of hexagonal base

        height: 
        of frustum

        alpha: 
        dihedral angle in radians between base and facet 

        """
        this = _libBornAgainCore.new_FormFactorCone6(base_edge, height, alpha)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorCone6 self) -> FormFactorCone6

        FormFactorCone6* FormFactorCone6::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorCone6_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorCone6 self, ISampleVisitor visitor)

        void FormFactorCone6::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorCone6_accept(self, visitor)


    def getBaseEdge(self):
        """
        getBaseEdge(FormFactorCone6 self) -> double

        double FormFactorCone6::getBaseEdge() const

        """
        return _libBornAgainCore.FormFactorCone6_getBaseEdge(self)


    def getHeight(self):
        """
        getHeight(FormFactorCone6 self) -> double

        double FormFactorCone6::getHeight() const

        """
        return _libBornAgainCore.FormFactorCone6_getHeight(self)


    def getAlpha(self):
        """
        getAlpha(FormFactorCone6 self) -> double

        double FormFactorCone6::getAlpha() const

        """
        return _libBornAgainCore.FormFactorCone6_getAlpha(self)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorCone6
    __del__ = lambda self: None
FormFactorCone6_swigregister = _libBornAgainCore.FormFactorCone6_swigregister
FormFactorCone6_swigregister(FormFactorCone6)

class FormFactorCrystal(IFormFactor):
    """


    The formfactor of a  MesoCrystal.

    C++ includes: FormFactorCrystal.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactor]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorCrystal, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactor]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorCrystal, name)
    __repr__ = _swig_repr

    def __init__(self, lattice, basis_form_factor, meso_form_factor):
        """
        __init__(FormFactorCrystal self, Lattice lattice, IFormFactor basis_form_factor, IFormFactor meso_form_factor) -> FormFactorCrystal

        FormFactorCrystal::FormFactorCrystal(const Lattice &lattice, const IFormFactor &basis_form_factor, const IFormFactor &meso_form_factor)

        """
        this = _libBornAgainCore.new_FormFactorCrystal(lattice, basis_form_factor, meso_form_factor)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_FormFactorCrystal
    __del__ = lambda self: None

    def clone(self):
        """
        clone(FormFactorCrystal self) -> FormFactorCrystal

        FormFactorCrystal* FormFactorCrystal::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorCrystal_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorCrystal self, ISampleVisitor visitor)

        void FormFactorCrystal::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorCrystal_accept(self, visitor)


    def getVolume(self):
        """
        getVolume(FormFactorCrystal self) -> double

        double FormFactorCrystal::getVolume() const override final

        Returns the total volume of the particle of this form factor's shape. 

        """
        return _libBornAgainCore.FormFactorCrystal_getVolume(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorCrystal self) -> double

        double FormFactorCrystal::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorCrystal_getRadialExtension(self)


    def evaluate(self, wavevectors):
        """
        evaluate(FormFactorCrystal self, WavevectorInfo wavevectors) -> complex_t

        complex_t FormFactorCrystal::evaluate(const WavevectorInfo &wavevectors) const override final

        Returns scattering amplitude for complex wavevectors ki, kf. 

        """
        return _libBornAgainCore.FormFactorCrystal_evaluate(self, wavevectors)

FormFactorCrystal_swigregister = _libBornAgainCore.FormFactorCrystal_swigregister
FormFactorCrystal_swigregister(FormFactorCrystal)

class FormFactorCuboctahedron(FormFactorPolyhedron):
    """


    A truncated bifrustum with quadratic base.

    C++ includes: FormFactorCuboctahedron.h

    """

    __swig_setmethods__ = {}
    for _s in [FormFactorPolyhedron]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorCuboctahedron, name, value)
    __swig_getmethods__ = {}
    for _s in [FormFactorPolyhedron]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorCuboctahedron, name)
    __repr__ = _swig_repr

    def __init__(self, length, height, height_ratio, alpha):
        """
        __init__(FormFactorCuboctahedron self, double length, double height, double height_ratio, double alpha) -> FormFactorCuboctahedron

        FormFactorCuboctahedron::FormFactorCuboctahedron(double length, double height, double height_ratio, double alpha)

        Parameters:
        -----------

        length: 
        of one side of the square base

        height: 
        of bottom frustum

        height_ratio: 
        ratio of heights of top to bottom frustum

        alpha: 
        dihedral angle in radians between base and facet 

        """
        this = _libBornAgainCore.new_FormFactorCuboctahedron(length, height, height_ratio, alpha)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorCuboctahedron self) -> FormFactorCuboctahedron

        FormFactorCuboctahedron* FormFactorCuboctahedron::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorCuboctahedron_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorCuboctahedron self, ISampleVisitor visitor)

        void FormFactorCuboctahedron::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorCuboctahedron_accept(self, visitor)


    def getLength(self):
        """
        getLength(FormFactorCuboctahedron self) -> double

        double FormFactorCuboctahedron::getLength() const

        """
        return _libBornAgainCore.FormFactorCuboctahedron_getLength(self)


    def getHeight(self):
        """
        getHeight(FormFactorCuboctahedron self) -> double

        double FormFactorCuboctahedron::getHeight() const

        """
        return _libBornAgainCore.FormFactorCuboctahedron_getHeight(self)


    def getHeightRatio(self):
        """
        getHeightRatio(FormFactorCuboctahedron self) -> double

        double FormFactorCuboctahedron::getHeightRatio() const

        """
        return _libBornAgainCore.FormFactorCuboctahedron_getHeightRatio(self)


    def getAlpha(self):
        """
        getAlpha(FormFactorCuboctahedron self) -> double

        double FormFactorCuboctahedron::getAlpha() const

        """
        return _libBornAgainCore.FormFactorCuboctahedron_getAlpha(self)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorCuboctahedron
    __del__ = lambda self: None
FormFactorCuboctahedron_swigregister = _libBornAgainCore.FormFactorCuboctahedron_swigregister
FormFactorCuboctahedron_swigregister(FormFactorCuboctahedron)

class FormFactorCylinder(IFormFactorBorn):
    """


    A circular cylinder.

    C++ includes: FormFactorCylinder.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorCylinder, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorCylinder, name)
    __repr__ = _swig_repr

    def __init__(self, radius, height):
        """
        __init__(FormFactorCylinder self, double radius, double height) -> FormFactorCylinder

        FormFactorCylinder::FormFactorCylinder(double radius, double height)

        """
        this = _libBornAgainCore.new_FormFactorCylinder(radius, height)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorCylinder self) -> FormFactorCylinder

        FormFactorCylinder* FormFactorCylinder::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorCylinder_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorCylinder self, ISampleVisitor visitor)

        void FormFactorCylinder::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorCylinder_accept(self, visitor)


    def getHeight(self):
        """
        getHeight(FormFactorCylinder self) -> double

        double FormFactorCylinder::getHeight() const

        """
        return _libBornAgainCore.FormFactorCylinder_getHeight(self)


    def getRadius(self):
        """
        getRadius(FormFactorCylinder self) -> double

        double FormFactorCylinder::getRadius() const

        """
        return _libBornAgainCore.FormFactorCylinder_getRadius(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorCylinder self) -> double

        double FormFactorCylinder::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorCylinder_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorCylinder self, cvector_t q) -> complex_t

        complex_t FormFactorCylinder::evaluate_for_q(const cvector_t q) const override final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainCore.FormFactorCylinder_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorCylinder
    __del__ = lambda self: None
FormFactorCylinder_swigregister = _libBornAgainCore.FormFactorCylinder_swigregister
FormFactorCylinder_swigregister(FormFactorCylinder)

class FormFactorDecoratorDebyeWaller(IFormFactorDecorator):
    """


    Debye-Waller factors in radial and z directions.

    C++ includes: FormFactorDecoratorDebyeWaller.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorDecorator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorDecoratorDebyeWaller, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorDecorator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorDecoratorDebyeWaller, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FormFactorDecoratorDebyeWaller self, IFormFactor form_factor, double dw_h_factor, double dw_r_factor) -> FormFactorDecoratorDebyeWaller
        __init__(FormFactorDecoratorDebyeWaller self, IFormFactor form_factor, double dw_factor) -> FormFactorDecoratorDebyeWaller

        FormFactorDecoratorDebyeWaller::FormFactorDecoratorDebyeWaller(const IFormFactor &form_factor, double dw_factor)

        Isotropic Debye-Waller factor. 

        """
        this = _libBornAgainCore.new_FormFactorDecoratorDebyeWaller(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorDecoratorDebyeWaller self) -> FormFactorDecoratorDebyeWaller

        FormFactorDecoratorDebyeWaller* FormFactorDecoratorDebyeWaller::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorDecoratorDebyeWaller_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorDecoratorDebyeWaller self, ISampleVisitor visitor)

        void FormFactorDecoratorDebyeWaller::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorDecoratorDebyeWaller_accept(self, visitor)


    def evaluate(self, wavevectors):
        """
        evaluate(FormFactorDecoratorDebyeWaller self, WavevectorInfo wavevectors) -> complex_t

        complex_t FormFactorDecoratorDebyeWaller::evaluate(const WavevectorInfo &wavevectors) const override final

        Returns scattering amplitude for complex wavevectors ki, kf. 

        """
        return _libBornAgainCore.FormFactorDecoratorDebyeWaller_evaluate(self, wavevectors)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorDecoratorDebyeWaller
    __del__ = lambda self: None
FormFactorDecoratorDebyeWaller_swigregister = _libBornAgainCore.FormFactorDecoratorDebyeWaller_swigregister
FormFactorDecoratorDebyeWaller_swigregister(FormFactorDecoratorDebyeWaller)

class FormFactorDodecahedron(FormFactorPolyhedron):
    """


    A regular dodecahedron.

    C++ includes: FormFactorDodecahedron.h

    """

    __swig_setmethods__ = {}
    for _s in [FormFactorPolyhedron]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorDodecahedron, name, value)
    __swig_getmethods__ = {}
    for _s in [FormFactorPolyhedron]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorDodecahedron, name)
    __repr__ = _swig_repr

    def __init__(self, edge):
        """
        __init__(FormFactorDodecahedron self, double edge) -> FormFactorDodecahedron

        FormFactorDodecahedron::FormFactorDodecahedron(double edge)

        Constructs a regular dodecahedron.

        Parameters:
        -----------

        edge: 
        length 

        """
        this = _libBornAgainCore.new_FormFactorDodecahedron(edge)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorDodecahedron self) -> FormFactorDodecahedron

        FormFactorDodecahedron* FormFactorDodecahedron::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorDodecahedron_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorDodecahedron self, ISampleVisitor visitor)

        void FormFactorDodecahedron::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorDodecahedron_accept(self, visitor)


    def getEdge(self):
        """
        getEdge(FormFactorDodecahedron self) -> double

        double FormFactorDodecahedron::getEdge() const

        """
        return _libBornAgainCore.FormFactorDodecahedron_getEdge(self)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorDodecahedron
    __del__ = lambda self: None
FormFactorDodecahedron_swigregister = _libBornAgainCore.FormFactorDodecahedron_swigregister
FormFactorDodecahedron_swigregister(FormFactorDodecahedron)

class FormFactorEllipsoidalCylinder(IFormFactorBorn):
    """


    A cylinder with elliptical base.

    C++ includes: FormFactorEllipsoidalCylinder.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorEllipsoidalCylinder, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorEllipsoidalCylinder, name)
    __repr__ = _swig_repr

    def __init__(self, radius_x, radius_y, height):
        """
        __init__(FormFactorEllipsoidalCylinder self, double radius_x, double radius_y, double height) -> FormFactorEllipsoidalCylinder

        FormFactorEllipsoidalCylinder::FormFactorEllipsoidalCylinder(double radius_x, double radius_y, double height)

        Parameters:
        -----------

        radius_x: 
        half length of one horizontal main axes

        radius_y: 
        half length of the other horizontal main axes

        height: 

        """
        this = _libBornAgainCore.new_FormFactorEllipsoidalCylinder(radius_x, radius_y, height)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorEllipsoidalCylinder self) -> FormFactorEllipsoidalCylinder

        FormFactorEllipsoidalCylinder* FormFactorEllipsoidalCylinder::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorEllipsoidalCylinder_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorEllipsoidalCylinder self, ISampleVisitor visitor)

        void FormFactorEllipsoidalCylinder::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorEllipsoidalCylinder_accept(self, visitor)


    def getRadiusX(self):
        """
        getRadiusX(FormFactorEllipsoidalCylinder self) -> double

        double FormFactorEllipsoidalCylinder::getRadiusX() const

        """
        return _libBornAgainCore.FormFactorEllipsoidalCylinder_getRadiusX(self)


    def getRadiusY(self):
        """
        getRadiusY(FormFactorEllipsoidalCylinder self) -> double

        double FormFactorEllipsoidalCylinder::getRadiusY() const

        """
        return _libBornAgainCore.FormFactorEllipsoidalCylinder_getRadiusY(self)


    def getHeight(self):
        """
        getHeight(FormFactorEllipsoidalCylinder self) -> double

        double FormFactorEllipsoidalCylinder::getHeight() const

        """
        return _libBornAgainCore.FormFactorEllipsoidalCylinder_getHeight(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorEllipsoidalCylinder self) -> double

        double FormFactorEllipsoidalCylinder::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorEllipsoidalCylinder_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorEllipsoidalCylinder self, cvector_t q) -> complex_t

        complex_t FormFactorEllipsoidalCylinder::evaluate_for_q(const cvector_t q) const override final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainCore.FormFactorEllipsoidalCylinder_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorEllipsoidalCylinder
    __del__ = lambda self: None
FormFactorEllipsoidalCylinder_swigregister = _libBornAgainCore.FormFactorEllipsoidalCylinder_swigregister
FormFactorEllipsoidalCylinder_swigregister(FormFactorEllipsoidalCylinder)

class FormFactorFullSphere(IFormFactorBorn):
    """


    A full sphere.

    C++ includes: FormFactorFullSphere.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorFullSphere, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorFullSphere, name)
    __repr__ = _swig_repr

    def __init__(self, radius):
        """
        __init__(FormFactorFullSphere self, double radius) -> FormFactorFullSphere

        FormFactorFullSphere::FormFactorFullSphere(double radius)

        """
        this = _libBornAgainCore.new_FormFactorFullSphere(radius)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorFullSphere self) -> FormFactorFullSphere

        FormFactorFullSphere* FormFactorFullSphere::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorFullSphere_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorFullSphere self, ISampleVisitor visitor)

        void FormFactorFullSphere::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorFullSphere_accept(self, visitor)


    def getRadius(self):
        """
        getRadius(FormFactorFullSphere self) -> double

        double FormFactorFullSphere::getRadius() const

        """
        return _libBornAgainCore.FormFactorFullSphere_getRadius(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorFullSphere self) -> double

        double FormFactorFullSphere::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorFullSphere_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorFullSphere self, cvector_t q) -> complex_t

        complex_t FormFactorFullSphere::evaluate_for_q(const cvector_t q) const override final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainCore.FormFactorFullSphere_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorFullSphere
    __del__ = lambda self: None
FormFactorFullSphere_swigregister = _libBornAgainCore.FormFactorFullSphere_swigregister
FormFactorFullSphere_swigregister(FormFactorFullSphere)

class FormFactorFullSpheroid(IFormFactorBorn):
    """


    A full spheroid (an ellipsoid with two equal axes, hence with circular cross section)

    C++ includes: FormFactorFullSpheroid.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorFullSpheroid, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorFullSpheroid, name)
    __repr__ = _swig_repr

    def __init__(self, radius, height):
        """
        __init__(FormFactorFullSpheroid self, double radius, double height) -> FormFactorFullSpheroid

        FormFactorFullSpheroid::FormFactorFullSpheroid(double radius, double height)

        Parameters:
        -----------

        radius: 
        of the two equal axes

        height: 
        total height of the spheroid, i.e. twice the radius of the third axis 

        """
        this = _libBornAgainCore.new_FormFactorFullSpheroid(radius, height)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorFullSpheroid self) -> FormFactorFullSpheroid

        FormFactorFullSpheroid* FormFactorFullSpheroid::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorFullSpheroid_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorFullSpheroid self, ISampleVisitor visitor)

        void FormFactorFullSpheroid::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorFullSpheroid_accept(self, visitor)


    def getHeight(self):
        """
        getHeight(FormFactorFullSpheroid self) -> double

        double FormFactorFullSpheroid::getHeight() const

        """
        return _libBornAgainCore.FormFactorFullSpheroid_getHeight(self)


    def getRadius(self):
        """
        getRadius(FormFactorFullSpheroid self) -> double

        double FormFactorFullSpheroid::getRadius() const

        """
        return _libBornAgainCore.FormFactorFullSpheroid_getRadius(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorFullSpheroid self) -> double

        double FormFactorFullSpheroid::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorFullSpheroid_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorFullSpheroid self, cvector_t q) -> complex_t

        complex_t FormFactorFullSpheroid::evaluate_for_q(const cvector_t q) const override final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainCore.FormFactorFullSpheroid_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorFullSpheroid
    __del__ = lambda self: None
FormFactorFullSpheroid_swigregister = _libBornAgainCore.FormFactorFullSpheroid_swigregister
FormFactorFullSpheroid_swigregister(FormFactorFullSpheroid)

class FormFactorGauss(IFormFactorBorn):
    """


    The formfactor of a gaussian.

    C++ includes: FormFactorGauss.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorGauss, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorGauss, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FormFactorGauss self, double length) -> FormFactorGauss
        __init__(FormFactorGauss self, double width, double height) -> FormFactorGauss

        FormFactorGauss::FormFactorGauss(double width, double height)

        """
        this = _libBornAgainCore.new_FormFactorGauss(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorGauss self) -> FormFactorGauss

        FormFactorGauss* FormFactorGauss::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorGauss_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorGauss self, ISampleVisitor visitor)

        void FormFactorGauss::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorGauss_accept(self, visitor)


    def getWidth(self):
        """
        getWidth(FormFactorGauss self) -> double

        double FormFactorGauss::getWidth() const

        """
        return _libBornAgainCore.FormFactorGauss_getWidth(self)


    def getHeight(self):
        """
        getHeight(FormFactorGauss self) -> double

        double FormFactorGauss::getHeight() const

        """
        return _libBornAgainCore.FormFactorGauss_getHeight(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorGauss self) -> double

        double FormFactorGauss::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorGauss_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorGauss self, cvector_t q) -> complex_t

        complex_t FormFactorGauss::evaluate_for_q(const cvector_t q) const override final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainCore.FormFactorGauss_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorGauss
    __del__ = lambda self: None
FormFactorGauss_swigregister = _libBornAgainCore.FormFactorGauss_swigregister
FormFactorGauss_swigregister(FormFactorGauss)

class FormFactorHemiEllipsoid(IFormFactorBorn):
    """


    An hemi ellipsoid, obtained by truncating a full ellipsoid in the middle plane spanned by two principal axes.

    C++ includes: FormFactorHemiEllipsoid.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorHemiEllipsoid, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorHemiEllipsoid, name)
    __repr__ = _swig_repr

    def __init__(self, radius_x, radius_y, height):
        """
        __init__(FormFactorHemiEllipsoid self, double radius_x, double radius_y, double height) -> FormFactorHemiEllipsoid

        FormFactorHemiEllipsoid::FormFactorHemiEllipsoid(double radius_x, double radius_y, double height)

        Parameters:
        -----------

        radius_x: 
        half length of one horizontal main axes

        radius_y: 
        half length of the other horizontal main axes

        height: 
        of the hemi ellipsoid 

        """
        this = _libBornAgainCore.new_FormFactorHemiEllipsoid(radius_x, radius_y, height)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_FormFactorHemiEllipsoid
    __del__ = lambda self: None

    def clone(self):
        """
        clone(FormFactorHemiEllipsoid self) -> FormFactorHemiEllipsoid

        FormFactorHemiEllipsoid* FormFactorHemiEllipsoid::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorHemiEllipsoid_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorHemiEllipsoid self, ISampleVisitor visitor)

        void FormFactorHemiEllipsoid::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorHemiEllipsoid_accept(self, visitor)


    def getHeight(self):
        """
        getHeight(FormFactorHemiEllipsoid self) -> double

        double FormFactorHemiEllipsoid::getHeight() const

        """
        return _libBornAgainCore.FormFactorHemiEllipsoid_getHeight(self)


    def getRadiusX(self):
        """
        getRadiusX(FormFactorHemiEllipsoid self) -> double

        double FormFactorHemiEllipsoid::getRadiusX() const

        """
        return _libBornAgainCore.FormFactorHemiEllipsoid_getRadiusX(self)


    def getRadiusY(self):
        """
        getRadiusY(FormFactorHemiEllipsoid self) -> double

        double FormFactorHemiEllipsoid::getRadiusY() const

        """
        return _libBornAgainCore.FormFactorHemiEllipsoid_getRadiusY(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorHemiEllipsoid self) -> double

        double FormFactorHemiEllipsoid::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorHemiEllipsoid_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorHemiEllipsoid self, cvector_t q) -> complex_t

        complex_t FormFactorHemiEllipsoid::evaluate_for_q(const cvector_t q) const override final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainCore.FormFactorHemiEllipsoid_evaluate_for_q(self, q)

FormFactorHemiEllipsoid_swigregister = _libBornAgainCore.FormFactorHemiEllipsoid_swigregister
FormFactorHemiEllipsoid_swigregister(FormFactorHemiEllipsoid)

class FormFactorIcosahedron(FormFactorPolyhedron):
    """


    A regular icosahedron.

    C++ includes: FormFactorIcosahedron.h

    """

    __swig_setmethods__ = {}
    for _s in [FormFactorPolyhedron]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorIcosahedron, name, value)
    __swig_getmethods__ = {}
    for _s in [FormFactorPolyhedron]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorIcosahedron, name)
    __repr__ = _swig_repr

    def __init__(self, edge):
        """
        __init__(FormFactorIcosahedron self, double edge) -> FormFactorIcosahedron

        FormFactorIcosahedron::FormFactorIcosahedron(double edge)

        """
        this = _libBornAgainCore.new_FormFactorIcosahedron(edge)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorIcosahedron self) -> FormFactorIcosahedron

        FormFactorIcosahedron* FormFactorIcosahedron::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorIcosahedron_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorIcosahedron self, ISampleVisitor visitor)

        void FormFactorIcosahedron::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorIcosahedron_accept(self, visitor)


    def getEdge(self):
        """
        getEdge(FormFactorIcosahedron self) -> double

        double FormFactorIcosahedron::getEdge() const

        """
        return _libBornAgainCore.FormFactorIcosahedron_getEdge(self)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorIcosahedron
    __del__ = lambda self: None
FormFactorIcosahedron_swigregister = _libBornAgainCore.FormFactorIcosahedron_swigregister
FormFactorIcosahedron_swigregister(FormFactorIcosahedron)

class FormFactorLongBoxGauss(IFormFactorBorn):
    """


    The formfactor for a long rectangular box.

    C++ includes: FormFactorLongBoxGauss.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorLongBoxGauss, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorLongBoxGauss, name)
    __repr__ = _swig_repr

    def __init__(self, length, width, height):
        """
        __init__(FormFactorLongBoxGauss self, double length, double width, double height) -> FormFactorLongBoxGauss

        FormFactorLongBoxGauss::FormFactorLongBoxGauss(double length, double width, double height)

        Box constructor.

        Parameters:
        -----------

        length: 
        of Box's base

        width: 
        of Box's base

        height: 
        of Box 

        """
        this = _libBornAgainCore.new_FormFactorLongBoxGauss(length, width, height)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorLongBoxGauss self) -> FormFactorLongBoxGauss

        FormFactorLongBoxGauss* FormFactorLongBoxGauss::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorLongBoxGauss_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorLongBoxGauss self, ISampleVisitor visitor)

        void FormFactorLongBoxGauss::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorLongBoxGauss_accept(self, visitor)


    def getLength(self):
        """
        getLength(FormFactorLongBoxGauss self) -> double

        double FormFactorLongBoxGauss::getLength() const

        """
        return _libBornAgainCore.FormFactorLongBoxGauss_getLength(self)


    def getHeight(self):
        """
        getHeight(FormFactorLongBoxGauss self) -> double

        double FormFactorLongBoxGauss::getHeight() const

        """
        return _libBornAgainCore.FormFactorLongBoxGauss_getHeight(self)


    def getWidth(self):
        """
        getWidth(FormFactorLongBoxGauss self) -> double

        double FormFactorLongBoxGauss::getWidth() const

        """
        return _libBornAgainCore.FormFactorLongBoxGauss_getWidth(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorLongBoxGauss self) -> double

        double FormFactorLongBoxGauss::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorLongBoxGauss_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorLongBoxGauss self, cvector_t q) -> complex_t

        complex_t FormFactorLongBoxGauss::evaluate_for_q(const cvector_t q) const override final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainCore.FormFactorLongBoxGauss_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorLongBoxGauss
    __del__ = lambda self: None
FormFactorLongBoxGauss_swigregister = _libBornAgainCore.FormFactorLongBoxGauss_swigregister
FormFactorLongBoxGauss_swigregister(FormFactorLongBoxGauss)

class FormFactorLongBoxLorentz(IFormFactorBorn):
    """


    The formfactor for a long rectangular box.

    C++ includes: FormFactorLongBoxLorentz.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorLongBoxLorentz, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorLongBoxLorentz, name)
    __repr__ = _swig_repr

    def __init__(self, length, width, height):
        """
        __init__(FormFactorLongBoxLorentz self, double length, double width, double height) -> FormFactorLongBoxLorentz

        FormFactorLongBoxLorentz::FormFactorLongBoxLorentz(double length, double width, double height)

        Box constructor.

        Parameters:
        -----------

        length: 
        of Box's base

        width: 
        of Box's base

        height: 
        of Box 

        """
        this = _libBornAgainCore.new_FormFactorLongBoxLorentz(length, width, height)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorLongBoxLorentz self) -> FormFactorLongBoxLorentz

        FormFactorLongBoxLorentz* FormFactorLongBoxLorentz::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorLongBoxLorentz_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorLongBoxLorentz self, ISampleVisitor visitor)

        void FormFactorLongBoxLorentz::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorLongBoxLorentz_accept(self, visitor)


    def getLength(self):
        """
        getLength(FormFactorLongBoxLorentz self) -> double

        double FormFactorLongBoxLorentz::getLength() const

        """
        return _libBornAgainCore.FormFactorLongBoxLorentz_getLength(self)


    def getHeight(self):
        """
        getHeight(FormFactorLongBoxLorentz self) -> double

        double FormFactorLongBoxLorentz::getHeight() const

        """
        return _libBornAgainCore.FormFactorLongBoxLorentz_getHeight(self)


    def getWidth(self):
        """
        getWidth(FormFactorLongBoxLorentz self) -> double

        double FormFactorLongBoxLorentz::getWidth() const

        """
        return _libBornAgainCore.FormFactorLongBoxLorentz_getWidth(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorLongBoxLorentz self) -> double

        double FormFactorLongBoxLorentz::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorLongBoxLorentz_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorLongBoxLorentz self, cvector_t q) -> complex_t

        complex_t FormFactorLongBoxLorentz::evaluate_for_q(const cvector_t q) const override final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainCore.FormFactorLongBoxLorentz_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorLongBoxLorentz
    __del__ = lambda self: None
FormFactorLongBoxLorentz_swigregister = _libBornAgainCore.FormFactorLongBoxLorentz_swigregister
FormFactorLongBoxLorentz_swigregister(FormFactorLongBoxLorentz)

class FormFactorLongRipple1Gauss(IFormFactorBorn):
    """


    The formfactor for a cosine ripple.

    C++ includes: FormFactorLongRipple1Gauss.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorLongRipple1Gauss, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorLongRipple1Gauss, name)
    __repr__ = _swig_repr

    def __init__(self, length, width, height):
        """
        __init__(FormFactorLongRipple1Gauss self, double length, double width, double height) -> FormFactorLongRipple1Gauss

        FormFactorLongRipple1Gauss::FormFactorLongRipple1Gauss(double length, double width, double height)

        Ripple1 constructor.

        Parameters:
        -----------

        length: 
        of Ripple1

        width: 
        of cosine cross section

        height: 
        of cosine cross section 

        """
        this = _libBornAgainCore.new_FormFactorLongRipple1Gauss(length, width, height)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorLongRipple1Gauss self) -> FormFactorLongRipple1Gauss

        FormFactorLongRipple1Gauss* FormFactorLongRipple1Gauss::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorLongRipple1Gauss_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorLongRipple1Gauss self, ISampleVisitor visitor)

        void FormFactorLongRipple1Gauss::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorLongRipple1Gauss_accept(self, visitor)


    def getHeight(self):
        """
        getHeight(FormFactorLongRipple1Gauss self) -> double

        double FormFactorLongRipple1Gauss::getHeight() const

        """
        return _libBornAgainCore.FormFactorLongRipple1Gauss_getHeight(self)


    def getWidth(self):
        """
        getWidth(FormFactorLongRipple1Gauss self) -> double

        double FormFactorLongRipple1Gauss::getWidth() const

        """
        return _libBornAgainCore.FormFactorLongRipple1Gauss_getWidth(self)


    def getLength(self):
        """
        getLength(FormFactorLongRipple1Gauss self) -> double

        double FormFactorLongRipple1Gauss::getLength() const

        """
        return _libBornAgainCore.FormFactorLongRipple1Gauss_getLength(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorLongRipple1Gauss self) -> double

        double FormFactorLongRipple1Gauss::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorLongRipple1Gauss_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorLongRipple1Gauss self, cvector_t q) -> complex_t

        complex_t FormFactorLongRipple1Gauss::evaluate_for_q(const cvector_t q) const override final

        Complex formfactor. 

        """
        return _libBornAgainCore.FormFactorLongRipple1Gauss_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorLongRipple1Gauss
    __del__ = lambda self: None
FormFactorLongRipple1Gauss_swigregister = _libBornAgainCore.FormFactorLongRipple1Gauss_swigregister
FormFactorLongRipple1Gauss_swigregister(FormFactorLongRipple1Gauss)

class FormFactorLongRipple1Lorentz(IFormFactorBorn):
    """


    The formfactor for a cosine ripple.

    C++ includes: FormFactorLongRipple1Lorentz.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorLongRipple1Lorentz, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorLongRipple1Lorentz, name)
    __repr__ = _swig_repr

    def __init__(self, length, width, height):
        """
        __init__(FormFactorLongRipple1Lorentz self, double length, double width, double height) -> FormFactorLongRipple1Lorentz

        FormFactorLongRipple1Lorentz::FormFactorLongRipple1Lorentz(double length, double width, double height)

        FormFactorLongRipple1Lorentz constructor.

        Parameters:
        -----------

        length: 
        of Ripple1

        width: 
        of cosine cross section

        height: 
        of cosine cross section 

        """
        this = _libBornAgainCore.new_FormFactorLongRipple1Lorentz(length, width, height)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorLongRipple1Lorentz self) -> FormFactorLongRipple1Lorentz

        FormFactorLongRipple1Lorentz* FormFactorLongRipple1Lorentz::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorLongRipple1Lorentz_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorLongRipple1Lorentz self, ISampleVisitor visitor)

        void FormFactorLongRipple1Lorentz::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorLongRipple1Lorentz_accept(self, visitor)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorLongRipple1Lorentz self) -> double

        double FormFactorLongRipple1Lorentz::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorLongRipple1Lorentz_getRadialExtension(self)


    def getHeight(self):
        """
        getHeight(FormFactorLongRipple1Lorentz self) -> double

        double FormFactorLongRipple1Lorentz::getHeight() const

        """
        return _libBornAgainCore.FormFactorLongRipple1Lorentz_getHeight(self)


    def getWidth(self):
        """
        getWidth(FormFactorLongRipple1Lorentz self) -> double

        double FormFactorLongRipple1Lorentz::getWidth() const

        """
        return _libBornAgainCore.FormFactorLongRipple1Lorentz_getWidth(self)


    def getLength(self):
        """
        getLength(FormFactorLongRipple1Lorentz self) -> double

        double FormFactorLongRipple1Lorentz::getLength() const

        """
        return _libBornAgainCore.FormFactorLongRipple1Lorentz_getLength(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorLongRipple1Lorentz self, cvector_t q) -> complex_t

        complex_t FormFactorLongRipple1Lorentz::evaluate_for_q(const cvector_t q) const override final

        Complex formfactor. 

        """
        return _libBornAgainCore.FormFactorLongRipple1Lorentz_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorLongRipple1Lorentz
    __del__ = lambda self: None
FormFactorLongRipple1Lorentz_swigregister = _libBornAgainCore.FormFactorLongRipple1Lorentz_swigregister
FormFactorLongRipple1Lorentz_swigregister(FormFactorLongRipple1Lorentz)

class FormFactorLongRipple2Gauss(IFormFactorBorn):
    """


    The formfactor for a triangular ripple.

    C++ includes: FormFactorLongRipple2Gauss.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorLongRipple2Gauss, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorLongRipple2Gauss, name)
    __repr__ = _swig_repr

    def __init__(self, length, width, height, asymmetry):
        """
        __init__(FormFactorLongRipple2Gauss self, double length, double width, double height, double asymmetry) -> FormFactorLongRipple2Gauss

        FormFactorLongRipple2Gauss::FormFactorLongRipple2Gauss(double length, double width, double height, double asymmetry)

        FormFactorLongRipple2Gauss constructor.

        Parameters:
        -----------

        length: 
        of Ripple2

        width: 
        of triangular cross section

        height: 
        of triangular cross section

        asymmetry: 
        length of triangular cross section 

        """
        this = _libBornAgainCore.new_FormFactorLongRipple2Gauss(length, width, height, asymmetry)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorLongRipple2Gauss self) -> FormFactorLongRipple2Gauss

        FormFactorLongRipple2Gauss* FormFactorLongRipple2Gauss::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorLongRipple2Gauss_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorLongRipple2Gauss self, ISampleVisitor visitor)

        void FormFactorLongRipple2Gauss::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorLongRipple2Gauss_accept(self, visitor)


    def getHeight(self):
        """
        getHeight(FormFactorLongRipple2Gauss self) -> double

        double FormFactorLongRipple2Gauss::getHeight() const

        """
        return _libBornAgainCore.FormFactorLongRipple2Gauss_getHeight(self)


    def getWidth(self):
        """
        getWidth(FormFactorLongRipple2Gauss self) -> double

        double FormFactorLongRipple2Gauss::getWidth() const

        """
        return _libBornAgainCore.FormFactorLongRipple2Gauss_getWidth(self)


    def getLength(self):
        """
        getLength(FormFactorLongRipple2Gauss self) -> double

        double FormFactorLongRipple2Gauss::getLength() const

        """
        return _libBornAgainCore.FormFactorLongRipple2Gauss_getLength(self)


    def getAsymmetry(self):
        """
        getAsymmetry(FormFactorLongRipple2Gauss self) -> double

        double FormFactorLongRipple2Gauss::getAsymmetry() const

        """
        return _libBornAgainCore.FormFactorLongRipple2Gauss_getAsymmetry(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorLongRipple2Gauss self) -> double

        double FormFactorLongRipple2Gauss::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorLongRipple2Gauss_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorLongRipple2Gauss self, cvector_t q) -> complex_t

        complex_t FormFactorLongRipple2Gauss::evaluate_for_q(const cvector_t q) const override final

        Complex formfactor. 

        """
        return _libBornAgainCore.FormFactorLongRipple2Gauss_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorLongRipple2Gauss
    __del__ = lambda self: None
FormFactorLongRipple2Gauss_swigregister = _libBornAgainCore.FormFactorLongRipple2Gauss_swigregister
FormFactorLongRipple2Gauss_swigregister(FormFactorLongRipple2Gauss)

class FormFactorLongRipple2Lorentz(IFormFactorBorn):
    """


    The formfactor for a triangular ripple.

    C++ includes: FormFactorLongRipple2Lorentz.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorLongRipple2Lorentz, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorLongRipple2Lorentz, name)
    __repr__ = _swig_repr

    def __init__(self, length, width, height, asymmetry):
        """
        __init__(FormFactorLongRipple2Lorentz self, double length, double width, double height, double asymmetry) -> FormFactorLongRipple2Lorentz

        FormFactorLongRipple2Lorentz::FormFactorLongRipple2Lorentz(double length, double width, double height, double asymmetry)

        Parameters:
        -----------

        length: 
        of Ripple2

        width: 
        of triangular cross section

        height: 
        of triangular cross section

        asymmetry: 
        length of triangular cross section 

        """
        this = _libBornAgainCore.new_FormFactorLongRipple2Lorentz(length, width, height, asymmetry)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorLongRipple2Lorentz self) -> FormFactorLongRipple2Lorentz

        FormFactorLongRipple2Lorentz* FormFactorLongRipple2Lorentz::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorLongRipple2Lorentz_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorLongRipple2Lorentz self, ISampleVisitor visitor)

        void FormFactorLongRipple2Lorentz::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorLongRipple2Lorentz_accept(self, visitor)


    def getHeight(self):
        """
        getHeight(FormFactorLongRipple2Lorentz self) -> double

        double FormFactorLongRipple2Lorentz::getHeight() const

        """
        return _libBornAgainCore.FormFactorLongRipple2Lorentz_getHeight(self)


    def getWidth(self):
        """
        getWidth(FormFactorLongRipple2Lorentz self) -> double

        double FormFactorLongRipple2Lorentz::getWidth() const

        """
        return _libBornAgainCore.FormFactorLongRipple2Lorentz_getWidth(self)


    def getLength(self):
        """
        getLength(FormFactorLongRipple2Lorentz self) -> double

        double FormFactorLongRipple2Lorentz::getLength() const

        """
        return _libBornAgainCore.FormFactorLongRipple2Lorentz_getLength(self)


    def getAsymmetry(self):
        """
        getAsymmetry(FormFactorLongRipple2Lorentz self) -> double

        double FormFactorLongRipple2Lorentz::getAsymmetry() const

        """
        return _libBornAgainCore.FormFactorLongRipple2Lorentz_getAsymmetry(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorLongRipple2Lorentz self) -> double

        double FormFactorLongRipple2Lorentz::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorLongRipple2Lorentz_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorLongRipple2Lorentz self, cvector_t q) -> complex_t

        complex_t FormFactorLongRipple2Lorentz::evaluate_for_q(const cvector_t q) const override final

        Complex formfactor. 

        """
        return _libBornAgainCore.FormFactorLongRipple2Lorentz_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorLongRipple2Lorentz
    __del__ = lambda self: None
FormFactorLongRipple2Lorentz_swigregister = _libBornAgainCore.FormFactorLongRipple2Lorentz_swigregister
FormFactorLongRipple2Lorentz_swigregister(FormFactorLongRipple2Lorentz)

class FormFactorLorentz(IFormFactorBorn):
    """


    The formfactor of a lorentzian.

    C++ includes: FormFactorLorentz.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorLorentz, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorLorentz, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FormFactorLorentz self, double length) -> FormFactorLorentz
        __init__(FormFactorLorentz self, double width, double height) -> FormFactorLorentz

        FormFactorLorentz::FormFactorLorentz(double width, double height)

        """
        this = _libBornAgainCore.new_FormFactorLorentz(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorLorentz self) -> FormFactorLorentz

        FormFactorLorentz* FormFactorLorentz::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorLorentz_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorLorentz self, ISampleVisitor visitor)

        void FormFactorLorentz::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorLorentz_accept(self, visitor)


    def getWidth(self):
        """
        getWidth(FormFactorLorentz self) -> double

        double FormFactorLorentz::getWidth() const

        """
        return _libBornAgainCore.FormFactorLorentz_getWidth(self)


    def getHeight(self):
        """
        getHeight(FormFactorLorentz self) -> double

        double FormFactorLorentz::getHeight() const

        """
        return _libBornAgainCore.FormFactorLorentz_getHeight(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorLorentz self) -> double

        double FormFactorLorentz::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorLorentz_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorLorentz self, cvector_t q) -> complex_t

        complex_t FormFactorLorentz::evaluate_for_q(const cvector_t q) const override final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainCore.FormFactorLorentz_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorLorentz
    __del__ = lambda self: None
FormFactorLorentz_swigregister = _libBornAgainCore.FormFactorLorentz_swigregister
FormFactorLorentz_swigregister(FormFactorLorentz)

class FormFactorPrism3(FormFactorPolygonalPrism):
    """


    A prism based on an equilateral triangle.

    C++ includes: FormFactorPrism3.h

    """

    __swig_setmethods__ = {}
    for _s in [FormFactorPolygonalPrism]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorPrism3, name, value)
    __swig_getmethods__ = {}
    for _s in [FormFactorPolygonalPrism]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorPrism3, name)
    __repr__ = _swig_repr

    def __init__(self, base_edge, height):
        """
        __init__(FormFactorPrism3 self, double const base_edge, double const height) -> FormFactorPrism3

        FormFactorPrism3::FormFactorPrism3(const double base_edge, const double height)

        """
        this = _libBornAgainCore.new_FormFactorPrism3(base_edge, height)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorPrism3 self) -> FormFactorPrism3

        FormFactorPrism3* FormFactorPrism3::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorPrism3_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorPrism3 self, ISampleVisitor visitor)

        void FormFactorPrism3::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorPrism3_accept(self, visitor)


    def getBaseEdge(self):
        """
        getBaseEdge(FormFactorPrism3 self) -> double

        double FormFactorPrism3::getBaseEdge() const

        """
        return _libBornAgainCore.FormFactorPrism3_getBaseEdge(self)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorPrism3
    __del__ = lambda self: None
FormFactorPrism3_swigregister = _libBornAgainCore.FormFactorPrism3_swigregister
FormFactorPrism3_swigregister(FormFactorPrism3)

class FormFactorPrism6(FormFactorPolygonalPrism):
    """


    A prism based on a regular hexagonal.

    C++ includes: FormFactorPrism6.h

    """

    __swig_setmethods__ = {}
    for _s in [FormFactorPolygonalPrism]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorPrism6, name, value)
    __swig_getmethods__ = {}
    for _s in [FormFactorPolygonalPrism]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorPrism6, name)
    __repr__ = _swig_repr

    def __init__(self, base_edge, height):
        """
        __init__(FormFactorPrism6 self, double const base_edge, double const height) -> FormFactorPrism6

        FormFactorPrism6::FormFactorPrism6(const double base_edge, const double height)

        """
        this = _libBornAgainCore.new_FormFactorPrism6(base_edge, height)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorPrism6 self) -> FormFactorPrism6

        FormFactorPrism6* FormFactorPrism6::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorPrism6_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorPrism6 self, ISampleVisitor visitor)

        void FormFactorPrism6::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorPrism6_accept(self, visitor)


    def getBaseEdge(self):
        """
        getBaseEdge(FormFactorPrism6 self) -> double

        double FormFactorPrism6::getBaseEdge() const

        """
        return _libBornAgainCore.FormFactorPrism6_getBaseEdge(self)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorPrism6
    __del__ = lambda self: None
FormFactorPrism6_swigregister = _libBornAgainCore.FormFactorPrism6_swigregister
FormFactorPrism6_swigregister(FormFactorPrism6)

class FormFactorPyramid(FormFactorPolyhedron):
    """


    A frustum with a quadratic base.

    C++ includes: FormFactorPyramid.h

    """

    __swig_setmethods__ = {}
    for _s in [FormFactorPolyhedron]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorPyramid, name, value)
    __swig_getmethods__ = {}
    for _s in [FormFactorPolyhedron]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorPyramid, name)
    __repr__ = _swig_repr

    def __init__(self, base_edge, height, alpha):
        """
        __init__(FormFactorPyramid self, double base_edge, double height, double alpha) -> FormFactorPyramid

        FormFactorPyramid::FormFactorPyramid(double base_edge, double height, double alpha)

        Parameters:
        -----------

        base_edge: 
        of one side of the square base

        height: 
        of the frustum

        alpha: 
        dihedral angle in radians between base and facet 

        """
        this = _libBornAgainCore.new_FormFactorPyramid(base_edge, height, alpha)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorPyramid self) -> FormFactorPyramid

        FormFactorPyramid* FormFactorPyramid::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorPyramid_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorPyramid self, ISampleVisitor visitor)

        void FormFactorPyramid::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorPyramid_accept(self, visitor)


    def getHeight(self):
        """
        getHeight(FormFactorPyramid self) -> double

        double FormFactorPyramid::getHeight() const

        """
        return _libBornAgainCore.FormFactorPyramid_getHeight(self)


    def getBaseEdge(self):
        """
        getBaseEdge(FormFactorPyramid self) -> double

        double FormFactorPyramid::getBaseEdge() const

        """
        return _libBornAgainCore.FormFactorPyramid_getBaseEdge(self)


    def getAlpha(self):
        """
        getAlpha(FormFactorPyramid self) -> double

        double FormFactorPyramid::getAlpha() const

        """
        return _libBornAgainCore.FormFactorPyramid_getAlpha(self)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorPyramid
    __del__ = lambda self: None
FormFactorPyramid_swigregister = _libBornAgainCore.FormFactorPyramid_swigregister
FormFactorPyramid_swigregister(FormFactorPyramid)

class FormFactorRipple1(IFormFactorBorn):
    """


    The formfactor for a cosine ripple.

    C++ includes: FormFactorRipple1.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorRipple1, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorRipple1, name)
    __repr__ = _swig_repr

    def __init__(self, length, width, height):
        """
        __init__(FormFactorRipple1 self, double length, double width, double height) -> FormFactorRipple1

        FormFactorRipple1::FormFactorRipple1(double length, double width, double height)

        Ripple1 constructor.

        Parameters:
        -----------

        length: 
        of Ripple1

        width: 
        of cosine cross section

        height: 
        of cosine cross section 

        """
        this = _libBornAgainCore.new_FormFactorRipple1(length, width, height)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorRipple1 self) -> FormFactorRipple1

        FormFactorRipple1* FormFactorRipple1::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorRipple1_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorRipple1 self, ISampleVisitor visitor)

        void FormFactorRipple1::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorRipple1_accept(self, visitor)


    def getLength(self):
        """
        getLength(FormFactorRipple1 self) -> double

        double FormFactorRipple1::getLength() const

        """
        return _libBornAgainCore.FormFactorRipple1_getLength(self)


    def getHeight(self):
        """
        getHeight(FormFactorRipple1 self) -> double

        double FormFactorRipple1::getHeight() const

        """
        return _libBornAgainCore.FormFactorRipple1_getHeight(self)


    def getWidth(self):
        """
        getWidth(FormFactorRipple1 self) -> double

        double FormFactorRipple1::getWidth() const

        """
        return _libBornAgainCore.FormFactorRipple1_getWidth(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorRipple1 self) -> double

        double FormFactorRipple1::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorRipple1_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorRipple1 self, cvector_t q) -> complex_t

        complex_t FormFactorRipple1::evaluate_for_q(const cvector_t q) const override final

        Complex formfactor. 

        """
        return _libBornAgainCore.FormFactorRipple1_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorRipple1
    __del__ = lambda self: None
FormFactorRipple1_swigregister = _libBornAgainCore.FormFactorRipple1_swigregister
FormFactorRipple1_swigregister(FormFactorRipple1)

class FormFactorRipple2(IFormFactorBorn):
    """


    The formfactor for a triangular ripple.

    C++ includes: FormFactorRipple2.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorRipple2, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorRipple2, name)
    __repr__ = _swig_repr

    def __init__(self, length, width, height, asymmetry):
        """
        __init__(FormFactorRipple2 self, double length, double width, double height, double asymmetry) -> FormFactorRipple2

        FormFactorRipple2::FormFactorRipple2(double length, double width, double height, double asymmetry)

        Ripple2 constructor.

        Parameters:
        -----------

        length: 
        of Ripple2

        width: 
        of triangular cross section

        height: 
        of triangular cross section

        asymmetry: 
        length of triangular cross section 

        """
        this = _libBornAgainCore.new_FormFactorRipple2(length, width, height, asymmetry)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorRipple2 self) -> FormFactorRipple2

        FormFactorRipple2* FormFactorRipple2::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorRipple2_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorRipple2 self, ISampleVisitor visitor)

        void FormFactorRipple2::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorRipple2_accept(self, visitor)


    def getHeight(self):
        """
        getHeight(FormFactorRipple2 self) -> double

        double FormFactorRipple2::getHeight() const

        """
        return _libBornAgainCore.FormFactorRipple2_getHeight(self)


    def getWidth(self):
        """
        getWidth(FormFactorRipple2 self) -> double

        double FormFactorRipple2::getWidth() const

        """
        return _libBornAgainCore.FormFactorRipple2_getWidth(self)


    def getLength(self):
        """
        getLength(FormFactorRipple2 self) -> double

        double FormFactorRipple2::getLength() const

        """
        return _libBornAgainCore.FormFactorRipple2_getLength(self)


    def getAsymmetry(self):
        """
        getAsymmetry(FormFactorRipple2 self) -> double

        double FormFactorRipple2::getAsymmetry() const

        """
        return _libBornAgainCore.FormFactorRipple2_getAsymmetry(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorRipple2 self) -> double

        double FormFactorRipple2::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorRipple2_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorRipple2 self, cvector_t q) -> complex_t

        complex_t FormFactorRipple2::evaluate_for_q(const cvector_t q) const override final

        Complex formfactor. 

        """
        return _libBornAgainCore.FormFactorRipple2_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorRipple2
    __del__ = lambda self: None
FormFactorRipple2_swigregister = _libBornAgainCore.FormFactorRipple2_swigregister
FormFactorRipple2_swigregister(FormFactorRipple2)

class FormFactorSphereGaussianRadius(IFormFactorBorn):
    """


    A sphere with gaussian radius distribution.

    C++ includes: FormFactorSphereGaussianRadius.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorSphereGaussianRadius, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorSphereGaussianRadius, name)
    __repr__ = _swig_repr

    def __init__(self, mean, sigma):
        """
        __init__(FormFactorSphereGaussianRadius self, double mean, double sigma) -> FormFactorSphereGaussianRadius

        FormFactorSphereGaussianRadius::FormFactorSphereGaussianRadius(double mean, double sigma)

        """
        this = _libBornAgainCore.new_FormFactorSphereGaussianRadius(mean, sigma)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorSphereGaussianRadius self) -> FormFactorSphereGaussianRadius

        FormFactorSphereGaussianRadius* FormFactorSphereGaussianRadius::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorSphereGaussianRadius_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorSphereGaussianRadius self, ISampleVisitor visitor)

        void FormFactorSphereGaussianRadius::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorSphereGaussianRadius_accept(self, visitor)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorSphereGaussianRadius self) -> double

        double FormFactorSphereGaussianRadius::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorSphereGaussianRadius_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorSphereGaussianRadius self, cvector_t q) -> complex_t

        complex_t FormFactorSphereGaussianRadius::evaluate_for_q(const cvector_t q) const override final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainCore.FormFactorSphereGaussianRadius_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorSphereGaussianRadius
    __del__ = lambda self: None
FormFactorSphereGaussianRadius_swigregister = _libBornAgainCore.FormFactorSphereGaussianRadius_swigregister
FormFactorSphereGaussianRadius_swigregister(FormFactorSphereGaussianRadius)

class FormFactorSphereLogNormalRadius(IFormFactorBorn):
    """


    A sphere with log normal radius distribution.

    C++ includes: FormFactorSphereLogNormalRadius.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorSphereLogNormalRadius, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorSphereLogNormalRadius, name)
    __repr__ = _swig_repr

    def __init__(self, mean, scale_param, n_samples):
        """
        __init__(FormFactorSphereLogNormalRadius self, double mean, double scale_param, size_t n_samples) -> FormFactorSphereLogNormalRadius

        FormFactorSphereLogNormalRadius::FormFactorSphereLogNormalRadius(double mean, double scale_param, size_t n_samples)

        """
        this = _libBornAgainCore.new_FormFactorSphereLogNormalRadius(mean, scale_param, n_samples)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorSphereLogNormalRadius self) -> FormFactorSphereLogNormalRadius

        FormFactorSphereLogNormalRadius* FormFactorSphereLogNormalRadius::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorSphereLogNormalRadius_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorSphereLogNormalRadius self, ISampleVisitor visitor)

        void FormFactorSphereLogNormalRadius::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorSphereLogNormalRadius_accept(self, visitor)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorSphereLogNormalRadius self) -> double

        double FormFactorSphereLogNormalRadius::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorSphereLogNormalRadius_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorSphereLogNormalRadius self, cvector_t q) -> complex_t

        complex_t FormFactorSphereLogNormalRadius::evaluate_for_q(const cvector_t q) const override final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainCore.FormFactorSphereLogNormalRadius_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorSphereLogNormalRadius
    __del__ = lambda self: None
FormFactorSphereLogNormalRadius_swigregister = _libBornAgainCore.FormFactorSphereLogNormalRadius_swigregister
FormFactorSphereLogNormalRadius_swigregister(FormFactorSphereLogNormalRadius)

class FormFactorSphereUniformRadius(IFormFactorBorn):
    """


    Integrated full sphere form factor over a uniform distribution of radii.

    C++ includes: FormFactorSphereUniformRadius.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorSphereUniformRadius, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorSphereUniformRadius, name)
    __repr__ = _swig_repr

    def __init__(self, mean, full_width):
        """
        __init__(FormFactorSphereUniformRadius self, double mean, double full_width) -> FormFactorSphereUniformRadius

        FormFactorSphereUniformRadius::FormFactorSphereUniformRadius(double mean, double full_width)

        """
        this = _libBornAgainCore.new_FormFactorSphereUniformRadius(mean, full_width)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorSphereUniformRadius self) -> FormFactorSphereUniformRadius

        FormFactorSphereUniformRadius* FormFactorSphereUniformRadius::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorSphereUniformRadius_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorSphereUniformRadius self, ISampleVisitor visitor)

        void FormFactorSphereUniformRadius::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorSphereUniformRadius_accept(self, visitor)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorSphereUniformRadius self) -> double

        double FormFactorSphereUniformRadius::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorSphereUniformRadius_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorSphereUniformRadius self, cvector_t q) -> complex_t

        complex_t FormFactorSphereUniformRadius::evaluate_for_q(const cvector_t q) const override final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainCore.FormFactorSphereUniformRadius_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorSphereUniformRadius
    __del__ = lambda self: None
FormFactorSphereUniformRadius_swigregister = _libBornAgainCore.FormFactorSphereUniformRadius_swigregister
FormFactorSphereUniformRadius_swigregister(FormFactorSphereUniformRadius)

class FormFactorTetrahedron(FormFactorPolyhedron):
    """


    A frustum with equilateral trigonal base.

    C++ includes: FormFactorTetrahedron.h

    """

    __swig_setmethods__ = {}
    for _s in [FormFactorPolyhedron]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorTetrahedron, name, value)
    __swig_getmethods__ = {}
    for _s in [FormFactorPolyhedron]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorTetrahedron, name)
    __repr__ = _swig_repr

    def __init__(self, base_edge, height, alpha):
        """
        __init__(FormFactorTetrahedron self, double base_edge, double height, double alpha) -> FormFactorTetrahedron

        FormFactorTetrahedron::FormFactorTetrahedron(double base_edge, double height, double alpha)

        Parameters:
        -----------

        base_edge: 
        of a side of the base

        height: 
        of the frustum

        alpha: 
        dihedral angle in radians between base and facet 

        """
        this = _libBornAgainCore.new_FormFactorTetrahedron(base_edge, height, alpha)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorTetrahedron self) -> FormFactorTetrahedron

        FormFactorTetrahedron* FormFactorTetrahedron::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorTetrahedron_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorTetrahedron self, ISampleVisitor visitor)

        void FormFactorTetrahedron::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorTetrahedron_accept(self, visitor)


    def getBaseEdge(self):
        """
        getBaseEdge(FormFactorTetrahedron self) -> double

        double FormFactorTetrahedron::getBaseEdge() const

        """
        return _libBornAgainCore.FormFactorTetrahedron_getBaseEdge(self)


    def getHeight(self):
        """
        getHeight(FormFactorTetrahedron self) -> double

        double FormFactorTetrahedron::getHeight() const

        """
        return _libBornAgainCore.FormFactorTetrahedron_getHeight(self)


    def getAlpha(self):
        """
        getAlpha(FormFactorTetrahedron self) -> double

        double FormFactorTetrahedron::getAlpha() const

        """
        return _libBornAgainCore.FormFactorTetrahedron_getAlpha(self)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorTetrahedron
    __del__ = lambda self: None
FormFactorTetrahedron_swigregister = _libBornAgainCore.FormFactorTetrahedron_swigregister
FormFactorTetrahedron_swigregister(FormFactorTetrahedron)

class FormFactorTrivial(IFormFactorBorn):
    """


    A dot, with trivial formfactor F(q)=1.

    C++ includes: FormFactorTrivial.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorTrivial, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorTrivial, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(FormFactorTrivial self) -> FormFactorTrivial

        FormFactorTrivial::FormFactorTrivial()

        """
        this = _libBornAgainCore.new_FormFactorTrivial()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorTrivial self) -> FormFactorTrivial

        FormFactorTrivial* FormFactorTrivial::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorTrivial_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorTrivial self, ISampleVisitor visitor)

        void FormFactorTrivial::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorTrivial_accept(self, visitor)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorTrivial self) -> double

        double FormFactorTrivial::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorTrivial_getRadialExtension(self)


    def evaluate_for_q(self, arg2):
        """
        evaluate_for_q(FormFactorTrivial self, cvector_t arg2) -> complex_t

        complex_t FormFactorTrivial::evaluate_for_q(const cvector_t) const override final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainCore.FormFactorTrivial_evaluate_for_q(self, arg2)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorTrivial
    __del__ = lambda self: None
FormFactorTrivial_swigregister = _libBornAgainCore.FormFactorTrivial_swigregister
FormFactorTrivial_swigregister(FormFactorTrivial)

class FormFactorTruncatedCube(FormFactorPolyhedron):
    """


    A cube, with tetrahedral truncation of all edges.

    C++ includes: FormFactorTruncatedCube.h

    """

    __swig_setmethods__ = {}
    for _s in [FormFactorPolyhedron]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorTruncatedCube, name, value)
    __swig_getmethods__ = {}
    for _s in [FormFactorPolyhedron]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorTruncatedCube, name)
    __repr__ = _swig_repr

    def __init__(self, length, removed_length):
        """
        __init__(FormFactorTruncatedCube self, double length, double removed_length) -> FormFactorTruncatedCube

        FormFactorTruncatedCube::FormFactorTruncatedCube(double length, double removed_length)

        Parameters:
        -----------

        length: 
        of the full cube

        removed_length: 
        as removed from each edge of the cube 

        """
        this = _libBornAgainCore.new_FormFactorTruncatedCube(length, removed_length)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorTruncatedCube self) -> FormFactorTruncatedCube

        FormFactorTruncatedCube* FormFactorTruncatedCube::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorTruncatedCube_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorTruncatedCube self, ISampleVisitor visitor)

        void FormFactorTruncatedCube::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorTruncatedCube_accept(self, visitor)


    def getLength(self):
        """
        getLength(FormFactorTruncatedCube self) -> double

        double FormFactorTruncatedCube::getLength() const

        """
        return _libBornAgainCore.FormFactorTruncatedCube_getLength(self)


    def getRemovedLength(self):
        """
        getRemovedLength(FormFactorTruncatedCube self) -> double

        double FormFactorTruncatedCube::getRemovedLength() const

        """
        return _libBornAgainCore.FormFactorTruncatedCube_getRemovedLength(self)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorTruncatedCube
    __del__ = lambda self: None
FormFactorTruncatedCube_swigregister = _libBornAgainCore.FormFactorTruncatedCube_swigregister
FormFactorTruncatedCube_swigregister(FormFactorTruncatedCube)

class FormFactorTruncatedSphere(IFormFactorBorn):
    """


    A truncated Sphere.

    C++ includes: FormFactorTruncatedSphere.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorTruncatedSphere, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorTruncatedSphere, name)
    __repr__ = _swig_repr

    def __init__(self, radius, height):
        """
        __init__(FormFactorTruncatedSphere self, double radius, double height) -> FormFactorTruncatedSphere

        FormFactorTruncatedSphere::FormFactorTruncatedSphere(double radius, double height)

        """
        this = _libBornAgainCore.new_FormFactorTruncatedSphere(radius, height)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorTruncatedSphere self) -> FormFactorTruncatedSphere

        FormFactorTruncatedSphere* FormFactorTruncatedSphere::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorTruncatedSphere_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorTruncatedSphere self, ISampleVisitor visitor)

        void FormFactorTruncatedSphere::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorTruncatedSphere_accept(self, visitor)


    def getHeight(self):
        """
        getHeight(FormFactorTruncatedSphere self) -> double

        double FormFactorTruncatedSphere::getHeight() const

        """
        return _libBornAgainCore.FormFactorTruncatedSphere_getHeight(self)


    def getRadius(self):
        """
        getRadius(FormFactorTruncatedSphere self) -> double

        double FormFactorTruncatedSphere::getRadius() const

        """
        return _libBornAgainCore.FormFactorTruncatedSphere_getRadius(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorTruncatedSphere self) -> double

        double FormFactorTruncatedSphere::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorTruncatedSphere_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorTruncatedSphere self, cvector_t q) -> complex_t

        complex_t FormFactorTruncatedSphere::evaluate_for_q(const cvector_t q) const override final

        Complex formfactor. 

        """
        return _libBornAgainCore.FormFactorTruncatedSphere_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorTruncatedSphere
    __del__ = lambda self: None
FormFactorTruncatedSphere_swigregister = _libBornAgainCore.FormFactorTruncatedSphere_swigregister
FormFactorTruncatedSphere_swigregister(FormFactorTruncatedSphere)

class FormFactorTruncatedSpheroid(IFormFactorBorn):
    """


    A truncated spheroid. An ellipsoid with two equal axis, truncated by a plane perpendicular to the third axis.

    C++ includes: FormFactorTruncatedSpheroid.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorTruncatedSpheroid, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactorBorn]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorTruncatedSpheroid, name)
    __repr__ = _swig_repr

    def __init__(self, radius, height, height_flattening):
        """
        __init__(FormFactorTruncatedSpheroid self, double radius, double height, double height_flattening) -> FormFactorTruncatedSpheroid

        FormFactorTruncatedSpheroid::FormFactorTruncatedSpheroid(double radius, double height, double height_flattening)

        """
        this = _libBornAgainCore.new_FormFactorTruncatedSpheroid(radius, height, height_flattening)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(FormFactorTruncatedSpheroid self) -> FormFactorTruncatedSpheroid

        FormFactorTruncatedSpheroid* FormFactorTruncatedSpheroid::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorTruncatedSpheroid_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorTruncatedSpheroid self, ISampleVisitor visitor)

        void FormFactorTruncatedSpheroid::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorTruncatedSpheroid_accept(self, visitor)


    def getRadius(self):
        """
        getRadius(FormFactorTruncatedSpheroid self) -> double

        double FormFactorTruncatedSpheroid::getRadius() const

        """
        return _libBornAgainCore.FormFactorTruncatedSpheroid_getRadius(self)


    def getHeight(self):
        """
        getHeight(FormFactorTruncatedSpheroid self) -> double

        double FormFactorTruncatedSpheroid::getHeight() const

        """
        return _libBornAgainCore.FormFactorTruncatedSpheroid_getHeight(self)


    def getHeightFlattening(self):
        """
        getHeightFlattening(FormFactorTruncatedSpheroid self) -> double

        double FormFactorTruncatedSpheroid::getHeightFlattening() const

        """
        return _libBornAgainCore.FormFactorTruncatedSpheroid_getHeightFlattening(self)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorTruncatedSpheroid self) -> double

        double FormFactorTruncatedSpheroid::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorTruncatedSpheroid_getRadialExtension(self)


    def evaluate_for_q(self, q):
        """
        evaluate_for_q(FormFactorTruncatedSpheroid self, cvector_t q) -> complex_t

        complex_t FormFactorTruncatedSpheroid::evaluate_for_q(const cvector_t q) const override final

        Returns scattering amplitude for complex scattering wavevector q=k_i-k_f. This method is public only for convenience of plotting form factors in Python. 

        """
        return _libBornAgainCore.FormFactorTruncatedSpheroid_evaluate_for_q(self, q)

    __swig_destroy__ = _libBornAgainCore.delete_FormFactorTruncatedSpheroid
    __del__ = lambda self: None
FormFactorTruncatedSpheroid_swigregister = _libBornAgainCore.FormFactorTruncatedSpheroid_swigregister
FormFactorTruncatedSpheroid_swigregister(FormFactorTruncatedSpheroid)

class FormFactorWeighted(IFormFactor):
    """


    Coherent sum of different scalar  IFormFactor's with different weights.

    Used by  ParticleComposition and  ParticleCoreShell. If same particles are at different positions, then consider FormFactorDecoratorMultiPositionFactor (restore from commit 0500a26de76).

    C++ includes: FormFactorWeighted.h

    """

    __swig_setmethods__ = {}
    for _s in [IFormFactor]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormFactorWeighted, name, value)
    __swig_getmethods__ = {}
    for _s in [IFormFactor]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormFactorWeighted, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(FormFactorWeighted self) -> FormFactorWeighted

        FormFactorWeighted::FormFactorWeighted()

        """
        this = _libBornAgainCore.new_FormFactorWeighted()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_FormFactorWeighted
    __del__ = lambda self: None

    def clone(self):
        """
        clone(FormFactorWeighted self) -> FormFactorWeighted

        FormFactorWeighted * FormFactorWeighted::clone() const override final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.FormFactorWeighted_clone(self)


    def accept(self, visitor):
        """
        accept(FormFactorWeighted self, ISampleVisitor visitor)

        void FormFactorWeighted::accept(ISampleVisitor *visitor) const override final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.FormFactorWeighted_accept(self, visitor)


    def getRadialExtension(self):
        """
        getRadialExtension(FormFactorWeighted self) -> double

        double FormFactorWeighted::getRadialExtension() const override final

        Returns the (approximate in some cases) radial size of the particle of this form factor's shape. This is used for SSCA calculations 

        """
        return _libBornAgainCore.FormFactorWeighted_getRadialExtension(self)


    def addFormFactor(self, form_factor, weight=1.0):
        """
        addFormFactor(FormFactorWeighted self, IFormFactor form_factor, double weight=1.0)
        addFormFactor(FormFactorWeighted self, IFormFactor form_factor)

        void FormFactorWeighted::addFormFactor(const IFormFactor &form_factor, double weight=1.0)

        """
        return _libBornAgainCore.FormFactorWeighted_addFormFactor(self, form_factor, weight)


    def setAmbientMaterial(self, material):
        """
        setAmbientMaterial(FormFactorWeighted self, IMaterial material)

        void FormFactorWeighted::setAmbientMaterial(const IMaterial &material) override final

        Passes the refractive index of the ambient material in which this particle is embedded. 

        """
        return _libBornAgainCore.FormFactorWeighted_setAmbientMaterial(self, material)


    def evaluate(self, wavevectors):
        """
        evaluate(FormFactorWeighted self, WavevectorInfo wavevectors) -> complex_t

        complex_t FormFactorWeighted::evaluate(const WavevectorInfo &wavevectors) const override final

        Returns scattering amplitude for complex wavevectors ki, kf. 

        """
        return _libBornAgainCore.FormFactorWeighted_evaluate(self, wavevectors)

FormFactorWeighted_swigregister = _libBornAgainCore.FormFactorWeighted_swigregister
FormFactorWeighted_swigregister(FormFactorWeighted)

class Simulation(ICloneable, IParameterized):
    """


    Pure virtual base class of OffSpecularSimulation and  GISASSimulation, holds common infrastructure to run a simulation.

    C++ includes: Simulation.h

    """

    __swig_setmethods__ = {}
    for _s in [ICloneable, IParameterized]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Simulation, name, value)
    __swig_getmethods__ = {}
    for _s in [ICloneable, IParameterized]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Simulation, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_Simulation
    __del__ = lambda self: None

    def clone(self):
        """
        clone(Simulation self) -> Simulation

        virtual Simulation* Simulation::clone() const =0

        """
        return _libBornAgainCore.Simulation_clone(self)


    def prepareSimulation(self):
        """
        prepareSimulation(Simulation self)

        void Simulation::prepareSimulation()

        Put into a clean state for running a simulation. 

        """
        return _libBornAgainCore.Simulation_prepareSimulation(self)


    def runSimulation(self):
        """
        runSimulation(Simulation self)

        void Simulation::runSimulation()

        Run a simulation, possibly averaged over parameter distributions.

        Run simulation with possible averaging over parameter distributions. 

        """
        return _libBornAgainCore.Simulation_runSimulation(self)


    def setInstrument(self, instrument):
        """
        setInstrument(Simulation self, Instrument instrument)

        void Simulation::setInstrument(const Instrument &instrument)

        """
        return _libBornAgainCore.Simulation_setInstrument(self, instrument)


    def getInstrument(self, *args):
        """
        getInstrument(Simulation self) -> Instrument
        getInstrument(Simulation self) -> Instrument

        Instrument& Simulation::getInstrument()

        """
        return _libBornAgainCore.Simulation_getInstrument(self, *args)


    def setBeamIntensity(self, intensity):
        """
        setBeamIntensity(Simulation self, double intensity)

        void Simulation::setBeamIntensity(double intensity)

        """
        return _libBornAgainCore.Simulation_setBeamIntensity(self, intensity)


    def getBeamIntensity(self):
        """
        getBeamIntensity(Simulation self) -> double

        double Simulation::getBeamIntensity() const

        """
        return _libBornAgainCore.Simulation_getBeamIntensity(self)


    def setBeamPolarization(self, bloch_vector):
        """
        setBeamPolarization(Simulation self, kvector_t bloch_vector)

        void Simulation::setBeamPolarization(const kvector_t bloch_vector)

        Sets the beam polarization according to the given Bloch vector. 

        """
        return _libBornAgainCore.Simulation_setBeamPolarization(self, bloch_vector)


    def setDetectorResolutionFunction(self, resolution_function):
        """
        setDetectorResolutionFunction(Simulation self, IResolutionFunction2D resolution_function)

        void Simulation::setDetectorResolutionFunction(const IResolutionFunction2D &resolution_function)

        """
        return _libBornAgainCore.Simulation_setDetectorResolutionFunction(self, resolution_function)


    def removeDetectorResolutionFunction(self):
        """
        removeDetectorResolutionFunction(Simulation self)

        void Simulation::removeDetectorResolutionFunction()

        """
        return _libBornAgainCore.Simulation_removeDetectorResolutionFunction(self)


    def setAnalyzerProperties(self, direction, efficiency, total_transmission):
        """
        setAnalyzerProperties(Simulation self, kvector_t direction, double efficiency, double total_transmission)

        void Simulation::setAnalyzerProperties(const kvector_t direction, double efficiency, double total_transmission)

        Sets the polarization analyzer characteristics of the detector. 

        """
        return _libBornAgainCore.Simulation_setAnalyzerProperties(self, direction, efficiency, total_transmission)


    def setSample(self, sample):
        """
        setSample(Simulation self, MultiLayer sample)

        void Simulation::setSample(const MultiLayer &sample)

        The  MultiLayer object will not be owned by the  Simulation object. 

        """
        return _libBornAgainCore.Simulation_setSample(self, sample)


    def getSample(self):
        """
        getSample(Simulation self) -> MultiLayer

        MultiLayer* Simulation::getSample() const

        """
        return _libBornAgainCore.Simulation_getSample(self)


    def setSampleBuilderCpp(self, sample_builder):
        """
        setSampleBuilderCpp(Simulation self, std::shared_ptr< IMultiLayerBuilder > const sample_builder)

        void Simulation::setSampleBuilder(const std::shared_ptr< IMultiLayerBuilder > sample_builder)

        """
        return _libBornAgainCore.Simulation_setSampleBuilderCpp(self, sample_builder)


    def getSampleBuilder(self):
        """
        getSampleBuilder(Simulation self) -> std::shared_ptr< IMultiLayerBuilder >

        std::shared_ptr<IMultiLayerBuilder> Simulation::getSampleBuilder() const

        """
        return _libBornAgainCore.Simulation_getSampleBuilder(self)


    def numberOfSimulationElements(self):
        """
        numberOfSimulationElements(Simulation self) -> int

        virtual int Simulation::numberOfSimulationElements() const =0

        """
        return _libBornAgainCore.Simulation_numberOfSimulationElements(self)


    def getDetectorIntensity(self, *args):
        """
        getDetectorIntensity(Simulation self, IDetector2D::EAxesUnits units_type) -> IntensityData
        getDetectorIntensity(Simulation self) -> IntensityData

        virtual OutputData<double>* Simulation::getDetectorIntensity(IDetector2D::EAxesUnits units_type=IDetector2D::DEFAULT) const =0

        Clone simulated intensity map. 

        """
        return _libBornAgainCore.Simulation_getDetectorIntensity(self, *args)


    def addSimulationParametersToExternalPool(self, path, external_pool):
        """
        addSimulationParametersToExternalPool(Simulation self, std::string const & path, ParameterPool external_pool) -> std::string

        std::string Simulation::addSimulationParametersToExternalPool(const std::string &path, ParameterPool *external_pool) const

        Adds parameters defined in this class the to external pool. 

        """
        return _libBornAgainCore.Simulation_addSimulationParametersToExternalPool(self, path, external_pool)


    def addParameterDistribution(self, *args):
        """
        addParameterDistribution(Simulation self, std::string const & param_name, IDistribution1D distribution, size_t nbr_samples, double sigma_factor=0.0, RealLimits limits)
        addParameterDistribution(Simulation self, std::string const & param_name, IDistribution1D distribution, size_t nbr_samples, double sigma_factor=0.0)
        addParameterDistribution(Simulation self, std::string const & param_name, IDistribution1D distribution, size_t nbr_samples)
        addParameterDistribution(Simulation self, ParameterDistribution par_distr)

        void Simulation::addParameterDistribution(const ParameterDistribution &par_distr)

        """
        return _libBornAgainCore.Simulation_addParameterDistribution(self, *args)


    def getDistributionHandler(self):
        """
        getDistributionHandler(Simulation self) -> DistributionHandler const &

        const DistributionHandler& Simulation::getDistributionHandler() const

        """
        return _libBornAgainCore.Simulation_getDistributionHandler(self)


    def setOptions(self, options):
        """
        setOptions(Simulation self, SimulationOptions options)

        void Simulation::setOptions(const SimulationOptions &options)

        """
        return _libBornAgainCore.Simulation_setOptions(self, options)


    def getOptions(self, *args):
        """
        getOptions(Simulation self) -> SimulationOptions
        getOptions(Simulation self) -> SimulationOptions

        SimulationOptions& Simulation::getOptions()

        """
        return _libBornAgainCore.Simulation_getOptions(self, *args)


    def subscribe(self, inform):
        """
        subscribe(Simulation self, ProgressHandler::Callback_t inform)

        void Simulation::subscribe(ProgressHandler::Callback_t inform)

        """
        return _libBornAgainCore.Simulation_subscribe(self, inform)


    def setTerminalProgressMonitor(self):
        """
        setTerminalProgressMonitor(Simulation self)

        void Simulation::setTerminalProgressMonitor()

        Initializes a progress monitor that prints to stdout. 

        """
        return _libBornAgainCore.Simulation_setTerminalProgressMonitor(self)


    def setSampleBuilder(self, ptr):
        self.samplebuilder = ptr
        self.setSampleBuilderCpp(ptr)

Simulation_swigregister = _libBornAgainCore.Simulation_swigregister
Simulation_swigregister(Simulation)

class SimulationOptions(_object):
    """


    Collect the different options for simulation  SimulationOptions.

    C++ includes: SimulationOptions.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimulationOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SimulationOptions, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(SimulationOptions self) -> SimulationOptions

        SimulationOptions::SimulationOptions()

        """
        this = _libBornAgainCore.new_SimulationOptions()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def isIntegrate(self):
        """
        isIntegrate(SimulationOptions self) -> bool

        bool SimulationOptions::isIntegrate() const

        """
        return _libBornAgainCore.SimulationOptions_isIntegrate(self)


    def getMcPoints(self):
        """
        getMcPoints(SimulationOptions self) -> size_t

        size_t SimulationOptions::getMcPoints() const

        """
        return _libBornAgainCore.SimulationOptions_getMcPoints(self)


    def setMonteCarloIntegration(self, flag=True, mc_points=50):
        """
        setMonteCarloIntegration(SimulationOptions self, bool flag=True, size_t mc_points=50)
        setMonteCarloIntegration(SimulationOptions self, bool flag=True)
        setMonteCarloIntegration(SimulationOptions self)

        void SimulationOptions::setMonteCarloIntegration(bool flag=true, size_t mc_points=50)

        Enables/disables MonetCarlo integration.

        Parameters:
        -----------

        flag: 
        If true, MonteCarlo integration will be used, otherwise analytical calculations

        mc_points: 
        Number of points for MonteCarlo integrator 

        """
        return _libBornAgainCore.SimulationOptions_setMonteCarloIntegration(self, flag, mc_points)


    def setNumberOfThreads(self, nthreads):
        """
        setNumberOfThreads(SimulationOptions self, int nthreads)

        void SimulationOptions::setNumberOfThreads(int nthreads)

        Sets number of threads to use during the simulation (0 - take the default value from the hardware) 

        """
        return _libBornAgainCore.SimulationOptions_setNumberOfThreads(self, nthreads)


    def getNumberOfThreads(self):
        """
        getNumberOfThreads(SimulationOptions self) -> int

        int SimulationOptions::getNumberOfThreads() const

        """
        return _libBornAgainCore.SimulationOptions_getNumberOfThreads(self)


    def setNumberOfBatches(self, nbatches):
        """
        setNumberOfBatches(SimulationOptions self, int nbatches)

        void SimulationOptions::setNumberOfBatches(int nbatches)

        Sets number of batches to split. 

        """
        return _libBornAgainCore.SimulationOptions_setNumberOfBatches(self, nbatches)


    def getNumberOfBatches(self):
        """
        getNumberOfBatches(SimulationOptions self) -> int

        int SimulationOptions::getNumberOfBatches() const

        """
        return _libBornAgainCore.SimulationOptions_getNumberOfBatches(self)


    def getCurrentBatch(self):
        """
        getCurrentBatch(SimulationOptions self) -> int

        int SimulationOptions::getCurrentBatch() const

        """
        return _libBornAgainCore.SimulationOptions_getCurrentBatch(self)


    def setThreadInfo(self, thread_info):
        """
        setThreadInfo(SimulationOptions self, ThreadInfo thread_info)

        void SimulationOptions::setThreadInfo(const ThreadInfo &thread_info)

        Sets the batch and thread information to be used. 

        """
        return _libBornAgainCore.SimulationOptions_setThreadInfo(self, thread_info)


    def getHardwareConcurrency(self):
        """
        getHardwareConcurrency(SimulationOptions self) -> int

        int SimulationOptions::getHardwareConcurrency() const

        """
        return _libBornAgainCore.SimulationOptions_getHardwareConcurrency(self)


    def setIncludeSpecular(self, include_specular):
        """
        setIncludeSpecular(SimulationOptions self, bool include_specular)

        void SimulationOptions::setIncludeSpecular(bool include_specular)

        """
        return _libBornAgainCore.SimulationOptions_setIncludeSpecular(self, include_specular)


    def includeSpecular(self):
        """
        includeSpecular(SimulationOptions self) -> bool

        bool SimulationOptions::includeSpecular() const

        """
        return _libBornAgainCore.SimulationOptions_includeSpecular(self)

    __swig_destroy__ = _libBornAgainCore.delete_SimulationOptions
    __del__ = lambda self: None
SimulationOptions_swigregister = _libBornAgainCore.SimulationOptions_swigregister
SimulationOptions_swigregister(SimulationOptions)

class GISASSimulation(Simulation):
    """


    Main class to run a Grazing-Incidence Small-Angle Scattering simulation.

    C++ includes: GISASSimulation.h

    """

    __swig_setmethods__ = {}
    for _s in [Simulation]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GISASSimulation, name, value)
    __swig_getmethods__ = {}
    for _s in [Simulation]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GISASSimulation, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GISASSimulation self) -> GISASSimulation
        __init__(GISASSimulation self, MultiLayer p_sample) -> GISASSimulation
        __init__(GISASSimulation self, std::shared_ptr< IMultiLayerBuilder > const p_sample_builder) -> GISASSimulation

        GISASSimulation::GISASSimulation(const std::shared_ptr< IMultiLayerBuilder > p_sample_builder)

        """
        this = _libBornAgainCore.new_GISASSimulation(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_GISASSimulation
    __del__ = lambda self: None

    def clone(self):
        """
        clone(GISASSimulation self) -> GISASSimulation

        GISASSimulation* GISASSimulation::clone() const

        """
        return _libBornAgainCore.GISASSimulation_clone(self)


    def prepareSimulation(self):
        """
        prepareSimulation(GISASSimulation self)

        void GISASSimulation::prepareSimulation() final

        Put into a clean state for running a simulation. 

        """
        return _libBornAgainCore.GISASSimulation_prepareSimulation(self)


    def numberOfSimulationElements(self):
        """
        numberOfSimulationElements(GISASSimulation self) -> int

        int GISASSimulation::numberOfSimulationElements() const final

        Gets the number of elements this simulation needs to calculate. 

        """
        return _libBornAgainCore.GISASSimulation_numberOfSimulationElements(self)


    def getDetectorIntensity(self, *args):
        """
        getDetectorIntensity(GISASSimulation self, IDetector2D::EAxesUnits units_type) -> IntensityData
        getDetectorIntensity(GISASSimulation self) -> IntensityData

        OutputData< double > * GISASSimulation::getDetectorIntensity(IDetector2D::EAxesUnits units_type=IDetector2D::DEFAULT) const

        Returns clone of the detector intensity map with detector resolution applied. 

        """
        return _libBornAgainCore.GISASSimulation_getDetectorIntensity(self, *args)


    def getIntensityData(self, *args):
        """
        getIntensityData(GISASSimulation self, IDetector2D::EAxesUnits units_type) -> Histogram2D
        getIntensityData(GISASSimulation self) -> Histogram2D

        Histogram2D * GISASSimulation::getIntensityData(IDetector2D::EAxesUnits units_type=IDetector2D::DEFAULT) const

        Returns histogram representing intensity map in requested axes units. 

        """
        return _libBornAgainCore.GISASSimulation_getIntensityData(self, *args)


    def setBeamParameters(self, wavelength, alpha_i, phi_i):
        """
        setBeamParameters(GISASSimulation self, double wavelength, double alpha_i, double phi_i)

        void GISASSimulation::setBeamParameters(double wavelength, double alpha_i, double phi_i)

        Sets beam parameters from here (forwarded to  Instrument) 

        """
        return _libBornAgainCore.GISASSimulation_setBeamParameters(self, wavelength, alpha_i, phi_i)


    def setDetector(self, detector):
        """
        setDetector(GISASSimulation self, IDetector2D detector)

        void GISASSimulation::setDetector(const IDetector2D &detector)

        Sets the detector (axes can be overwritten later) 

        """
        return _libBornAgainCore.GISASSimulation_setDetector(self, detector)


    def setDetectorParameters(self, n_phi, phi_min, phi_max, n_alpha, alpha_min, alpha_max):
        """
        setDetectorParameters(GISASSimulation self, size_t n_phi, double phi_min, double phi_max, size_t n_alpha, double alpha_min, double alpha_max)

        void GISASSimulation::setDetectorParameters(size_t n_phi, double phi_min, double phi_max, size_t n_alpha, double alpha_min, double alpha_max)

        Sets spherical detector parameters using angle ranges

        Parameters:
        -----------

        n_phi: 
        number of phi-axis bins

        phi_min: 
        low edge of first phi-bin

        phi_max: 
        upper edge of last phi-bin

        n_alpha: 
        number of alpha-axis bins

        alpha_min: 
        low edge of first alpha-bin

        alpha_max: 
        upper edge of last alpha-bin 

        """
        return _libBornAgainCore.GISASSimulation_setDetectorParameters(self, n_phi, phi_min, phi_max, n_alpha, alpha_min, alpha_max)


    def removeMasks(self):
        """
        removeMasks(GISASSimulation self)

        void GISASSimulation::removeMasks()

        removes all masks from the detector 

        """
        return _libBornAgainCore.GISASSimulation_removeMasks(self)


    def addMask(self, shape, mask_value=True):
        """
        addMask(GISASSimulation self, IShape2D shape, bool mask_value=True)
        addMask(GISASSimulation self, IShape2D shape)

        void GISASSimulation::addMask(const Geometry::IShape2D &shape, bool mask_value=true)

        Adds mask of given shape to the stack of detector masks. The mask value 'true' means that the channel will be excluded from the simulation. The mask which is added last has priority.

        Parameters:
        -----------

        shape: 
        The shape of mask (Rectangle, Polygon, Line, Ellipse)

        mask_value: 
        The value of mask 

        """
        return _libBornAgainCore.GISASSimulation_addMask(self, shape, mask_value)


    def maskAll(self):
        """
        maskAll(GISASSimulation self)

        void GISASSimulation::maskAll()

        Put the mask for all detector channels (i.e. exclude whole detector from the analysis) 

        """
        return _libBornAgainCore.GISASSimulation_maskAll(self)


    def setRegionOfInterest(self, xlow, ylow, xup, yup):
        """
        setRegionOfInterest(GISASSimulation self, double xlow, double ylow, double xup, double yup)

        void GISASSimulation::setRegionOfInterest(double xlow, double ylow, double xup, double yup)

        Sets rectangular region of interest with lower left and upper right corners defined. 

        """
        return _libBornAgainCore.GISASSimulation_setRegionOfInterest(self, xlow, ylow, xup, yup)


    def resetRegionOfInterest(self):
        """
        resetRegionOfInterest(GISASSimulation self)

        void GISASSimulation::resetRegionOfInterest()

        Resets region of interest making whole detector plane available for the simulation. 

        """
        return _libBornAgainCore.GISASSimulation_resetRegionOfInterest(self)

GISASSimulation_swigregister = _libBornAgainCore.GISASSimulation_swigregister
GISASSimulation_swigregister(GISASSimulation)

class IHistogram(_object):
    """


    Base class for 1D and 2D histograms holding values of double type.

    C++ includes: IHistogram.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IHistogram, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IHistogram, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    INTEGRAL = _libBornAgainCore.IHistogram_INTEGRAL
    AVERAGE = _libBornAgainCore.IHistogram_AVERAGE
    STANDARD_ERROR = _libBornAgainCore.IHistogram_STANDARD_ERROR
    NENTRIES = _libBornAgainCore.IHistogram_NENTRIES
    __swig_destroy__ = _libBornAgainCore.delete_IHistogram
    __del__ = lambda self: None

    def clone(self):
        """
        clone(IHistogram self) -> IHistogram

        virtual IHistogram* IHistogram::clone() const =0

        """
        return _libBornAgainCore.IHistogram_clone(self)


    def getRank(self):
        """
        getRank(IHistogram self) -> size_t

        virtual size_t IHistogram::getRank() const =0

        Returns number of histogram dimensions. 

        """
        return _libBornAgainCore.IHistogram_getRank(self)


    def getTotalNumberOfBins(self):
        """
        getTotalNumberOfBins(IHistogram self) -> size_t

        size_t IHistogram::getTotalNumberOfBins() const

        Returns total number of histogram bins. For 2D histograms the result will be the product of bin numbers along X and Y axes. 

        """
        return _libBornAgainCore.IHistogram_getTotalNumberOfBins(self)


    def getXaxis(self):
        """
        getXaxis(IHistogram self) -> IAxis

        const IAxis & IHistogram::getXaxis() const

        returns x-axis 

        """
        return _libBornAgainCore.IHistogram_getXaxis(self)


    def getYaxis(self):
        """
        getYaxis(IHistogram self) -> IAxis

        const IAxis & IHistogram::getYaxis() const

        returns y-axis for 2D histograms 

        """
        return _libBornAgainCore.IHistogram_getYaxis(self)


    def getXmin(self):
        """
        getXmin(IHistogram self) -> double

        double IHistogram::getXmin() const

        Returns x-axis min (lower edge of first bin). 

        """
        return _libBornAgainCore.IHistogram_getXmin(self)


    def getXmax(self):
        """
        getXmax(IHistogram self) -> double

        double IHistogram::getXmax() const

        Returns x-axis max (upper edge of last bin). 

        """
        return _libBornAgainCore.IHistogram_getXmax(self)


    def getNbinsX(self):
        """
        getNbinsX(IHistogram self) -> size_t

        size_t IHistogram::getNbinsX() const

        Returns number of bins on x-axis. 

        """
        return _libBornAgainCore.IHistogram_getNbinsX(self)


    def getYmin(self):
        """
        getYmin(IHistogram self) -> double

        double IHistogram::getYmin() const

        Returns y-axis min (lower edge of first bin) for 2D histograms. 

        """
        return _libBornAgainCore.IHistogram_getYmin(self)


    def getYmax(self):
        """
        getYmax(IHistogram self) -> double

        double IHistogram::getYmax() const

        Returns y-axis max (upper edge of last bin) for 2D histograms. 

        """
        return _libBornAgainCore.IHistogram_getYmax(self)


    def getNbinsY(self):
        """
        getNbinsY(IHistogram self) -> size_t

        size_t IHistogram::getNbinsY() const

        Returns number of bins on y-axis. 

        """
        return _libBornAgainCore.IHistogram_getNbinsY(self)


    def getGlobalBin(self, binx, biny=0):
        """
        getGlobalBin(IHistogram self, size_t binx, size_t biny=0) -> size_t
        getGlobalBin(IHistogram self, size_t binx) -> size_t

        size_t IHistogram::getGlobalBin(size_t binx, size_t biny=0) const

        Returns global bin index for given axes indices. For 1D histogram the global bin index coinside with x-axis index.

        Parameters:
        -----------

        binx: 
        x-axis bin index

        biny: 
        y-axis bin index (for 2D histograms)

        The global bin index 

        """
        return _libBornAgainCore.IHistogram_getGlobalBin(self, binx, biny)


    def findGlobalBin(self, x, y):
        """
        findGlobalBin(IHistogram self, double x, double y) -> size_t

        size_t IHistogram::findGlobalBin(double x, double y) const

        Returns closest global bin index for given axes coordinates. For 1D.

        Parameters:
        -----------

        x: 
        Value on x-axis

        y: 
        Value on y-axis (for 2D histograms)

        Closest global bin index 

        """
        return _libBornAgainCore.IHistogram_findGlobalBin(self, x, y)


    def getXaxisIndex(self, i):
        """
        getXaxisIndex(IHistogram self, size_t i) -> int

        int IHistogram::getXaxisIndex(size_t i) const

        Returns x-axis bin index for given globalbin. For 1D histograms returned value conicide with globalbin value. 

        """
        return _libBornAgainCore.IHistogram_getXaxisIndex(self, i)


    def getYaxisIndex(self, i):
        """
        getYaxisIndex(IHistogram self, size_t i) -> int

        int IHistogram::getYaxisIndex(size_t i) const

        Returns y-axis bin index for given globalbin (for 2D histograms). 

        """
        return _libBornAgainCore.IHistogram_getYaxisIndex(self, i)


    def getXaxisValue(self, i):
        """
        getXaxisValue(IHistogram self, size_t i) -> double

        double IHistogram::getXaxisValue(size_t i)

        Returns the value on x-axis corresponding to the global bin index.

        Parameters:
        -----------

        globalbin: 
        The global bin index

        The center of corresponding bin of the axis 

        """
        return _libBornAgainCore.IHistogram_getXaxisValue(self, i)


    def getYaxisValue(self, i):
        """
        getYaxisValue(IHistogram self, size_t i) -> double

        double IHistogram::getYaxisValue(size_t i)

        Returns the value on y-axis corresponding to the 2D histogram global bin index.

        Parameters:
        -----------

        globalbin: 
        The global bin index

        The center of corresponding bin of the axis 

        """
        return _libBornAgainCore.IHistogram_getYaxisValue(self, i)


    def getData(self, *args):
        """
        getData(IHistogram self) -> OutputData< CumulativeValue > const
        getData(IHistogram self) -> OutputData< CumulativeValue > &

        OutputData<CumulativeValue>& IHistogram::getData()

        """
        return _libBornAgainCore.IHistogram_getData(self, *args)


    def getBinContent(self, *args):
        """
        getBinContent(IHistogram self, size_t i) -> double
        getBinContent(IHistogram self, size_t binx, size_t biny) -> double

        double IHistogram::getBinContent(size_t binx, size_t biny) const

        Returns content (accumulated value) of the 2D histogram bin with given indices.

        Parameters:
        -----------

        binx: 
        x-axis bin index

        biny: 
        y-axis bin index

        The value accumulated by the bin (integral) 

        """
        return _libBornAgainCore.IHistogram_getBinContent(self, *args)


    def setBinContent(self, i, value):
        """
        setBinContent(IHistogram self, size_t i, double value)

        void IHistogram::setBinContent(size_t i, double value)

        Sets content of the bin corresponding to the globalbin number. 

        """
        return _libBornAgainCore.IHistogram_setBinContent(self, i, value)


    def addBinContent(self, i, value):
        """
        addBinContent(IHistogram self, size_t i, double value)

        void IHistogram::addBinContent(size_t i, double value)

        Add the value to the bin. 

        """
        return _libBornAgainCore.IHistogram_addBinContent(self, i, value)


    def getBinError(self, *args):
        """
        getBinError(IHistogram self, size_t i) -> double
        getBinError(IHistogram self, size_t binx, size_t biny) -> double

        double IHistogram::getBinError(size_t binx, size_t biny) const

        Returns error of the bin with given indices (for 2D histograms). 

        """
        return _libBornAgainCore.IHistogram_getBinError(self, *args)


    def getBinAverage(self, *args):
        """
        getBinAverage(IHistogram self, size_t i) -> double
        getBinAverage(IHistogram self, size_t binx, size_t biny) -> double

        double IHistogram::getBinAverage(size_t binx, size_t biny) const

        Returns average value of the bin with given indices (for 2D histograms). 

        """
        return _libBornAgainCore.IHistogram_getBinAverage(self, *args)


    def getBinNumberOfEntries(self, *args):
        """
        getBinNumberOfEntries(IHistogram self, size_t i) -> int
        getBinNumberOfEntries(IHistogram self, size_t binx, size_t biny) -> int

        int IHistogram::getBinNumberOfEntries(size_t binx, size_t biny) const

        Returns number of entries in the bin with given indices (for 2D histograms). 

        """
        return _libBornAgainCore.IHistogram_getBinNumberOfEntries(self, *args)


    def getMaximum(self):
        """
        getMaximum(IHistogram self) -> double

        double IHistogram::getMaximum() const

        Returns histogram maximum value (maximum of  getBinContent() over all bins) 

        """
        return _libBornAgainCore.IHistogram_getMaximum(self)


    def getMaximumBinIndex(self):
        """
        getMaximumBinIndex(IHistogram self) -> size_t

        size_t IHistogram::getMaximumBinIndex() const

        Returns globalbin index with maximum content. 

        """
        return _libBornAgainCore.IHistogram_getMaximumBinIndex(self)


    def getMinimum(self):
        """
        getMinimum(IHistogram self) -> double

        double IHistogram::getMinimum() const

        Returns histogram minimum value (minimum of  getBinContent() over all bins) 

        """
        return _libBornAgainCore.IHistogram_getMinimum(self)


    def getMinimumBinIndex(self):
        """
        getMinimumBinIndex(IHistogram self) -> size_t

        size_t IHistogram::getMinimumBinIndex() const

        Returns globalbin index with minimum content. 

        """
        return _libBornAgainCore.IHistogram_getMinimumBinIndex(self)


    def scale(self, value):
        """
        scale(IHistogram self, double value)

        void IHistogram::scale(double value)

        Multiply this histogram (every bin content value) by a constant. 

        """
        return _libBornAgainCore.IHistogram_scale(self, value)


    def integral(self):
        """
        integral(IHistogram self) -> double

        double IHistogram::integral() const

        Returns integral of bins content (computed as a sum of all bin content). 

        """
        return _libBornAgainCore.IHistogram_integral(self)


    def getArray(self, *args):
        """
        getArray(IHistogram self, IHistogram::DataType dataType) -> PyObject
        getArray(IHistogram self) -> PyObject *
        """
        return _libBornAgainCore.IHistogram_getArray(self, *args)


    def reset(self):
        """
        reset(IHistogram self)

        void IHistogram::reset()

        Reset histogram content (axes remains) 

        """
        return _libBornAgainCore.IHistogram_reset(self)


    def createHistogram(source):
        """createHistogram(IntensityData source) -> IHistogram"""
        return _libBornAgainCore.IHistogram_createHistogram(source)

    if _newclass:
        createHistogram = staticmethod(createHistogram)
    __swig_getmethods__["createHistogram"] = lambda x: createHistogram

    def createFrom(*args):
        """
        createFrom(std::string const & filename) -> IHistogram
        createFrom(vdouble2d_t data) -> IHistogram
        """
        return _libBornAgainCore.IHistogram_createFrom(*args)

    if _newclass:
        createFrom = staticmethod(createFrom)
    __swig_getmethods__["createFrom"] = lambda x: createFrom

    def createOutputData(self, *args):
        """
        createOutputData(IHistogram self, IHistogram::DataType dataType) -> IntensityData
        createOutputData(IHistogram self) -> IntensityData

        OutputData< double > * IHistogram::createOutputData(DataType dataType=DataType::INTEGRAL) const

        creates new  OutputData with histogram's shape and values corresponding to DataType

        creates new  OutputData with histogram's shape and put there values corresponding to DataType 

        """
        return _libBornAgainCore.IHistogram_createOutputData(self, *args)


    def hasSameShape(self, other):
        """
        hasSameShape(IHistogram self, IHistogram other) -> bool

        bool IHistogram::hasSameShape(const IHistogram &other) const

        Returns true if objects a) have same dimensions b) bin boundaries of axes coincide. 

        """
        return _libBornAgainCore.IHistogram_hasSameShape(self, other)


    def hasSameDimensions(self, other):
        """
        hasSameDimensions(IHistogram self, IHistogram other) -> bool

        bool IHistogram::hasSameDimensions(const IHistogram &other) const

        Returns true if object have same rank and number of axes bins. 

        """
        return _libBornAgainCore.IHistogram_hasSameDimensions(self, other)


    def __iadd__(self, right):
        """__iadd__(IHistogram self, IHistogram right) -> IHistogram"""
        return _libBornAgainCore.IHistogram___iadd__(self, right)


    def relativeDifferenceHistogram(self, rhs):
        """
        relativeDifferenceHistogram(IHistogram self, IHistogram rhs) -> IHistogram

        IHistogram * IHistogram::relativeDifferenceHistogram(const IHistogram &rhs)

        returns histogram representing relative difference of two histograms. 

        """
        return _libBornAgainCore.IHistogram_relativeDifferenceHistogram(self, rhs)


    def save(self, filename):
        """
        save(IHistogram self, std::string const & filename)

        void IHistogram::save(const std::string &filename)

        Saves histogram in file Following formats are available: *.txt, *.tif, *.int (*.txt.gz, *.tif.gz, *.int.gz) 

        """
        return _libBornAgainCore.IHistogram_save(self, filename)


    def load(self, filename):
        """
        load(IHistogram self, std::string const & filename)

        void IHistogram::load(const std::string &filename)

        Loads histogram from file, the shape of array in file should match Following formats are available: *.txt, *.tif, *.int (*.txt.gz, *.tif.gz, *.int.gz) Only bin content will be loaded, histogram axes remain the same. 

        """
        return _libBornAgainCore.IHistogram_load(self, filename)

IHistogram_swigregister = _libBornAgainCore.IHistogram_swigregister
IHistogram_swigregister(IHistogram)

def IHistogram_createHistogram(source):
    """IHistogram_createHistogram(IntensityData source) -> IHistogram"""
    return _libBornAgainCore.IHistogram_createHistogram(source)

def IHistogram_createFrom(*args):
    """
    createFrom(std::string const & filename) -> IHistogram
    IHistogram_createFrom(vdouble2d_t data) -> IHistogram
    """
    return _libBornAgainCore.IHistogram_createFrom(*args)

class Histogram1D(IHistogram):
    """Proxy of C++ Histogram1D class."""

    __swig_setmethods__ = {}
    for _s in [IHistogram]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Histogram1D, name, value)
    __swig_getmethods__ = {}
    for _s in [IHistogram]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Histogram1D, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Histogram1D self, int nbinsx, double xlow, double xup) -> Histogram1D
        __init__(Histogram1D self, int nbinsx, vdouble1d_t xbins) -> Histogram1D
        __init__(Histogram1D self, IAxis axis) -> Histogram1D
        __init__(Histogram1D self, IntensityData data) -> Histogram1D

        Histogram1D::Histogram1D(const OutputData< double > &data)

        Constructor for 1D histograms from basic  OutputData object. 

        """
        this = _libBornAgainCore.new_Histogram1D(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(Histogram1D self) -> Histogram1D

        Histogram1D * Histogram1D::clone() const

        Returns clone of other histogram. 

        """
        return _libBornAgainCore.Histogram1D_clone(self)


    def getRank(self):
        """
        getRank(Histogram1D self) -> size_t

        size_t Histogram1D::getRank() const

        Returns the number of histogram dimensions. 

        """
        return _libBornAgainCore.Histogram1D_getRank(self)


    def fill(self, x, weight=1.0):
        """
        fill(Histogram1D self, double x, double weight=1.0) -> int
        fill(Histogram1D self, double x) -> int

        int Histogram1D::fill(double x, double weight=1.0)

        Increment bin with abscissa x with a weight. 

        """
        return _libBornAgainCore.Histogram1D_fill(self, x, weight)


    def getBinCenters(self):
        """
        getBinCenters(Histogram1D self) -> vdouble1d_t

        std::vector< double > Histogram1D::getBinCenters() const

        returns vector of histogram bin centers 

        """
        return self.getBinCentersNumpy()


    def getBinValues(self):
        """
        getBinValues(Histogram1D self) -> vdouble1d_t

        std::vector< double > Histogram1D::getBinValues() const

        returns vector of bin content (the value accumulated by bins) 

        """
        return self.getBinValuesNumpy()


    def getBinErrors(self):
        """
        getBinErrors(Histogram1D self) -> vdouble1d_t

        std::vector< double > Histogram1D::getBinErrors() const

        returns vector of bin errors 

        """
        return self.getBinErrorsNumpy()


    def getBinCentersNumpy(self):
        """getBinCentersNumpy(Histogram1D self) -> PyObject *"""
        return _libBornAgainCore.Histogram1D_getBinCentersNumpy(self)


    def getBinValuesNumpy(self):
        """getBinValuesNumpy(Histogram1D self) -> PyObject *"""
        return _libBornAgainCore.Histogram1D_getBinValuesNumpy(self)


    def getBinErrorsNumpy(self):
        """getBinErrorsNumpy(Histogram1D self) -> PyObject *"""
        return _libBornAgainCore.Histogram1D_getBinErrorsNumpy(self)


    def crop(self, xmin, xmax):
        """
        crop(Histogram1D self, double xmin, double xmax) -> Histogram1D

        Histogram1D * Histogram1D::crop(double xmin, double xmax)

        Create new histogram by applying crop on axis. 

        """
        return _libBornAgainCore.Histogram1D_crop(self, xmin, xmax)


    def dynamicCast(pHistogram):
        """dynamicCast(IHistogram pHistogram) -> Histogram1D"""
        return _libBornAgainCore.Histogram1D_dynamicCast(pHistogram)

    if _newclass:
        dynamicCast = staticmethod(dynamicCast)
    __swig_getmethods__["dynamicCast"] = lambda x: dynamicCast
    __swig_destroy__ = _libBornAgainCore.delete_Histogram1D
    __del__ = lambda self: None
Histogram1D_swigregister = _libBornAgainCore.Histogram1D_swigregister
Histogram1D_swigregister(Histogram1D)

def Histogram1D_dynamicCast(pHistogram):
    """Histogram1D_dynamicCast(IHistogram pHistogram) -> Histogram1D"""
    return _libBornAgainCore.Histogram1D_dynamicCast(pHistogram)

class Histogram2D(IHistogram):
    """


    Two dimensional histogram.

    C++ includes: Histogram2D.h

    """

    __swig_setmethods__ = {}
    for _s in [IHistogram]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Histogram2D, name, value)
    __swig_getmethods__ = {}
    for _s in [IHistogram]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Histogram2D, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Histogram2D self, int nbinsx, double xlow, double xup, int nbinsy, double ylow, double yup) -> Histogram2D
        __init__(Histogram2D self, int nbinsx, vdouble1d_t xbins, int nbinsy, vdouble1d_t ybins) -> Histogram2D
        __init__(Histogram2D self, IAxis axis_x, IAxis axis_y) -> Histogram2D
        __init__(Histogram2D self, IntensityData data) -> Histogram2D
        __init__(Histogram2D self, vdouble2d_t data) -> Histogram2D

        Histogram2D::Histogram2D(const std::vector< std::vector< double >> &data)

        Constructor for 2D histograms from numpy array (thanks to swig) 

        """
        this = _libBornAgainCore.new_Histogram2D(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(Histogram2D self) -> Histogram2D

        Histogram2D * Histogram2D::clone() const

        Returns clone of other histogram. 

        """
        return _libBornAgainCore.Histogram2D_clone(self)


    def getRank(self):
        """
        getRank(Histogram2D self) -> size_t

        size_t Histogram2D::getRank() const

        Returns the number of histogram dimensions. 

        """
        return _libBornAgainCore.Histogram2D_getRank(self)


    def fill(self, x, y, weight=1.0):
        """
        fill(Histogram2D self, double x, double y, double weight=1.0) -> int
        fill(Histogram2D self, double x, double y) -> int

        int Histogram2D::fill(double x, double y, double weight=1.0)

        Increment bin with abscissa x and ordinate y with a weight. 

        """
        return _libBornAgainCore.Histogram2D_fill(self, x, y, weight)


    def projectionX(self, *args):
        """
        projectionX(Histogram2D self) -> Histogram1D
        projectionX(Histogram2D self, double yvalue) -> Histogram1D
        projectionX(Histogram2D self, double ylow, double yup) -> Histogram1D

        Histogram1D * Histogram2D::projectionX(double ylow, double yup)

        Project a 2D histogram into 1D histogram along X. The projection is made from all y-bins corresponding to ordinate between ylow and yup.

        Parameters:
        -----------

        ylow: 
        lower edje on y-axis

        yup: 
        upper edje on y-axis 

        """
        return _libBornAgainCore.Histogram2D_projectionX(self, *args)


    def projectionY(self, *args):
        """
        projectionY(Histogram2D self) -> Histogram1D
        projectionY(Histogram2D self, double xvalue) -> Histogram1D
        projectionY(Histogram2D self, double xlow, double xup) -> Histogram1D

        Histogram1D * Histogram2D::projectionY(double xlow, double xup)

        Project a 2D histogram into 1D histogram along Y. The projection is made from all x-bins corresponding to abscissa between xlow and xup.

        Parameters:
        -----------

        xlow: 
        lower edje on x-axis

        xup: 
        upper edje on x-axis 

        """
        return _libBornAgainCore.Histogram2D_projectionY(self, *args)


    def crop(self, xmin, ymin, xmax, ymax):
        """
        crop(Histogram2D self, double xmin, double ymin, double xmax, double ymax) -> Histogram2D

        Histogram2D * Histogram2D::crop(double xmin, double ymin, double xmax, double ymax)

        Create new histogram by applying rectangular clip. 

        """
        return _libBornAgainCore.Histogram2D_crop(self, xmin, ymin, xmax, ymax)


    def setContent(self, data):
        """
        setContent(Histogram2D self, vdouble2d_t data)

        void Histogram2D::setContent(const std::vector< std::vector< double >> &data)

        Sets the values in histograms channels from numpy array,. 

        """
        return _libBornAgainCore.Histogram2D_setContent(self, data)


    def addContent(self, data):
        """
        addContent(Histogram2D self, vdouble2d_t data)

        void Histogram2D::addContent(const std::vector< std::vector< double >> &data)

        Add to values in histograms channels from numpy array,. 

        """
        return _libBornAgainCore.Histogram2D_addContent(self, data)


    def dynamicCast(pHistogram):
        """dynamicCast(IHistogram pHistogram) -> Histogram2D"""
        return _libBornAgainCore.Histogram2D_dynamicCast(pHistogram)

    if _newclass:
        dynamicCast = staticmethod(dynamicCast)
    __swig_getmethods__["dynamicCast"] = lambda x: dynamicCast
    __swig_destroy__ = _libBornAgainCore.delete_Histogram2D
    __del__ = lambda self: None
Histogram2D_swigregister = _libBornAgainCore.Histogram2D_swigregister
Histogram2D_swigregister(Histogram2D)

def Histogram2D_dynamicCast(pHistogram):
    """Histogram2D_dynamicCast(IHistogram pHistogram) -> Histogram2D"""
    return _libBornAgainCore.Histogram2D_dynamicCast(pHistogram)

class IMaterial(INamed):
    """


    Interface to a named material.

    C++ includes: IMaterial.h

    """

    __swig_setmethods__ = {}
    for _s in [INamed]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IMaterial, name, value)
    __swig_getmethods__ = {}
    for _s in [INamed]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IMaterial, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_IMaterial
    __del__ = lambda self: None

    def clone(self):
        """
        clone(IMaterial self) -> IMaterial

        IMaterial * IMaterial::clone() const

        """
        return _libBornAgainCore.IMaterial_clone(self)


    def cloneInverted(self):
        """cloneInverted(IMaterial self) -> IMaterial"""
        return _libBornAgainCore.IMaterial_cloneInverted(self)


    def isScalarMaterial(self):
        """
        isScalarMaterial(IMaterial self) -> bool

        virtual bool IMaterial::isScalarMaterial() const

        Indicates whether the interaction with the material is scalar. This means that different polarization states will be diffracted equally 

        """
        return _libBornAgainCore.IMaterial_isScalarMaterial(self)


    def isMagneticMaterial(self):
        """
        isMagneticMaterial(IMaterial self) -> bool

        bool IMaterial::isMagneticMaterial() const

        """
        return _libBornAgainCore.IMaterial_isMagneticMaterial(self)


    def getRefractiveIndex(self):
        """
        getRefractiveIndex(IMaterial self) -> complex_t

        virtual complex_t IMaterial::getRefractiveIndex() const

        """
        return _libBornAgainCore.IMaterial_getRefractiveIndex(self)


    def createTransformedMaterial(self, transform):
        """
        createTransformedMaterial(IMaterial self, Transform3D const & transform) -> IMaterial

        virtual const IMaterial* IMaterial::createTransformedMaterial(const Transform3D &transform) const =0

        Create a new material that is transformed with respect to this one. 

        """
        return _libBornAgainCore.IMaterial_createTransformedMaterial(self, transform)


    def __eq__(self, other):
        """__eq__(IMaterial self, IMaterial other) -> bool"""
        return _libBornAgainCore.IMaterial___eq__(self, other)

IMaterial_swigregister = _libBornAgainCore.IMaterial_swigregister
IMaterial_swigregister(IMaterial)

class HomogeneousMaterial(IMaterial):
    """


    An homogeneous material with a refractive index.

    C++ includes: HomogeneousMaterial.h

    """

    __swig_setmethods__ = {}
    for _s in [IMaterial]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HomogeneousMaterial, name, value)
    __swig_getmethods__ = {}
    for _s in [IMaterial]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HomogeneousMaterial, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HomogeneousMaterial self, std::string const & name, complex_t const refractive_index) -> HomogeneousMaterial
        __init__(HomogeneousMaterial self, std::string const & name, double refractive_index_delta, double refractive_index_beta) -> HomogeneousMaterial

        HomogeneousMaterial::HomogeneousMaterial(const std::string &name, double refractive_index_delta, double refractive_index_beta)

        Constructs a material with  name and refractive_index parameters delta and beta (n = 1 - delta + i*beta). 

        """
        this = _libBornAgainCore.new_HomogeneousMaterial(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_HomogeneousMaterial
    __del__ = lambda self: None

    def clone(self):
        """
        clone(HomogeneousMaterial self) -> HomogeneousMaterial

        virtual HomogeneousMaterial* HomogeneousMaterial::clone() const

        """
        return _libBornAgainCore.HomogeneousMaterial_clone(self)


    def cloneInverted(self):
        """cloneInverted(HomogeneousMaterial self) -> HomogeneousMaterial"""
        return _libBornAgainCore.HomogeneousMaterial_cloneInverted(self)


    def getRefractiveIndex(self):
        """
        getRefractiveIndex(HomogeneousMaterial self) -> complex_t

        virtual complex_t HomogeneousMaterial::getRefractiveIndex() const

        """
        return _libBornAgainCore.HomogeneousMaterial_getRefractiveIndex(self)


    def setRefractiveIndex(self, refractive_index):
        """
        setRefractiveIndex(HomogeneousMaterial self, complex_t const refractive_index)

        void HomogeneousMaterial::setRefractiveIndex(const complex_t refractive_index)

        """
        return _libBornAgainCore.HomogeneousMaterial_setRefractiveIndex(self, refractive_index)


    def createTransformedMaterial(self, arg2):
        """
        createTransformedMaterial(HomogeneousMaterial self, Transform3D const & arg2) -> IMaterial

        virtual const IMaterial* HomogeneousMaterial::createTransformedMaterial(const Transform3D &) const

        Create a new material that is transformed with respect to this one. 

        """
        return _libBornAgainCore.HomogeneousMaterial_createTransformedMaterial(self, arg2)

HomogeneousMaterial_swigregister = _libBornAgainCore.HomogeneousMaterial_swigregister
HomogeneousMaterial_swigregister(HomogeneousMaterial)

class HomogeneousMagneticMaterial(HomogeneousMaterial):
    """


    A homogeneous material with magnetization.

    C++ includes: HomogeneousMagneticMaterial.h

    """

    __swig_setmethods__ = {}
    for _s in [HomogeneousMaterial]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HomogeneousMagneticMaterial, name, value)
    __swig_getmethods__ = {}
    for _s in [HomogeneousMaterial]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HomogeneousMagneticMaterial, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(HomogeneousMagneticMaterial self, std::string const & name, complex_t const refractive_index, kvector_t magnetic_field) -> HomogeneousMagneticMaterial
        __init__(HomogeneousMagneticMaterial self, std::string const & name, double refractive_index_delta, double refractive_index_beta, kvector_t magnetic_field) -> HomogeneousMagneticMaterial

        HomogeneousMagneticMaterial::HomogeneousMagneticMaterial(const std::string &name, double refractive_index_delta, double refractive_index_beta, const kvector_t magnetic_field)

        Constructs a material with  name, refractive_index parameters and  magnetic_field

        """
        this = _libBornAgainCore.new_HomogeneousMagneticMaterial(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(HomogeneousMagneticMaterial self) -> HomogeneousMagneticMaterial

        HomogeneousMagneticMaterial * HomogeneousMagneticMaterial::clone() const

        Clone. 

        """
        return _libBornAgainCore.HomogeneousMagneticMaterial_clone(self)


    def cloneInverted(self):
        """cloneInverted(HomogeneousMagneticMaterial self) -> HomogeneousMagneticMaterial"""
        return _libBornAgainCore.HomogeneousMagneticMaterial_cloneInverted(self)


    def getMagneticField(self):
        """
        getMagneticField(HomogeneousMagneticMaterial self) -> kvector_t

        kvector_t HomogeneousMagneticMaterial::getMagneticField() const

        Get the magnetic field (in Tesla) 

        """
        return _libBornAgainCore.HomogeneousMagneticMaterial_getMagneticField(self)


    def setMagneticField(self, magnetic_field):
        """
        setMagneticField(HomogeneousMagneticMaterial self, kvector_t magnetic_field)

        void HomogeneousMagneticMaterial::setMagneticField(const kvector_t magnetic_field)

        Set the magnetic field (in Tesla) 

        """
        return _libBornAgainCore.HomogeneousMagneticMaterial_setMagneticField(self, magnetic_field)


    def isScalarMaterial(self):
        """
        isScalarMaterial(HomogeneousMagneticMaterial self) -> bool

        virtual bool HomogeneousMagneticMaterial::isScalarMaterial() const

        Indicates that the material is not scalar. This means that different polarization states will be diffracted differently 

        """
        return _libBornAgainCore.HomogeneousMagneticMaterial_isScalarMaterial(self)


    def createTransformedMaterial(self, transform):
        """
        createTransformedMaterial(HomogeneousMagneticMaterial self, Transform3D const & transform) -> IMaterial

        const IMaterial * HomogeneousMagneticMaterial::createTransformedMaterial(const Transform3D &transform) const

        Create a new material that is transformed with respect to this one. 

        """
        return _libBornAgainCore.HomogeneousMagneticMaterial_createTransformedMaterial(self, transform)

    __swig_destroy__ = _libBornAgainCore.delete_HomogeneousMagneticMaterial
    __del__ = lambda self: None
HomogeneousMagneticMaterial_swigregister = _libBornAgainCore.HomogeneousMagneticMaterial_swigregister
HomogeneousMagneticMaterial_swigregister(HomogeneousMagneticMaterial)

class IDetector2D(ICloneable, IParameterized):
    """Proxy of C++ IDetector2D class."""

    __swig_setmethods__ = {}
    for _s in [ICloneable, IParameterized]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IDetector2D, name, value)
    __swig_getmethods__ = {}
    for _s in [ICloneable, IParameterized]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IDetector2D, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    DEFAULT = _libBornAgainCore.IDetector2D_DEFAULT
    NBINS = _libBornAgainCore.IDetector2D_NBINS
    RADIANS = _libBornAgainCore.IDetector2D_RADIANS
    DEGREES = _libBornAgainCore.IDetector2D_DEGREES
    MM = _libBornAgainCore.IDetector2D_MM
    QYQZ = _libBornAgainCore.IDetector2D_QYQZ

    def clone(self):
        """
        clone(IDetector2D self) -> IDetector2D

        virtual IDetector2D* IDetector2D::clone() const =0

        """
        return _libBornAgainCore.IDetector2D_clone(self)

    __swig_destroy__ = _libBornAgainCore.delete_IDetector2D
    __del__ = lambda self: None

    def init(self, arg2):
        """
        init(IDetector2D self, Beam arg2)

        virtual void IDetector2D::init(const Beam &)

        Inits detector with the beam settings. 

        """
        return _libBornAgainCore.IDetector2D_init(self, arg2)


    def addAxis(self, axis):
        """
        addAxis(IDetector2D self, IAxis axis)

        void IDetector2D::addAxis(const IAxis &axis)

        """
        return _libBornAgainCore.IDetector2D_addAxis(self, axis)


    def getAxis(self, index):
        """
        getAxis(IDetector2D self, size_t index) -> IAxis

        const IAxis & IDetector2D::getAxis(size_t index) const

        """
        return _libBornAgainCore.IDetector2D_getAxis(self, index)


    def getDimension(self):
        """
        getDimension(IDetector2D self) -> size_t

        size_t IDetector2D::getDimension() const

        """
        return _libBornAgainCore.IDetector2D_getDimension(self)


    def clear(self):
        """
        clear(IDetector2D self)

        void IDetector2D::clear()

        """
        return _libBornAgainCore.IDetector2D_clear(self)


    def setDetectorParameters(self, n_x, x_min, x_max, n_y, y_min, y_max):
        """
        setDetectorParameters(IDetector2D self, size_t n_x, double x_min, double x_max, size_t n_y, double y_min, double y_max)

        void IDetector2D::setDetectorParameters(size_t n_x, double x_min, double x_max, size_t n_y, double y_min, double y_max)

        Sets detector parameters using angle ranges. 

        """
        return _libBornAgainCore.IDetector2D_setDetectorParameters(self, n_x, x_min, x_max, n_y, y_min, y_max)


    def setDetectorAxes(self, axis0, axis1):
        """
        setDetectorAxes(IDetector2D self, IAxis axis0, IAxis axis1)

        void IDetector2D::setDetectorAxes(const IAxis &axis0, const IAxis &axis1)

        Sets detector parameters using axes. 

        """
        return _libBornAgainCore.IDetector2D_setDetectorAxes(self, axis0, axis1)


    def setDetectorResolution(self, p_detector_resolution):
        """
        setDetectorResolution(IDetector2D self, IDetectorResolution p_detector_resolution)

        void IDetector2D::setDetectorResolution(IDetectorResolution *p_detector_resolution)

        Sets the detector resolution. 

        """
        return _libBornAgainCore.IDetector2D_setDetectorResolution(self, p_detector_resolution)


    def applyDetectorResolution(self, p_intensity_map):
        """
        applyDetectorResolution(IDetector2D self, IntensityData p_intensity_map)

        void IDetector2D::applyDetectorResolution(OutputData< double > *p_intensity_map) const

        Applies the detector resolution to the given intensity maps. 

        """
        return _libBornAgainCore.IDetector2D_applyDetectorResolution(self, p_intensity_map)


    def getDetectorResolutionFunction(self):
        """
        getDetectorResolutionFunction(IDetector2D self) -> IDetectorResolution

        const IDetectorResolution * IDetector2D::getDetectorResolutionFunction() const

        """
        return _libBornAgainCore.IDetector2D_getDetectorResolutionFunction(self)


    def setAnalyzerProperties(self, direction, efficiency, total_transmission):
        """
        setAnalyzerProperties(IDetector2D self, kvector_t direction, double efficiency, double total_transmission)

        void IDetector2D::setAnalyzerProperties(const kvector_t direction, double efficiency, double total_transmission)

        Sets the polarization analyzer characteristics of the detector. 

        """
        return _libBornAgainCore.IDetector2D_setAnalyzerProperties(self, direction, efficiency, total_transmission)


    def removeMasks(self):
        """
        removeMasks(IDetector2D self)

        void IDetector2D::removeMasks()

        removes all masks from the detector 

        """
        return _libBornAgainCore.IDetector2D_removeMasks(self)


    def addMask(self, shape, mask_value=True):
        """
        addMask(IDetector2D self, IShape2D shape, bool mask_value=True)
        addMask(IDetector2D self, IShape2D shape)

        void IDetector2D::addMask(const Geometry::IShape2D &shape, bool mask_value=true)

        Adds mask of given shape to the stack of detector masks. The mask value 'true' means that the channel will be excluded from the simulation. The mask which is added last has priority.

        Parameters:
        -----------

        shape: 
        The shape of mask (Rectangle, Polygon, Line, Ellipse)

        mask_value: 
        The value of mask 

        """
        return _libBornAgainCore.IDetector2D_addMask(self, shape, mask_value)


    def maskAll(self):
        """
        maskAll(IDetector2D self)

        void IDetector2D::maskAll()

        Put the mask for all detector channels (i.e. exclude whole detector from the analysis) 

        """
        return _libBornAgainCore.IDetector2D_maskAll(self)


    def getDetectorMask(self):
        """
        getDetectorMask(IDetector2D self) -> DetectorMask

        const DetectorMask * IDetector2D::getDetectorMask() const

        """
        return _libBornAgainCore.IDetector2D_getDetectorMask(self)


    def numberOfMaskedChannels(self):
        """
        numberOfMaskedChannels(IDetector2D self) -> size_t

        size_t IDetector2D::numberOfMaskedChannels() const

        """
        return _libBornAgainCore.IDetector2D_numberOfMaskedChannels(self)


    def isMasked(self, index):
        """
        isMasked(IDetector2D self, size_t index) -> bool

        bool IDetector2D::isMasked(size_t index) const

        """
        return _libBornAgainCore.IDetector2D_isMasked(self, index)


    def hasMasks(self):
        """
        hasMasks(IDetector2D self) -> bool

        bool IDetector2D::hasMasks() const

        return true if has masks 

        """
        return _libBornAgainCore.IDetector2D_hasMasks(self)


    def createDetectorIntensity(self, *args):
        """
        createDetectorIntensity(IDetector2D self, std::vector< SimulationElement,std::allocator< SimulationElement > > const & elements, Beam beam, IDetector2D::EAxesUnits units_type) -> IntensityData
        createDetectorIntensity(IDetector2D self, std::vector< SimulationElement,std::allocator< SimulationElement > > const & elements, Beam beam) -> IntensityData

        OutputData< double > * IDetector2D::createDetectorIntensity(const std::vector< SimulationElement > &elements, const Beam &beam, IDetector2D::EAxesUnits units_type=IDetector2D::DEFAULT) const

        Returns new intensity map with detector resolution applied and axes in requested units. 

        """
        return _libBornAgainCore.IDetector2D_createDetectorIntensity(self, *args)


    def createDetectorMap(self, beam, units):
        """
        createDetectorMap(IDetector2D self, Beam beam, IDetector2D::EAxesUnits units) -> IntensityData

        OutputData< double > * IDetector2D::createDetectorMap(const Beam &beam, EAxesUnits units) const

        Returns empty detector map in given axes units. 

        """
        return _libBornAgainCore.IDetector2D_createDetectorMap(self, beam, units)


    def initOutputData(self, data):
        """
        initOutputData(IDetector2D self, IntensityData data)

        void IDetector2D::initOutputData(OutputData< double > &data) const

        Inits axes of  OutputData to match the detector and sets values to zero. 

        """
        return _libBornAgainCore.IDetector2D_initOutputData(self, data)


    def getValidAxesUnits(self):
        """
        getValidAxesUnits(IDetector2D self) -> std::vector< IDetector2D::EAxesUnits,std::allocator< IDetector2D::EAxesUnits > >

        std::vector< IDetector2D::EAxesUnits > IDetector2D::getValidAxesUnits() const

        returns vector of valid axes units 

        """
        return _libBornAgainCore.IDetector2D_getValidAxesUnits(self)


    def getDefaultAxesUnits(self):
        """
        getDefaultAxesUnits(IDetector2D self) -> IDetector2D::EAxesUnits

        virtual EAxesUnits IDetector2D::getDefaultAxesUnits() const

        return default axes units 

        """
        return _libBornAgainCore.IDetector2D_getDefaultAxesUnits(self)


    def regionOfInterest(self):
        """
        regionOfInterest(IDetector2D self) -> RegionOfInterest const *

        const RegionOfInterest * IDetector2D::regionOfInterest() const

        Returns region of interest if exists. 

        """
        return _libBornAgainCore.IDetector2D_regionOfInterest(self)


    def setRegionOfInterest(self, xlow, ylow, xup, yup):
        """
        setRegionOfInterest(IDetector2D self, double xlow, double ylow, double xup, double yup)

        void IDetector2D::setRegionOfInterest(double xlow, double ylow, double xup, double yup)

        Sets rectangular region of interest with lower left and upper right corners defined. 

        """
        return _libBornAgainCore.IDetector2D_setRegionOfInterest(self, xlow, ylow, xup, yup)


    def resetRegionOfInterest(self):
        """
        resetRegionOfInterest(IDetector2D self)

        void IDetector2D::resetRegionOfInterest()

        Resets region of interest making whole detector plane available for the simulation. 

        """
        return _libBornAgainCore.IDetector2D_resetRegionOfInterest(self)


    def getTotalSize(self):
        """
        getTotalSize(IDetector2D self) -> size_t

        size_t IDetector2D::getTotalSize() const

        Returns total number of pixels. 

        """
        return _libBornAgainCore.IDetector2D_getTotalSize(self)


    def getAxisBinIndex(self, index, selected_axis):
        """
        getAxisBinIndex(IDetector2D self, size_t index, size_t selected_axis) -> size_t

        size_t IDetector2D::getAxisBinIndex(size_t index, size_t selected_axis) const

        Calculate axis index for given global index. 

        """
        return _libBornAgainCore.IDetector2D_getAxisBinIndex(self, index, selected_axis)


    def numberOfSimulationElements(self):
        """
        numberOfSimulationElements(IDetector2D self) -> size_t

        size_t IDetector2D::numberOfSimulationElements() const

        Returns number of simulation elements. 

        """
        return _libBornAgainCore.IDetector2D_numberOfSimulationElements(self)

IDetector2D_swigregister = _libBornAgainCore.IDetector2D_swigregister
IDetector2D_swigregister(IDetector2D)

class IDetectorResolution(ICloneable, IParameterized):
    """


    Interface for detector resolution algorithms.

    C++ includes: IDetectorResolution.h

    """

    __swig_setmethods__ = {}
    for _s in [ICloneable, IParameterized]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IDetectorResolution, name, value)
    __swig_getmethods__ = {}
    for _s in [ICloneable, IParameterized]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IDetectorResolution, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_IDetectorResolution
    __del__ = lambda self: None

    def applyDetectorResolution(self, p_intensity_map):
        """
        applyDetectorResolution(IDetectorResolution self, IntensityData p_intensity_map)

        virtual void IDetectorResolution::applyDetectorResolution(OutputData< double > *p_intensity_map) const =0

        Apply the resolution function to the intensity data. 

        """
        return _libBornAgainCore.IDetectorResolution_applyDetectorResolution(self, p_intensity_map)


    def clone(self):
        """
        clone(IDetectorResolution self) -> IDetectorResolution

        virtual IDetectorResolution* IDetectorResolution::clone() const =0

        """
        return _libBornAgainCore.IDetectorResolution_clone(self)

IDetectorResolution_swigregister = _libBornAgainCore.IDetectorResolution_swigregister
IDetectorResolution_swigregister(IDetectorResolution)

class IInterferenceFunction(ISample):
    """


    Pure virtual base class of interference functions.

    C++ includes: IInterferenceFunction.h

    """

    __swig_setmethods__ = {}
    for _s in [ISample]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IInterferenceFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [ISample]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IInterferenceFunction, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_IInterferenceFunction
    __del__ = lambda self: None

    def clone(self):
        """
        clone(IInterferenceFunction self) -> IInterferenceFunction

        virtual IInterferenceFunction* IInterferenceFunction::clone() const =0

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.IInterferenceFunction_clone(self)


    def accept(self, visitor):
        """
        accept(IInterferenceFunction self, ISampleVisitor visitor)

        virtual void IInterferenceFunction::accept(ISampleVisitor *visitor) const =0

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.IInterferenceFunction_accept(self, visitor)


    def evaluate(self, q):
        """
        evaluate(IInterferenceFunction self, kvector_t q) -> double

        virtual double IInterferenceFunction::evaluate(const kvector_t q) const =0

        Evaluates the interference function for a given wavevector transfer (only the real x and y components are relevant) 

        """
        return _libBornAgainCore.IInterferenceFunction_evaluate(self, q)


    def getKappa(self):
        """
        getKappa(IInterferenceFunction self) -> double

        virtual double IInterferenceFunction::getKappa() const

        Retrieves the size-distance coupling constant (default 0.0) 

        """
        return _libBornAgainCore.IInterferenceFunction_getKappa(self)


    def getParticleDensity(self):
        """
        getParticleDensity(IInterferenceFunction self) -> double

        virtual double IInterferenceFunction::getParticleDensity() const

        If defined by this interference function's parameters, returns the particle density (per area). Otherwise, returns zero or a user-defined value 

        """
        return _libBornAgainCore.IInterferenceFunction_getParticleDensity(self)

IInterferenceFunction_swigregister = _libBornAgainCore.IInterferenceFunction_swigregister
IInterferenceFunction_swigregister(IInterferenceFunction)

class ILayout(ICompositeSample):
    """


    Pure virtual interface class to equip a sample layer with scattering properties. Currently only inherited by  ParticleLayout; in the future also by domain structure.

    C++ includes: ILayout.h

    """

    __swig_setmethods__ = {}
    for _s in [ICompositeSample]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ILayout, name, value)
    __swig_getmethods__ = {}
    for _s in [ICompositeSample]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ILayout, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    DA = _libBornAgainCore.ILayout_DA
    SSCA = _libBornAgainCore.ILayout_SSCA
    __swig_destroy__ = _libBornAgainCore.delete_ILayout
    __del__ = lambda self: None

    def clone(self):
        """
        clone(ILayout self) -> ILayout

        virtual ILayout* ILayout::clone() const =0

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.ILayout_clone(self)


    def accept(self, visitor):
        """
        accept(ILayout self, ISampleVisitor visitor)

        virtual void ILayout::accept(ISampleVisitor *visitor) const =0

        calls the  ISampleVisitor's visit method 

        """
        return _libBornAgainCore.ILayout_accept(self, visitor)


    def cloneInvertB(self):
        """
        cloneInvertB(ILayout self) -> ILayout

        virtual ILayout* ILayout::cloneInvertB() const =0

        Returns a clone with inverted magnetic fields. 

        """
        return _libBornAgainCore.ILayout_cloneInvertB(self)


    def getNumberOfParticles(self):
        """
        getNumberOfParticles(ILayout self) -> size_t

        virtual size_t ILayout::getNumberOfParticles() const =0

        Returns number of particles. 

        """
        return _libBornAgainCore.ILayout_getNumberOfParticles(self)


    def getParticle(self, index):
        """
        getParticle(ILayout self, size_t index) -> IAbstractParticle

        virtual const IAbstractParticle* ILayout::getParticle(size_t index) const =0

        Returns information about particle with index. 

        """
        return _libBornAgainCore.ILayout_getParticle(self, index)


    def getParticles(self):
        """
        getParticles(ILayout self) -> SafePointerVector< IParticle const >

        virtual SafePointerVector<const IParticle> ILayout::getParticles() const =0

        Returns information on all particles (type and abundance) and generates new particles if an  IAbstractParticle denotes a collection 

        """
        return _libBornAgainCore.ILayout_getParticles(self)


    def getAbundanceOfParticle(self, index):
        """
        getAbundanceOfParticle(ILayout self, size_t index) -> double

        virtual double ILayout::getAbundanceOfParticle(size_t index) const =0

        Get abundance fraction of particle with index. 

        """
        return _libBornAgainCore.ILayout_getAbundanceOfParticle(self, index)


    def getTotalAbundance(self):
        """
        getTotalAbundance(ILayout self) -> double

        double ILayout::getTotalAbundance() const

        Get total abundance of all particles. 

        """
        return _libBornAgainCore.ILayout_getTotalAbundance(self)


    def getInterferenceFunction(self):
        """
        getInterferenceFunction(ILayout self) -> IInterferenceFunction

        virtual const IInterferenceFunction* ILayout::getInterferenceFunction() const =0

        Returns interference function. 

        """
        return _libBornAgainCore.ILayout_getInterferenceFunction(self)


    def cloneInterferenceFunction(self):
        """
        cloneInterferenceFunction(ILayout self) -> IInterferenceFunction

        virtual IInterferenceFunction* ILayout::cloneInterferenceFunction() const =0

        """
        return _libBornAgainCore.ILayout_cloneInterferenceFunction(self)


    def getTotalParticleSurfaceDensity(self):
        """
        getTotalParticleSurfaceDensity(ILayout self) -> double

        virtual double ILayout::getTotalParticleSurfaceDensity() const =0

        Returns surface density of all particles. 

        """
        return _libBornAgainCore.ILayout_getTotalParticleSurfaceDensity(self)


    def setTotalParticleSurfaceDensity(self, particle_density):
        """
        setTotalParticleSurfaceDensity(ILayout self, double particle_density)

        virtual void ILayout::setTotalParticleSurfaceDensity(double particle_density)=0

        Sets surface density of all particles. 

        """
        return _libBornAgainCore.ILayout_setTotalParticleSurfaceDensity(self, particle_density)


    def getApproximation(self):
        """
        getApproximation(ILayout self) -> ILayout::EInterferenceApproximation

        EInterferenceApproximation ILayout::getApproximation() const

        Gets the used approximation for particles and interference functions. 

        """
        return _libBornAgainCore.ILayout_getApproximation(self)


    def setApproximation(self, approximation):
        """
        setApproximation(ILayout self, ILayout::EInterferenceApproximation approximation)

        void ILayout::setApproximation(EInterferenceApproximation approximation)

        Sets the used approximation for particles and interference functions. 

        """
        return _libBornAgainCore.ILayout_setApproximation(self, approximation)

ILayout_swigregister = _libBornAgainCore.ILayout_swigregister
ILayout_swigregister(ILayout)

class IAbstractParticle(ICompositeSample):
    """


    Interface for a generic particle.

    Inherited by  IParticle and  ParticleDistribution.

    C++ includes: IAbstractParticle.h

    """

    __swig_setmethods__ = {}
    for _s in [ICompositeSample]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IAbstractParticle, name, value)
    __swig_getmethods__ = {}
    for _s in [ICompositeSample]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IAbstractParticle, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_IAbstractParticle
    __del__ = lambda self: None

    def clone(self):
        """
        clone(IAbstractParticle self) -> IAbstractParticle

        virtual IAbstractParticle* IAbstractParticle::clone() const =0

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.IAbstractParticle_clone(self)


    def cloneInvertB(self):
        """
        cloneInvertB(IAbstractParticle self) -> IAbstractParticle

        virtual IAbstractParticle* IAbstractParticle::cloneInvertB() const =0

        Returns a clone with inverted magnetic fields. 

        """
        return _libBornAgainCore.IAbstractParticle_cloneInvertB(self)


    def accept(self, visitor):
        """
        accept(IAbstractParticle self, ISampleVisitor visitor)

        virtual void IAbstractParticle::accept(ISampleVisitor *visitor) const

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.IAbstractParticle_accept(self, visitor)


    def setAmbientMaterial(self, arg2):
        """
        setAmbientMaterial(IAbstractParticle self, IMaterial arg2)

        virtual void IAbstractParticle::setAmbientMaterial(const IMaterial &)=0

        Sets the refractive index of the ambient material (which influences its scattering power) 

        """
        return _libBornAgainCore.IAbstractParticle_setAmbientMaterial(self, arg2)


    def getAbundance(self):
        """
        getAbundance(IAbstractParticle self) -> double

        double IAbstractParticle::getAbundance() const

        """
        return _libBornAgainCore.IAbstractParticle_getAbundance(self)


    def setAbundance(self, abundance):
        """
        setAbundance(IAbstractParticle self, double abundance)

        void IAbstractParticle::setAbundance(double abundance)

        """
        return _libBornAgainCore.IAbstractParticle_setAbundance(self, abundance)


    def getAmbientMaterial(self):
        """
        getAmbientMaterial(IAbstractParticle self) -> IMaterial

        virtual const IMaterial* IAbstractParticle::getAmbientMaterial() const =0

        Returns nullptr, unless overwritten to return a specific material. 

        """
        return _libBornAgainCore.IAbstractParticle_getAmbientMaterial(self)

IAbstractParticle_swigregister = _libBornAgainCore.IAbstractParticle_swigregister
IAbstractParticle_swigregister(IAbstractParticle)

class IParameterReal(INamed, INoncopyable):
    """


    Pure virtual base class for parameter wrapper classes  RealParameter, ComponentParameter. Holds a pointer to the wrapped parameter, a name, and a callback function to be called when the parameter is changed. This class is templated on the data type of the wrapped parameter.

    C++ includes: IParameter.h

    """

    __swig_setmethods__ = {}
    for _s in [INamed, INoncopyable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IParameterReal, name, value)
    __swig_getmethods__ = {}
    for _s in [INamed, INoncopyable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IParameterReal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self, *args):
        """
        clone(IParameterReal self, std::string const & new_name) -> IParameterReal
        clone(IParameterReal self) -> IParameterReal

        virtual IParameter* IParameter< T >::clone(const std::string &new_name="") const =0

        """
        return _libBornAgainCore.IParameterReal_clone(self, *args)


    def isNull(self):
        """
        isNull(IParameterReal self) -> bool

        virtual bool IParameter< T >::isNull() const

        Returns true if wrapped parameter was not initialized with proper real value. 

        """
        return _libBornAgainCore.IParameterReal_isNull(self)


    def getData(self):
        """
        getData(IParameterReal self) -> double volatile &

        volatile T& IParameter< T >::getData() const

        """
        return _libBornAgainCore.IParameterReal_getData(self)


    def setData(self, data):
        """
        setData(IParameterReal self, double volatile & data)

        void IParameter< T >::setData(volatile T &data)

        """
        return _libBornAgainCore.IParameterReal_setData(self, data)


    def __eq__(self, other):
        """__eq__(IParameterReal self, IParameterReal other) -> bool"""
        return _libBornAgainCore.IParameterReal___eq__(self, other)


    def __ne__(self, other):
        """__ne__(IParameterReal self, IParameterReal other) -> bool"""
        return _libBornAgainCore.IParameterReal___ne__(self, other)

    __swig_destroy__ = _libBornAgainCore.delete_IParameterReal
    __del__ = lambda self: None
IParameterReal_swigregister = _libBornAgainCore.IParameterReal_swigregister
IParameterReal_swigregister(IParameterReal)

class IParticle(IAbstractParticle):
    """


    Pure virtual base class for  Particle,  ParticleComposition,  ParticleCoreShell,  MesoCrystal. Provides position/rotation and form factor. Abundance is inherited from  IAbstractParticle.

    C++ includes: IParticle.h

    """

    __swig_setmethods__ = {}
    for _s in [IAbstractParticle]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IParticle, name, value)
    __swig_getmethods__ = {}
    for _s in [IAbstractParticle]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IParticle, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_IParticle
    __del__ = lambda self: None

    def clone(self):
        """
        clone(IParticle self) -> IParticle

        virtual IParticle* IParticle::clone() const =0

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.IParticle_clone(self)


    def cloneInvertB(self):
        """
        cloneInvertB(IParticle self) -> IParticle

        virtual IParticle* IParticle::cloneInvertB() const =0

        Returns a clone with inverted magnetic fields. 

        """
        return _libBornAgainCore.IParticle_cloneInvertB(self)


    def accept(self, visitor):
        """
        accept(IParticle self, ISampleVisitor visitor)

        virtual void IParticle::accept(ISampleVisitor *visitor) const

        calls the  ISampleVisitor's visit method 

        """
        return _libBornAgainCore.IParticle_accept(self, visitor)


    def createFormFactor(self):
        """
        createFormFactor(IParticle self) -> IFormFactor

        IFormFactor * IParticle::createFormFactor() const

        Create a form factor for this particle. 

        """
        return _libBornAgainCore.IParticle_createFormFactor(self)


    def createTransformedFormFactor(self, p_rotation, translation):
        """
        createTransformedFormFactor(IParticle self, IRotation p_rotation, kvector_t translation) -> IFormFactor

        virtual IFormFactor* IParticle::createTransformedFormFactor(const IRotation *p_rotation, kvector_t translation) const =0

        Create a form factor for this particle with an extra transformation. 

        """
        return _libBornAgainCore.IParticle_createTransformedFormFactor(self, p_rotation, translation)


    def getPosition(self):
        """
        getPosition(IParticle self) -> kvector_t

        kvector_t IParticle::getPosition() const

        Returns particle position. 

        """
        return _libBornAgainCore.IParticle_getPosition(self)


    def setPosition(self, *args):
        """
        setPosition(IParticle self, kvector_t position)
        setPosition(IParticle self, double x, double y, double z)

        void IParticle::setPosition(double x, double y, double z)

        Sets particle position. 

        """
        return _libBornAgainCore.IParticle_setPosition(self, *args)


    def getRotation(self):
        """
        getRotation(IParticle self) -> IRotation

        const IRotation * IParticle::getRotation() const

        Returns rotation object. 

        """
        return _libBornAgainCore.IParticle_getRotation(self)


    def setRotation(self, rotation):
        """
        setRotation(IParticle self, IRotation rotation)

        void IParticle::setRotation(const IRotation &rotation)

        Sets transformation. 

        """
        return _libBornAgainCore.IParticle_setRotation(self, rotation)


    def applyRotation(self, rotation):
        """
        applyRotation(IParticle self, IRotation rotation)

        void IParticle::applyRotation(const IRotation &rotation)

        Applies transformation by composing it with the existing one. 

        """
        return _libBornAgainCore.IParticle_applyRotation(self, rotation)


    def applyTranslation(self, displacement):
        """
        applyTranslation(IParticle self, kvector_t displacement)

        void IParticle::applyTranslation(kvector_t displacement)

        Applies extra translation by adding it to the current one. 

        """
        return _libBornAgainCore.IParticle_applyTranslation(self, displacement)

IParticle_swigregister = _libBornAgainCore.IParticle_swigregister
IParticle_swigregister(IParticle)

class IResolutionFunction2D(IParameterized):
    """


    Interface providing two-dimensional resolution function.

    C++ includes: IResolutionFunction2D.h

    """

    __swig_setmethods__ = {}
    for _s in [IParameterized]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IResolutionFunction2D, name, value)
    __swig_getmethods__ = {}
    for _s in [IParameterized]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IResolutionFunction2D, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_IResolutionFunction2D
    __del__ = lambda self: None

    def evaluateCDF(self, x, y):
        """
        evaluateCDF(IResolutionFunction2D self, double x, double y) -> double

        virtual double IResolutionFunction2D::evaluateCDF(double x, double y) const =0

        """
        return _libBornAgainCore.IResolutionFunction2D_evaluateCDF(self, x, y)


    def clone(self):
        """
        clone(IResolutionFunction2D self) -> IResolutionFunction2D

        virtual IResolutionFunction2D* IResolutionFunction2D::clone() const =0

        """
        return _libBornAgainCore.IResolutionFunction2D_clone(self)

IResolutionFunction2D_swigregister = _libBornAgainCore.IResolutionFunction2D_swigregister
IResolutionFunction2D_swigregister(IResolutionFunction2D)

class IRotation(ISample):
    """


    must be subclass of sample, because it can be registered as a child in  ICompositeSample

    An interface for classes representing a rotation.

    C++ includes: Rotations.h

    """

    __swig_setmethods__ = {}
    for _s in [ISample]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IRotation, name, value)
    __swig_getmethods__ = {}
    for _s in [ISample]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IRotation, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def createRotation(transform):
        """createRotation(Transform3D const & transform) -> IRotation"""
        return _libBornAgainCore.IRotation_createRotation(transform)

    if _newclass:
        createRotation = staticmethod(createRotation)
    __swig_getmethods__["createRotation"] = lambda x: createRotation
    __swig_destroy__ = _libBornAgainCore.delete_IRotation
    __del__ = lambda self: None

    def clone(self):
        """
        clone(IRotation self) -> IRotation

        virtual IRotation* IRotation::clone() const =0

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.IRotation_clone(self)


    def cloneInvertB(self):
        """
        cloneInvertB(IRotation self) -> IRotation

        IRotation* IRotation::cloneInvertB() const final

        Returns a clone with inverted magnetic fields. 

        """
        return _libBornAgainCore.IRotation_cloneInvertB(self)


    def createInverse(self):
        """
        createInverse(IRotation self) -> IRotation

        virtual IRotation* IRotation::createInverse() const =0

        Returns a new  IRotation object that is the current object's inverse. 

        """
        return _libBornAgainCore.IRotation_createInverse(self)


    def accept(self, visitor):
        """
        accept(IRotation self, ISampleVisitor visitor)

        void IRotation::accept(ISampleVisitor *visitor) const

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.IRotation_accept(self, visitor)


    def getTransform3D(self):
        """
        getTransform3D(IRotation self) -> Transform3D

        virtual Transform3D IRotation::getTransform3D() const =0

        Returns transformation. 

        """
        return _libBornAgainCore.IRotation_getTransform3D(self)


    def isIdentity(self):
        """
        isIdentity(IRotation self) -> bool

        bool IRotation::isIdentity() const

        Returns true if roation matrix is identity matrix (no rotations) 

        """
        return _libBornAgainCore.IRotation_isIdentity(self)

IRotation_swigregister = _libBornAgainCore.IRotation_swigregister
IRotation_swigregister(IRotation)

def IRotation_createRotation(transform):
    """IRotation_createRotation(Transform3D const & transform) -> IRotation"""
    return _libBornAgainCore.IRotation_createRotation(transform)


def CreateProduct(left, right):
    """
    CreateProduct(IRotation left, IRotation right) -> IRotation

    BA_CORE_API_ IRotation* CreateProduct(const IRotation &left, const IRotation &right)

    Returns concatenated rotation (first right, then left). 

    """
    return _libBornAgainCore.CreateProduct(left, right)
class RotationX(IRotation):
    """Proxy of C++ RotationX class."""

    __swig_setmethods__ = {}
    for _s in [IRotation]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RotationX, name, value)
    __swig_getmethods__ = {}
    for _s in [IRotation]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RotationX, name)
    __repr__ = _swig_repr

    def __init__(self, angle):
        """
        __init__(RotationX self, double angle) -> RotationX

        RotationX::RotationX(double angle)

        """
        this = _libBornAgainCore.new_RotationX(angle)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(RotationX self) -> RotationX

        RotationX* RotationX::clone() const

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.RotationX_clone(self)


    def createInverse(self):
        """
        createInverse(RotationX self) -> RotationX

        RotationX* RotationX::createInverse() const

        Returns a new  IRotation object that is the current object's inverse. 

        """
        return _libBornAgainCore.RotationX_createInverse(self)


    def accept(self, visitor):
        """
        accept(RotationX self, ISampleVisitor visitor)

        void RotationX::accept(ISampleVisitor *visitor) const

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.RotationX_accept(self, visitor)


    def getAngle(self):
        """
        getAngle(RotationX self) -> double

        double RotationX::getAngle() const

        """
        return _libBornAgainCore.RotationX_getAngle(self)


    def getTransform3D(self):
        """
        getTransform3D(RotationX self) -> Transform3D

        Transform3D RotationX::getTransform3D() const

        Returns transformation. 

        """
        return _libBornAgainCore.RotationX_getTransform3D(self)

    __swig_destroy__ = _libBornAgainCore.delete_RotationX
    __del__ = lambda self: None
RotationX_swigregister = _libBornAgainCore.RotationX_swigregister
RotationX_swigregister(RotationX)

class RotationY(IRotation):
    """Proxy of C++ RotationY class."""

    __swig_setmethods__ = {}
    for _s in [IRotation]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RotationY, name, value)
    __swig_getmethods__ = {}
    for _s in [IRotation]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RotationY, name)
    __repr__ = _swig_repr

    def __init__(self, angle):
        """
        __init__(RotationY self, double angle) -> RotationY

        RotationY::RotationY(double angle)

        """
        this = _libBornAgainCore.new_RotationY(angle)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(RotationY self) -> RotationY

        RotationY* RotationY::clone() const

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.RotationY_clone(self)


    def createInverse(self):
        """
        createInverse(RotationY self) -> RotationY

        RotationY* RotationY::createInverse() const

        Returns a new  IRotation object that is the current object's inverse. 

        """
        return _libBornAgainCore.RotationY_createInverse(self)


    def accept(self, visitor):
        """
        accept(RotationY self, ISampleVisitor visitor)

        void RotationY::accept(ISampleVisitor *visitor) const

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.RotationY_accept(self, visitor)


    def getAngle(self):
        """
        getAngle(RotationY self) -> double

        double RotationY::getAngle() const

        """
        return _libBornAgainCore.RotationY_getAngle(self)


    def getTransform3D(self):
        """
        getTransform3D(RotationY self) -> Transform3D

        Transform3D RotationY::getTransform3D() const

        Returns transformation. 

        """
        return _libBornAgainCore.RotationY_getTransform3D(self)

    __swig_destroy__ = _libBornAgainCore.delete_RotationY
    __del__ = lambda self: None
RotationY_swigregister = _libBornAgainCore.RotationY_swigregister
RotationY_swigregister(RotationY)

class RotationZ(IRotation):
    """Proxy of C++ RotationZ class."""

    __swig_setmethods__ = {}
    for _s in [IRotation]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RotationZ, name, value)
    __swig_getmethods__ = {}
    for _s in [IRotation]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RotationZ, name)
    __repr__ = _swig_repr

    def __init__(self, angle=0.0):
        """
        __init__(RotationZ self, double angle=0.0) -> RotationZ
        __init__(RotationZ self) -> RotationZ

        RotationZ::RotationZ(double angle=0.0)

        """
        this = _libBornAgainCore.new_RotationZ(angle)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(RotationZ self) -> RotationZ

        RotationZ* RotationZ::clone() const

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.RotationZ_clone(self)


    def createInverse(self):
        """
        createInverse(RotationZ self) -> RotationZ

        RotationZ* RotationZ::createInverse() const

        Returns a new  IRotation object that is the current object's inverse. 

        """
        return _libBornAgainCore.RotationZ_createInverse(self)


    def accept(self, visitor):
        """
        accept(RotationZ self, ISampleVisitor visitor)

        void RotationZ::accept(ISampleVisitor *visitor) const

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.RotationZ_accept(self, visitor)


    def getAngle(self):
        """
        getAngle(RotationZ self) -> double

        double RotationZ::getAngle() const

        """
        return _libBornAgainCore.RotationZ_getAngle(self)


    def getTransform3D(self):
        """
        getTransform3D(RotationZ self) -> Transform3D

        Transform3D RotationZ::getTransform3D() const

        Returns transformation. 

        """
        return _libBornAgainCore.RotationZ_getTransform3D(self)

    __swig_destroy__ = _libBornAgainCore.delete_RotationZ
    __del__ = lambda self: None
RotationZ_swigregister = _libBornAgainCore.RotationZ_swigregister
RotationZ_swigregister(RotationZ)

class RotationEuler(IRotation):
    """Proxy of C++ RotationEuler class."""

    __swig_setmethods__ = {}
    for _s in [IRotation]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RotationEuler, name, value)
    __swig_getmethods__ = {}
    for _s in [IRotation]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RotationEuler, name)
    __repr__ = _swig_repr

    def __init__(self, alpha, beta, gamma):
        """
        __init__(RotationEuler self, double alpha, double beta, double gamma) -> RotationEuler

        RotationEuler::RotationEuler(double alpha, double beta, double gamma)

        """
        this = _libBornAgainCore.new_RotationEuler(alpha, beta, gamma)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(RotationEuler self) -> RotationEuler

        RotationEuler* RotationEuler::clone() const

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.RotationEuler_clone(self)


    def createInverse(self):
        """
        createInverse(RotationEuler self) -> IRotation

        IRotation * RotationEuler::createInverse() const

        Returns a new  IRotation object that is the current object's inverse. 

        """
        return _libBornAgainCore.RotationEuler_createInverse(self)


    def accept(self, visitor):
        """
        accept(RotationEuler self, ISampleVisitor visitor)

        void RotationEuler::accept(ISampleVisitor *visitor) const

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.RotationEuler_accept(self, visitor)


    def getAlpha(self):
        """
        getAlpha(RotationEuler self) -> double

        double RotationEuler::getAlpha() const

        """
        return _libBornAgainCore.RotationEuler_getAlpha(self)


    def getBeta(self):
        """
        getBeta(RotationEuler self) -> double

        double RotationEuler::getBeta() const

        """
        return _libBornAgainCore.RotationEuler_getBeta(self)


    def getGamma(self):
        """
        getGamma(RotationEuler self) -> double

        double RotationEuler::getGamma() const

        """
        return _libBornAgainCore.RotationEuler_getGamma(self)


    def getTransform3D(self):
        """
        getTransform3D(RotationEuler self) -> Transform3D

        Transform3D RotationEuler::getTransform3D() const

        Returns transformation. 

        """
        return _libBornAgainCore.RotationEuler_getTransform3D(self)

    __swig_destroy__ = _libBornAgainCore.delete_RotationEuler
    __del__ = lambda self: None
RotationEuler_swigregister = _libBornAgainCore.RotationEuler_swigregister
RotationEuler_swigregister(RotationEuler)

class ISelectionRule(_object):
    """


    Pure virtual base class for selection rules.

    C++ includes: ISelectionRule.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ISelectionRule, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ISelectionRule, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_ISelectionRule
    __del__ = lambda self: None

    def clone(self):
        """
        clone(ISelectionRule self) -> ISelectionRule

        virtual ISelectionRule* ISelectionRule::clone() const =0

        """
        return _libBornAgainCore.ISelectionRule_clone(self)


    def coordinateSelected(self, coordinate):
        """
        coordinateSelected(ISelectionRule self, ivector_t const & coordinate) -> bool

        virtual bool ISelectionRule::coordinateSelected(const ivector_t &coordinate) const =0

        """
        return _libBornAgainCore.ISelectionRule_coordinateSelected(self, coordinate)

ISelectionRule_swigregister = _libBornAgainCore.ISelectionRule_swigregister
ISelectionRule_swigregister(ISelectionRule)

class SimpleSelectionRule(ISelectionRule):
    """


    Selection rule (v*q)modulus!=0, defined by vector v(a,b,c) and modulus.

    C++ includes: ISelectionRule.h

    """

    __swig_setmethods__ = {}
    for _s in [ISelectionRule]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimpleSelectionRule, name, value)
    __swig_getmethods__ = {}
    for _s in [ISelectionRule]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SimpleSelectionRule, name)
    __repr__ = _swig_repr

    def __init__(self, a, b, c, modulus):
        """
        __init__(SimpleSelectionRule self, int a, int b, int c, int modulus) -> SimpleSelectionRule

        SimpleSelectionRule::SimpleSelectionRule(int a, int b, int c, int modulus)

        """
        this = _libBornAgainCore.new_SimpleSelectionRule(a, b, c, modulus)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_SimpleSelectionRule
    __del__ = lambda self: None

    def clone(self):
        """
        clone(SimpleSelectionRule self) -> SimpleSelectionRule

        SimpleSelectionRule * SimpleSelectionRule::clone() const

        """
        return _libBornAgainCore.SimpleSelectionRule_clone(self)


    def coordinateSelected(self, coordinate):
        """
        coordinateSelected(SimpleSelectionRule self, ivector_t const & coordinate) -> bool

        bool SimpleSelectionRule::coordinateSelected(const ivector_t &coordinate) const

        """
        return _libBornAgainCore.SimpleSelectionRule_coordinateSelected(self, coordinate)

SimpleSelectionRule_swigregister = _libBornAgainCore.SimpleSelectionRule_swigregister
SimpleSelectionRule_swigregister(SimpleSelectionRule)

class Instrument(IParameterized):
    """


    Assembles beam, detector and their relative positions wrt the sample.

    C++ includes: Instrument.h

    """

    __swig_setmethods__ = {}
    for _s in [IParameterized]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Instrument, name, value)
    __swig_getmethods__ = {}
    for _s in [IParameterized]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Instrument, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Instrument self) -> Instrument
        __init__(Instrument self, Instrument other) -> Instrument

        Instrument::Instrument(const Instrument &other)

        """
        this = _libBornAgainCore.new_Instrument(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_Instrument
    __del__ = lambda self: None

    def getBeam(self, *args):
        """
        getBeam(Instrument self) -> Beam
        getBeam(Instrument self) -> Beam

        const Beam& Instrument::getBeam() const

        """
        return _libBornAgainCore.Instrument_getBeam(self, *args)


    def setBeam(self, beam):
        """
        setBeam(Instrument self, Beam beam)

        void Instrument::setBeam(const Beam &beam)

        """
        return _libBornAgainCore.Instrument_setBeam(self, beam)


    def setBeamParameters(self, wavelength, alpha_i, phi_i):
        """
        setBeamParameters(Instrument self, double wavelength, double alpha_i, double phi_i)

        void Instrument::setBeamParameters(double wavelength, double alpha_i, double phi_i)

        Sets the beam wavelength and incoming angles. 

        """
        return _libBornAgainCore.Instrument_setBeamParameters(self, wavelength, alpha_i, phi_i)


    def setBeamIntensity(self, intensity):
        """
        setBeamIntensity(Instrument self, double intensity)

        void Instrument::setBeamIntensity(double intensity)

        Sets the beam's intensity. 

        """
        return _libBornAgainCore.Instrument_setBeamIntensity(self, intensity)


    def setBeamPolarization(self, bloch_vector):
        """
        setBeamPolarization(Instrument self, kvector_t bloch_vector)

        void Instrument::setBeamPolarization(const kvector_t bloch_vector)

        Sets the beam's polarization according to the given Bloch vector. 

        """
        return _libBornAgainCore.Instrument_setBeamPolarization(self, bloch_vector)


    def getBeamIntensity(self):
        """
        getBeamIntensity(Instrument self) -> double

        double Instrument::getBeamIntensity() const

        Returns the beam's intensity. 

        """
        return _libBornAgainCore.Instrument_getBeamIntensity(self)


    def getDetector(self, *args):
        """
        getDetector(Instrument self) -> IDetector2D
        getDetector(Instrument self) -> IDetector2D

        IDetector2D * Instrument::getDetector()

        """
        return _libBornAgainCore.Instrument_getDetector(self, *args)


    def getDetectorMask(self):
        """
        getDetectorMask(Instrument self) -> DetectorMask

        const DetectorMask * Instrument::getDetectorMask() const

        """
        return _libBornAgainCore.Instrument_getDetectorMask(self)


    def getDetectorAxis(self, index):
        """
        getDetectorAxis(Instrument self, size_t index) -> IAxis

        const IAxis & Instrument::getDetectorAxis(size_t index) const

        Returns a detector axis. 

        """
        return _libBornAgainCore.Instrument_getDetectorAxis(self, index)


    def getDetectorDimension(self):
        """
        getDetectorDimension(Instrument self) -> size_t

        size_t Instrument::getDetectorDimension() const

        Returns the detector's dimension. 

        """
        return _libBornAgainCore.Instrument_getDetectorDimension(self)


    def setDetector(self, detector):
        """
        setDetector(Instrument self, IDetector2D detector)

        void Instrument::setDetector(const IDetector2D &detector)

        Sets the detector (axes can be overwritten later) 

        """
        return _libBornAgainCore.Instrument_setDetector(self, detector)


    def setDetectorParameters(self, n_x, x_min, x_max, n_y, y_min, y_max):
        """
        setDetectorParameters(Instrument self, size_t n_x, double x_min, double x_max, size_t n_y, double y_min, double y_max)

        void Instrument::setDetectorParameters(size_t n_x, double x_min, double x_max, size_t n_y, double y_min, double y_max)

        Sets detector parameters using angle ranges. 

        """
        return _libBornAgainCore.Instrument_setDetectorParameters(self, n_x, x_min, x_max, n_y, y_min, y_max)


    def setDetectorAxes(self, axis0, axis1):
        """
        setDetectorAxes(Instrument self, IAxis axis0, IAxis axis1)

        void Instrument::setDetectorAxes(const IAxis &axis0, const IAxis &axis1)

        Sets detector parameters using axes. 

        """
        return _libBornAgainCore.Instrument_setDetectorAxes(self, axis0, axis1)


    def setDetectorResolutionFunction(self, p_resolution_function):
        """
        setDetectorResolutionFunction(Instrument self, IResolutionFunction2D p_resolution_function)

        void Instrument::setDetectorResolutionFunction(const IResolutionFunction2D &p_resolution_function)

        """
        return _libBornAgainCore.Instrument_setDetectorResolutionFunction(self, p_resolution_function)


    def setAnalyzerProperties(self, direction, efficiency, total_transmission):
        """
        setAnalyzerProperties(Instrument self, kvector_t direction, double efficiency, double total_transmission)

        void Instrument::setAnalyzerProperties(const kvector_t direction, double efficiency, double total_transmission)

        Sets the polarization analyzer characteristics of the detector. 

        """
        return _libBornAgainCore.Instrument_setAnalyzerProperties(self, direction, efficiency, total_transmission)


    def applyDetectorResolution(self, p_intensity_map):
        """
        applyDetectorResolution(Instrument self, IntensityData p_intensity_map)

        void Instrument::applyDetectorResolution(OutputData< double > *p_intensity_map) const

        apply the detector resolution to the given intensity map 

        """
        return _libBornAgainCore.Instrument_applyDetectorResolution(self, p_intensity_map)


    def createDetectorIntensity(self, *args):
        """
        createDetectorIntensity(Instrument self, std::vector< SimulationElement,std::allocator< SimulationElement > > const & elements, IDetector2D::EAxesUnits units) -> IntensityData
        createDetectorIntensity(Instrument self, std::vector< SimulationElement,std::allocator< SimulationElement > > const & elements) -> IntensityData

        OutputData< double > * Instrument::createDetectorIntensity(const std::vector< SimulationElement > &elements, IDetector2D::EAxesUnits units=IDetector2D::DEFAULT) const

        Returns new intensity map with detector resolution applied and axes in requested units. 

        """
        return _libBornAgainCore.Instrument_createDetectorIntensity(self, *args)


    def createDetectorMap(self, *args):
        """
        createDetectorMap(Instrument self, IDetector2D::EAxesUnits units) -> IntensityData
        createDetectorMap(Instrument self) -> IntensityData

        OutputData< double > * Instrument::createDetectorMap(IDetector2D::EAxesUnits units=IDetector2D::DEFAULT) const

        Returns empty detector map in given axes units. 

        """
        return _libBornAgainCore.Instrument_createDetectorMap(self, *args)


    def initDetector(self):
        """
        initDetector(Instrument self)

        void Instrument::initDetector()

        init detector with beam settings 

        """
        return _libBornAgainCore.Instrument_initDetector(self)

Instrument_swigregister = _libBornAgainCore.Instrument_swigregister
Instrument_swigregister(Instrument)


def getRelativeDifference(*args):
    """
    getRelativeDifference(IntensityData dat, IntensityData ref) -> double
    getRelativeDifference(IHistogram dat, IHistogram ref) -> double

    BA_CORE_API_ double IntensityDataFunctions::getRelativeDifference(const IHistogram &dat, const IHistogram &ref)

    """
    return _libBornAgainCore.getRelativeDifference(*args)

def createRelativeDifferenceData(data, reference):
    """
    createRelativeDifferenceData(IntensityData data, IntensityData reference) -> IntensityData

    BA_CORE_API_ OutputData<double>* IntensityDataFunctions::createRelativeDifferenceData(const OutputData< double > &data, const OutputData< double > &reference)

    """
    return _libBornAgainCore.createRelativeDifferenceData(data, reference)

def createClippedDataSet(origin, x1, y1, x2, y2):
    """
    createClippedDataSet(IntensityData origin, double x1, double y1, double x2, double y2) -> IntensityData

    BA_CORE_API_ OutputData<double>* IntensityDataFunctions::createClippedDataSet(const OutputData< double > &origin, double x1, double y1, double x2, double y2)

    Returns new IntensityData objects which axes clipped to represent the specified rectangle 

    """
    return _libBornAgainCore.createClippedDataSet(origin, x1, y1, x2, y2)

def applyDetectorResolution(origin, resolution_function):
    """
    applyDetectorResolution(IntensityData origin, IResolutionFunction2D resolution_function) -> IntensityData

    BA_CORE_API_ OutputData<double>* IntensityDataFunctions::applyDetectorResolution(const OutputData< double > &origin, const IResolutionFunction2D &resolution_function)

    Applies detector resolution function and returns new IntensityData object. 

    """
    return _libBornAgainCore.applyDetectorResolution(origin, resolution_function)

def coordinateToBinf(*args):
    """
    coordinateToBinf(double coordinate, IAxis axis) -> double
    coordinateToBinf(double & x, double & y, IntensityData data)

    BA_CORE_API_ void IntensityDataFunctions::coordinateToBinf(double &x, double &y, const OutputData< double > &data)

    Transform x,y coordinate from  OutputData axes coordinates to bin-fraction-coordinates 

    """
    return _libBornAgainCore.coordinateToBinf(*args)

def coordinateFromBinf(*args):
    """
    coordinateFromBinf(double value, IAxis axis) -> double
    coordinateFromBinf(double & x, double & y, IntensityData data)

    BA_CORE_API_ void IntensityDataFunctions::coordinateFromBinf(double &x, double &y, const OutputData< double > &data)

    Transform x,y coordinate from bin-fraction-coordinates to  OutputData's axes coordinates 

    """
    return _libBornAgainCore.coordinateFromBinf(*args)
class IntensityDataIOFactory(_object):
    """


    Provides users with possibility to read and write IntensityData from/to files in different format. Type of the file will be deduced from file name. *.txt - ASCII file with 2D array [nrow][ncol], layout as in numpy. *.int - BornAgain internal ASCII format. *.tif - 32-bits tiff file. If file name ends woth "*.gz" or "*.bz2" the file will be zipped on the fly using appropriate algorithm.

    Usage:

    C++ includes: IntensityDataIOFactory.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntensityDataIOFactory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntensityDataIOFactory, name)
    __repr__ = _swig_repr

    def readOutputData(file_name):
        """readOutputData(std::string const & file_name) -> IntensityData"""
        return _libBornAgainCore.IntensityDataIOFactory_readOutputData(file_name)

    if _newclass:
        readOutputData = staticmethod(readOutputData)
    __swig_getmethods__["readOutputData"] = lambda x: readOutputData

    def readIntensityData(file_name):
        """readIntensityData(std::string const & file_name) -> IHistogram"""
        return _libBornAgainCore.IntensityDataIOFactory_readIntensityData(file_name)

    if _newclass:
        readIntensityData = staticmethod(readIntensityData)
    __swig_getmethods__["readIntensityData"] = lambda x: readIntensityData

    def writeOutputData(data, file_name):
        """writeOutputData(IntensityData data, std::string const & file_name)"""
        return _libBornAgainCore.IntensityDataIOFactory_writeOutputData(data, file_name)

    if _newclass:
        writeOutputData = staticmethod(writeOutputData)
    __swig_getmethods__["writeOutputData"] = lambda x: writeOutputData

    def writeIntensityData(histogram, file_name):
        """writeIntensityData(IHistogram histogram, std::string const & file_name)"""
        return _libBornAgainCore.IntensityDataIOFactory_writeIntensityData(histogram, file_name)

    if _newclass:
        writeIntensityData = staticmethod(writeIntensityData)
    __swig_getmethods__["writeIntensityData"] = lambda x: writeIntensityData

    def __init__(self):
        """
        __init__(IntensityDataIOFactory self) -> IntensityDataIOFactory



        Provides users with possibility to read and write IntensityData from/to files in different format. Type of the file will be deduced from file name. *.txt - ASCII file with 2D array [nrow][ncol], layout as in numpy. *.int - BornAgain internal ASCII format. *.tif - 32-bits tiff file. If file name ends woth "*.gz" or "*.bz2" the file will be zipped on the fly using appropriate algorithm.

        Usage:

        C++ includes: IntensityDataIOFactory.h

        """
        this = _libBornAgainCore.new_IntensityDataIOFactory()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_IntensityDataIOFactory
    __del__ = lambda self: None
IntensityDataIOFactory_swigregister = _libBornAgainCore.IntensityDataIOFactory_swigregister
IntensityDataIOFactory_swigregister(IntensityDataIOFactory)

def IntensityDataIOFactory_readOutputData(file_name):
    """IntensityDataIOFactory_readOutputData(std::string const & file_name) -> IntensityData"""
    return _libBornAgainCore.IntensityDataIOFactory_readOutputData(file_name)

def IntensityDataIOFactory_readIntensityData(file_name):
    """IntensityDataIOFactory_readIntensityData(std::string const & file_name) -> IHistogram"""
    return _libBornAgainCore.IntensityDataIOFactory_readIntensityData(file_name)

def IntensityDataIOFactory_writeOutputData(data, file_name):
    """IntensityDataIOFactory_writeOutputData(IntensityData data, std::string const & file_name)"""
    return _libBornAgainCore.IntensityDataIOFactory_writeOutputData(data, file_name)

def IntensityDataIOFactory_writeIntensityData(histogram, file_name):
    """IntensityDataIOFactory_writeIntensityData(IHistogram histogram, std::string const & file_name)"""
    return _libBornAgainCore.IntensityDataIOFactory_writeIntensityData(histogram, file_name)

class InterferenceFunction1DLattice(IInterferenceFunction):
    """


    Interference function of 1D lattice.

    C++ includes: InterferenceFunction1DLattice.h

    """

    __swig_setmethods__ = {}
    for _s in [IInterferenceFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InterferenceFunction1DLattice, name, value)
    __swig_getmethods__ = {}
    for _s in [IInterferenceFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InterferenceFunction1DLattice, name)
    __repr__ = _swig_repr

    def __init__(self, length, xi):
        """
        __init__(InterferenceFunction1DLattice self, double length, double xi) -> InterferenceFunction1DLattice

        InterferenceFunction1DLattice::InterferenceFunction1DLattice(double length, double xi)

        Parameters:
        -----------

        length: 
         Lattice length

        xi: 
        rotation of lattice with respect to x-axis 

        """
        this = _libBornAgainCore.new_InterferenceFunction1DLattice(length, xi)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_InterferenceFunction1DLattice
    __del__ = lambda self: None

    def clone(self):
        """
        clone(InterferenceFunction1DLattice self) -> InterferenceFunction1DLattice

        InterferenceFunction1DLattice * InterferenceFunction1DLattice::clone() const final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.InterferenceFunction1DLattice_clone(self)


    def accept(self, visitor):
        """
        accept(InterferenceFunction1DLattice self, ISampleVisitor visitor)

        void InterferenceFunction1DLattice::accept(ISampleVisitor *visitor) const final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.InterferenceFunction1DLattice_accept(self, visitor)


    def setDecayFunction(self, pdf):
        """
        setDecayFunction(InterferenceFunction1DLattice self, IFTDecayFunction1D pdf)

        void InterferenceFunction1DLattice::setDecayFunction(const IFTDecayFunction1D &pdf)

        """
        return _libBornAgainCore.InterferenceFunction1DLattice_setDecayFunction(self, pdf)


    def getLatticeParameters(self):
        """
        getLatticeParameters(InterferenceFunction1DLattice self) -> Lattice1DParameters

        Lattice1DParameters InterferenceFunction1DLattice::getLatticeParameters() const

        """
        return _libBornAgainCore.InterferenceFunction1DLattice_getLatticeParameters(self)


    def getDecayFunction(self):
        """
        getDecayFunction(InterferenceFunction1DLattice self) -> IFTDecayFunction1D

        const IFTDecayFunction1D* InterferenceFunction1DLattice::getDecayFunction() const

        """
        return _libBornAgainCore.InterferenceFunction1DLattice_getDecayFunction(self)


    def evaluate(self, q):
        """
        evaluate(InterferenceFunction1DLattice self, kvector_t q) -> double

        double InterferenceFunction1DLattice::evaluate(const kvector_t q) const final

        Evaluates the interference function for a given wavevector transfer (only the real x and y components are relevant) 

        """
        return _libBornAgainCore.InterferenceFunction1DLattice_evaluate(self, q)

InterferenceFunction1DLattice_swigregister = _libBornAgainCore.InterferenceFunction1DLattice_swigregister
InterferenceFunction1DLattice_swigregister(InterferenceFunction1DLattice)

class InterferenceFunctionRadialParaCrystal(IInterferenceFunction):
    """


    Interference function of radial paracrystal.

    C++ includes: InterferenceFunctionRadialParaCrystal.h

    """

    __swig_setmethods__ = {}
    for _s in [IInterferenceFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InterferenceFunctionRadialParaCrystal, name, value)
    __swig_getmethods__ = {}
    for _s in [IInterferenceFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InterferenceFunctionRadialParaCrystal, name)
    __repr__ = _swig_repr

    def __init__(self, peak_distance, damping_length=0.0):
        """
        __init__(InterferenceFunctionRadialParaCrystal self, double peak_distance, double damping_length=0.0) -> InterferenceFunctionRadialParaCrystal
        __init__(InterferenceFunctionRadialParaCrystal self, double peak_distance) -> InterferenceFunctionRadialParaCrystal

        InterferenceFunctionRadialParaCrystal::InterferenceFunctionRadialParaCrystal(double peak_distance, double damping_length=0.0)

        """
        this = _libBornAgainCore.new_InterferenceFunctionRadialParaCrystal(peak_distance, damping_length)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(InterferenceFunctionRadialParaCrystal self) -> InterferenceFunctionRadialParaCrystal

        InterferenceFunctionRadialParaCrystal * InterferenceFunctionRadialParaCrystal::clone() const final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.InterferenceFunctionRadialParaCrystal_clone(self)


    def accept(self, visitor):
        """
        accept(InterferenceFunctionRadialParaCrystal self, ISampleVisitor visitor)

        void InterferenceFunctionRadialParaCrystal::accept(ISampleVisitor *visitor) const final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.InterferenceFunctionRadialParaCrystal_accept(self, visitor)


    def to_str(self, indent=0):
        """
        to_str(InterferenceFunctionRadialParaCrystal self, int indent=0) -> std::string
        to_str(InterferenceFunctionRadialParaCrystal self) -> std::string

        std::string InterferenceFunctionRadialParaCrystal::to_str(int indent=0) const final

        Returns textual representation of this and its descendants. 

        """
        return _libBornAgainCore.InterferenceFunctionRadialParaCrystal_to_str(self, indent)


    def setKappa(self, kappa):
        """
        setKappa(InterferenceFunctionRadialParaCrystal self, double kappa)

        void InterferenceFunctionRadialParaCrystal::setKappa(double kappa)

        """
        return _libBornAgainCore.InterferenceFunctionRadialParaCrystal_setKappa(self, kappa)


    def getKappa(self):
        """
        getKappa(InterferenceFunctionRadialParaCrystal self) -> double

        double InterferenceFunctionRadialParaCrystal::getKappa() const final

        Retrieves the size-distance coupling constant (default 0.0) 

        """
        return _libBornAgainCore.InterferenceFunctionRadialParaCrystal_getKappa(self)


    def setDomainSize(self, size):
        """
        setDomainSize(InterferenceFunctionRadialParaCrystal self, double size)

        void InterferenceFunctionRadialParaCrystal::setDomainSize(double size)

        """
        return _libBornAgainCore.InterferenceFunctionRadialParaCrystal_setDomainSize(self, size)


    def getDomainSize(self):
        """
        getDomainSize(InterferenceFunctionRadialParaCrystal self) -> double

        double InterferenceFunctionRadialParaCrystal::getDomainSize() const

        """
        return _libBornAgainCore.InterferenceFunctionRadialParaCrystal_getDomainSize(self)


    def evaluate(self, q):
        """
        evaluate(InterferenceFunctionRadialParaCrystal self, kvector_t q) -> double

        double InterferenceFunctionRadialParaCrystal::evaluate(const kvector_t q) const final

        Evaluates the interference function for a given wavevector transfer (only the real x and y components are relevant) 

        """
        return _libBornAgainCore.InterferenceFunctionRadialParaCrystal_evaluate(self, q)


    def FTPDF(self, qpar):
        """
        FTPDF(InterferenceFunctionRadialParaCrystal self, double qpar) -> complex_t

        complex_t InterferenceFunctionRadialParaCrystal::FTPDF(double qpar) const

        """
        return _libBornAgainCore.InterferenceFunctionRadialParaCrystal_FTPDF(self, qpar)


    def setProbabilityDistribution(self, pdf):
        """
        setProbabilityDistribution(InterferenceFunctionRadialParaCrystal self, IFTDistribution1D pdf)

        void InterferenceFunctionRadialParaCrystal::setProbabilityDistribution(const IFTDistribution1D &pdf)

        """
        return _libBornAgainCore.InterferenceFunctionRadialParaCrystal_setProbabilityDistribution(self, pdf)


    def getProbabilityDistribution(self):
        """
        getProbabilityDistribution(InterferenceFunctionRadialParaCrystal self) -> IFTDistribution1D

        const IFTDistribution1D* InterferenceFunctionRadialParaCrystal::getProbabilityDistribution() const

        """
        return _libBornAgainCore.InterferenceFunctionRadialParaCrystal_getProbabilityDistribution(self)


    def getPeakDistance(self):
        """
        getPeakDistance(InterferenceFunctionRadialParaCrystal self) -> double

        double InterferenceFunctionRadialParaCrystal::getPeakDistance() const

        """
        return _libBornAgainCore.InterferenceFunctionRadialParaCrystal_getPeakDistance(self)


    def getDampingLength(self):
        """
        getDampingLength(InterferenceFunctionRadialParaCrystal self) -> double

        double InterferenceFunctionRadialParaCrystal::getDampingLength() const

        """
        return _libBornAgainCore.InterferenceFunctionRadialParaCrystal_getDampingLength(self)

    __swig_destroy__ = _libBornAgainCore.delete_InterferenceFunctionRadialParaCrystal
    __del__ = lambda self: None
InterferenceFunctionRadialParaCrystal_swigregister = _libBornAgainCore.InterferenceFunctionRadialParaCrystal_swigregister
InterferenceFunctionRadialParaCrystal_swigregister(InterferenceFunctionRadialParaCrystal)

class InterferenceFunction2DLattice(IInterferenceFunction):
    """


    Interference function of 2D lattice.

    C++ includes: InterferenceFunction2DLattice.h

    """

    __swig_setmethods__ = {}
    for _s in [IInterferenceFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InterferenceFunction2DLattice, name, value)
    __swig_getmethods__ = {}
    for _s in [IInterferenceFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InterferenceFunction2DLattice, name)
    __repr__ = _swig_repr

    def __init__(self, length_1, length_2, angle, xi=0.0):
        """
        __init__(InterferenceFunction2DLattice self, double length_1, double length_2, double angle, double xi=0.0) -> InterferenceFunction2DLattice
        __init__(InterferenceFunction2DLattice self, double length_1, double length_2, double angle) -> InterferenceFunction2DLattice

        InterferenceFunction2DLattice::InterferenceFunction2DLattice(double length_1, double length_2, double angle, double xi=0.0)

        Parameters:
        -----------

        length_1: 
         Lattice length 1

        length_2: 
         Lattice length 2

        angle: 
        angle between lattice vectors

        xi: 
        rotation of lattice with respect to x-axis 

        """
        this = _libBornAgainCore.new_InterferenceFunction2DLattice(length_1, length_2, angle, xi)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_InterferenceFunction2DLattice
    __del__ = lambda self: None

    def clone(self):
        """
        clone(InterferenceFunction2DLattice self) -> InterferenceFunction2DLattice

        InterferenceFunction2DLattice * InterferenceFunction2DLattice::clone() const final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.InterferenceFunction2DLattice_clone(self)


    def accept(self, visitor):
        """
        accept(InterferenceFunction2DLattice self, ISampleVisitor visitor)

        void InterferenceFunction2DLattice::accept(ISampleVisitor *visitor) const final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.InterferenceFunction2DLattice_accept(self, visitor)


    def createSquare(lattice_length, xi=0.0):
        """
        createSquare(double lattice_length, double xi=0.0) -> InterferenceFunction2DLattice
        createSquare(double lattice_length) -> InterferenceFunction2DLattice
        """
        return _libBornAgainCore.InterferenceFunction2DLattice_createSquare(lattice_length, xi)

    if _newclass:
        createSquare = staticmethod(createSquare)
    __swig_getmethods__["createSquare"] = lambda x: createSquare

    def createHexagonal(lattice_length, xi=0.0):
        """
        createHexagonal(double lattice_length, double xi=0.0) -> InterferenceFunction2DLattice
        createHexagonal(double lattice_length) -> InterferenceFunction2DLattice
        """
        return _libBornAgainCore.InterferenceFunction2DLattice_createHexagonal(lattice_length, xi)

    if _newclass:
        createHexagonal = staticmethod(createHexagonal)
    __swig_getmethods__["createHexagonal"] = lambda x: createHexagonal

    def setDecayFunction(self, pdf):
        """
        setDecayFunction(InterferenceFunction2DLattice self, IFTDecayFunction2D pdf)

        void InterferenceFunction2DLattice::setDecayFunction(const IFTDecayFunction2D &pdf)

        """
        return _libBornAgainCore.InterferenceFunction2DLattice_setDecayFunction(self, pdf)


    def getDecayFunction(self):
        """
        getDecayFunction(InterferenceFunction2DLattice self) -> IFTDecayFunction2D

        const IFTDecayFunction2D* InterferenceFunction2DLattice::getDecayFunction() const

        """
        return _libBornAgainCore.InterferenceFunction2DLattice_getDecayFunction(self)


    def evaluate(self, q):
        """
        evaluate(InterferenceFunction2DLattice self, kvector_t q) -> double

        double InterferenceFunction2DLattice::evaluate(const kvector_t q) const final

        Evaluates the interference function for a given wavevector transfer (only the real x and y components are relevant) 

        """
        return _libBornAgainCore.InterferenceFunction2DLattice_evaluate(self, q)


    def getLatticeParameters(self):
        """
        getLatticeParameters(InterferenceFunction2DLattice self) -> Lattice2DParameters

        Lattice2DParameters InterferenceFunction2DLattice::getLatticeParameters() const

        """
        return _libBornAgainCore.InterferenceFunction2DLattice_getLatticeParameters(self)


    def getParticleDensity(self):
        """
        getParticleDensity(InterferenceFunction2DLattice self) -> double

        double InterferenceFunction2DLattice::getParticleDensity() const final

        Returns the particle density associated with this 2d lattice. 

        """
        return _libBornAgainCore.InterferenceFunction2DLattice_getParticleDensity(self)

InterferenceFunction2DLattice_swigregister = _libBornAgainCore.InterferenceFunction2DLattice_swigregister
InterferenceFunction2DLattice_swigregister(InterferenceFunction2DLattice)

def InterferenceFunction2DLattice_createSquare(lattice_length, xi=0.0):
    """
    createSquare(double lattice_length, double xi=0.0) -> InterferenceFunction2DLattice
    InterferenceFunction2DLattice_createSquare(double lattice_length) -> InterferenceFunction2DLattice
    """
    return _libBornAgainCore.InterferenceFunction2DLattice_createSquare(lattice_length, xi)

def InterferenceFunction2DLattice_createHexagonal(lattice_length, xi=0.0):
    """
    createHexagonal(double lattice_length, double xi=0.0) -> InterferenceFunction2DLattice
    InterferenceFunction2DLattice_createHexagonal(double lattice_length) -> InterferenceFunction2DLattice
    """
    return _libBornAgainCore.InterferenceFunction2DLattice_createHexagonal(lattice_length, xi)

class InterferenceFunction2DParaCrystal(IInterferenceFunction):
    """


    Interference function of 2D paracrystal.

    C++ includes: InterferenceFunction2DParaCrystal.h

    """

    __swig_setmethods__ = {}
    for _s in [IInterferenceFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InterferenceFunction2DParaCrystal, name, value)
    __swig_getmethods__ = {}
    for _s in [IInterferenceFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InterferenceFunction2DParaCrystal, name)
    __repr__ = _swig_repr

    def __init__(self, length_1, length_2, alpha_lattice, xi=0.0, damping_length=0.0):
        """
        __init__(InterferenceFunction2DParaCrystal self, double length_1, double length_2, double alpha_lattice, double xi=0.0, double damping_length=0.0) -> InterferenceFunction2DParaCrystal
        __init__(InterferenceFunction2DParaCrystal self, double length_1, double length_2, double alpha_lattice, double xi=0.0) -> InterferenceFunction2DParaCrystal
        __init__(InterferenceFunction2DParaCrystal self, double length_1, double length_2, double alpha_lattice) -> InterferenceFunction2DParaCrystal

        InterferenceFunction2DParaCrystal::InterferenceFunction2DParaCrystal(double length_1, double length_2, double alpha_lattice, double xi=0.0, double damping_length=0.0)

        Parameters:
        -----------

        length_1: 
        Length of first lattice basis vector.

        length_2: 
        Length of second lattice basis vector.

        alpha_lattice: 
        Angle between the lattice basis vectors.

        xi: 
        Angle between first basis vector and the x-axis of incoming beam.

        damping_length: 
        Damping length for removing delta function singularity at q=0. 

        """
        this = _libBornAgainCore.new_InterferenceFunction2DParaCrystal(length_1, length_2, alpha_lattice, xi, damping_length)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_InterferenceFunction2DParaCrystal
    __del__ = lambda self: None

    def clone(self):
        """
        clone(InterferenceFunction2DParaCrystal self) -> InterferenceFunction2DParaCrystal

        InterferenceFunction2DParaCrystal * InterferenceFunction2DParaCrystal::clone() const final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.InterferenceFunction2DParaCrystal_clone(self)


    def accept(self, visitor):
        """
        accept(InterferenceFunction2DParaCrystal self, ISampleVisitor visitor)

        void InterferenceFunction2DParaCrystal::accept(ISampleVisitor *visitor) const final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.InterferenceFunction2DParaCrystal_accept(self, visitor)


    def to_str(self, indent=0):
        """
        to_str(InterferenceFunction2DParaCrystal self, int indent=0) -> std::string
        to_str(InterferenceFunction2DParaCrystal self) -> std::string

        std::string InterferenceFunction2DParaCrystal::to_str(int indent=0) const final

        Returns textual representation of this and its descendants. 

        """
        return _libBornAgainCore.InterferenceFunction2DParaCrystal_to_str(self, indent)


    def createSquare(peak_distance, damping_length=0.0, domain_size_1=0.0, domain_size_2=0.0):
        """
        createSquare(double peak_distance, double damping_length=0.0, double domain_size_1=0.0, double domain_size_2=0.0) -> InterferenceFunction2DParaCrystal
        createSquare(double peak_distance, double damping_length=0.0, double domain_size_1=0.0) -> InterferenceFunction2DParaCrystal
        createSquare(double peak_distance, double damping_length=0.0) -> InterferenceFunction2DParaCrystal
        createSquare(double peak_distance) -> InterferenceFunction2DParaCrystal
        """
        return _libBornAgainCore.InterferenceFunction2DParaCrystal_createSquare(peak_distance, damping_length, domain_size_1, domain_size_2)

    if _newclass:
        createSquare = staticmethod(createSquare)
    __swig_getmethods__["createSquare"] = lambda x: createSquare

    def createHexagonal(peak_distance, damping_length=0.0, domain_size_1=0.0, domain_size_2=0.0):
        """
        createHexagonal(double peak_distance, double damping_length=0.0, double domain_size_1=0.0, double domain_size_2=0.0) -> InterferenceFunction2DParaCrystal
        createHexagonal(double peak_distance, double damping_length=0.0, double domain_size_1=0.0) -> InterferenceFunction2DParaCrystal
        createHexagonal(double peak_distance, double damping_length=0.0) -> InterferenceFunction2DParaCrystal
        createHexagonal(double peak_distance) -> InterferenceFunction2DParaCrystal
        """
        return _libBornAgainCore.InterferenceFunction2DParaCrystal_createHexagonal(peak_distance, damping_length, domain_size_1, domain_size_2)

    if _newclass:
        createHexagonal = staticmethod(createHexagonal)
    __swig_getmethods__["createHexagonal"] = lambda x: createHexagonal

    def setDomainSizes(self, size_1, size_2):
        """
        setDomainSizes(InterferenceFunction2DParaCrystal self, double size_1, double size_2)

        void InterferenceFunction2DParaCrystal::setDomainSizes(double size_1, double size_2)

        Sets the sizes of coherence domains.

        Parameters:
        -----------

        size_1: 
        size in first lattice direction

        size_2: 
        size in second lattice direction 

        """
        return _libBornAgainCore.InterferenceFunction2DParaCrystal_setDomainSizes(self, size_1, size_2)


    def setProbabilityDistributions(self, pdf_1, pdf_2):
        """
        setProbabilityDistributions(InterferenceFunction2DParaCrystal self, IFTDistribution2D pdf_1, IFTDistribution2D pdf_2)

        void InterferenceFunction2DParaCrystal::setProbabilityDistributions(const IFTDistribution2D &pdf_1, const IFTDistribution2D &pdf_2)

        Sets the probability distributions (Fourier transformed) for the two lattice directions.

        Parameters:
        -----------

        pdf_1: 
        probability distribution in first lattice direction

        pdf_2: 
        probability distribution in second lattice direction 

        """
        return _libBornAgainCore.InterferenceFunction2DParaCrystal_setProbabilityDistributions(self, pdf_1, pdf_2)


    def evaluate(self, q):
        """
        evaluate(InterferenceFunction2DParaCrystal self, kvector_t q) -> double

        double InterferenceFunction2DParaCrystal::evaluate(const kvector_t q) const final

        Evaluates the interference function for a given wavevector transfer (only the real x and y components are relevant) 

        """
        return _libBornAgainCore.InterferenceFunction2DParaCrystal_evaluate(self, q)


    def getDomainSizes(self):
        """
        getDomainSizes(InterferenceFunction2DParaCrystal self) -> vdouble1d_t

        std::vector< double > InterferenceFunction2DParaCrystal::getDomainSizes() const

        """
        return _libBornAgainCore.InterferenceFunction2DParaCrystal_getDomainSizes(self)


    def getProbabilityDistributions(self):
        """
        getProbabilityDistributions(InterferenceFunction2DParaCrystal self) -> std::vector< IFTDistribution2D const *,std::allocator< IFTDistribution2D const * > >

        std::vector< const IFTDistribution2D * > InterferenceFunction2DParaCrystal::getProbabilityDistributions() const

        """
        return _libBornAgainCore.InterferenceFunction2DParaCrystal_getProbabilityDistributions(self)


    def setIntegrationOverXi(self, integrate_xi):
        """
        setIntegrationOverXi(InterferenceFunction2DParaCrystal self, bool integrate_xi)

        void InterferenceFunction2DParaCrystal::setIntegrationOverXi(bool integrate_xi)

        """
        return _libBornAgainCore.InterferenceFunction2DParaCrystal_setIntegrationOverXi(self, integrate_xi)


    def getIntegrationOverXi(self):
        """
        getIntegrationOverXi(InterferenceFunction2DParaCrystal self) -> bool

        bool InterferenceFunction2DParaCrystal::getIntegrationOverXi() const

        """
        return _libBornAgainCore.InterferenceFunction2DParaCrystal_getIntegrationOverXi(self)


    def getDampingLength(self):
        """
        getDampingLength(InterferenceFunction2DParaCrystal self) -> double

        double InterferenceFunction2DParaCrystal::getDampingLength() const

        """
        return _libBornAgainCore.InterferenceFunction2DParaCrystal_getDampingLength(self)


    def getLatticeParameters(self):
        """
        getLatticeParameters(InterferenceFunction2DParaCrystal self) -> Lattice2DParameters

        Lattice2DParameters InterferenceFunction2DParaCrystal::getLatticeParameters() const

        """
        return _libBornAgainCore.InterferenceFunction2DParaCrystal_getLatticeParameters(self)


    def getParticleDensity(self):
        """
        getParticleDensity(InterferenceFunction2DParaCrystal self) -> double

        double InterferenceFunction2DParaCrystal::getParticleDensity() const final

        If defined by this interference function's parameters, returns the particle density (per area). Otherwise, returns zero or a user-defined value 

        """
        return _libBornAgainCore.InterferenceFunction2DParaCrystal_getParticleDensity(self)

InterferenceFunction2DParaCrystal_swigregister = _libBornAgainCore.InterferenceFunction2DParaCrystal_swigregister
InterferenceFunction2DParaCrystal_swigregister(InterferenceFunction2DParaCrystal)

def InterferenceFunction2DParaCrystal_createSquare(peak_distance, damping_length=0.0, domain_size_1=0.0, domain_size_2=0.0):
    """
    createSquare(double peak_distance, double damping_length=0.0, double domain_size_1=0.0, double domain_size_2=0.0) -> InterferenceFunction2DParaCrystal
    createSquare(double peak_distance, double damping_length=0.0, double domain_size_1=0.0) -> InterferenceFunction2DParaCrystal
    createSquare(double peak_distance, double damping_length=0.0) -> InterferenceFunction2DParaCrystal
    InterferenceFunction2DParaCrystal_createSquare(double peak_distance) -> InterferenceFunction2DParaCrystal
    """
    return _libBornAgainCore.InterferenceFunction2DParaCrystal_createSquare(peak_distance, damping_length, domain_size_1, domain_size_2)

def InterferenceFunction2DParaCrystal_createHexagonal(peak_distance, damping_length=0.0, domain_size_1=0.0, domain_size_2=0.0):
    """
    createHexagonal(double peak_distance, double damping_length=0.0, double domain_size_1=0.0, double domain_size_2=0.0) -> InterferenceFunction2DParaCrystal
    createHexagonal(double peak_distance, double damping_length=0.0, double domain_size_1=0.0) -> InterferenceFunction2DParaCrystal
    createHexagonal(double peak_distance, double damping_length=0.0) -> InterferenceFunction2DParaCrystal
    InterferenceFunction2DParaCrystal_createHexagonal(double peak_distance) -> InterferenceFunction2DParaCrystal
    """
    return _libBornAgainCore.InterferenceFunction2DParaCrystal_createHexagonal(peak_distance, damping_length, domain_size_1, domain_size_2)

class InterferenceFunctionNone(IInterferenceFunction):
    """


    Default interference function (i.e. absence of any interference).

    C++ includes: InterferenceFunctionNone.h

    """

    __swig_setmethods__ = {}
    for _s in [IInterferenceFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InterferenceFunctionNone, name, value)
    __swig_getmethods__ = {}
    for _s in [IInterferenceFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InterferenceFunctionNone, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(InterferenceFunctionNone self) -> InterferenceFunctionNone

        InterferenceFunctionNone::InterferenceFunctionNone()

        """
        this = _libBornAgainCore.new_InterferenceFunctionNone()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(InterferenceFunctionNone self) -> InterferenceFunctionNone

        InterferenceFunctionNone* InterferenceFunctionNone::clone() const final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.InterferenceFunctionNone_clone(self)


    def accept(self, visitor):
        """
        accept(InterferenceFunctionNone self, ISampleVisitor visitor)

        void InterferenceFunctionNone::accept(ISampleVisitor *visitor) const final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.InterferenceFunctionNone_accept(self, visitor)


    def evaluate(self, arg2):
        """
        evaluate(InterferenceFunctionNone self, kvector_t arg2) -> double

        double InterferenceFunctionNone::evaluate(const kvector_t) const final

        Evaluates the interference function for a given wavevector transfer (only the real x and y components are relevant) 

        """
        return _libBornAgainCore.InterferenceFunctionNone_evaluate(self, arg2)

    __swig_destroy__ = _libBornAgainCore.delete_InterferenceFunctionNone
    __del__ = lambda self: None
InterferenceFunctionNone_swigregister = _libBornAgainCore.InterferenceFunctionNone_swigregister
InterferenceFunctionNone_swigregister(InterferenceFunctionNone)

class IPixelMap(_object):
    """


    Interface for a function that maps [0,1]x[0,1] to the kvectors in a pixel.

    C++ includes: IPixelMap.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPixelMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPixelMap, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_IPixelMap
    __del__ = lambda self: None

    def clone(self):
        """
        clone(IPixelMap self) -> IPixelMap

        virtual IPixelMap* IPixelMap::clone() const =0

        """
        return _libBornAgainCore.IPixelMap_clone(self)


    def createZeroSizeMap(self, x, y):
        """
        createZeroSizeMap(IPixelMap self, double x, double y) -> IPixelMap

        virtual IPixelMap* IPixelMap::createZeroSizeMap(double x, double y) const =0

        """
        return _libBornAgainCore.IPixelMap_createZeroSizeMap(self, x, y)


    def getK(self, x, y, wavelength):
        """
        getK(IPixelMap self, double x, double y, double wavelength) -> kvector_t

        virtual kvector_t IPixelMap::getK(double x, double y, double wavelength) const =0

        """
        return _libBornAgainCore.IPixelMap_getK(self, x, y, wavelength)


    def getIntegrationFactor(self, x, y):
        """
        getIntegrationFactor(IPixelMap self, double x, double y) -> double

        virtual double IPixelMap::getIntegrationFactor(double x, double y) const =0

        """
        return _libBornAgainCore.IPixelMap_getIntegrationFactor(self, x, y)


    def getSolidAngle(self):
        """
        getSolidAngle(IPixelMap self) -> double

        virtual double IPixelMap::getSolidAngle() const =0

        """
        return _libBornAgainCore.IPixelMap_getSolidAngle(self)

IPixelMap_swigregister = _libBornAgainCore.IPixelMap_swigregister
IPixelMap_swigregister(IPixelMap)

class SphericalDetector(IDetector2D):
    """


    A spherical detector with axes and resolution function.  SphericalDetector

    C++ includes: SphericalDetector.h

    """

    __swig_setmethods__ = {}
    for _s in [IDetector2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SphericalDetector, name, value)
    __swig_getmethods__ = {}
    for _s in [IDetector2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SphericalDetector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SphericalDetector self) -> SphericalDetector
        __init__(SphericalDetector self, size_t n_phi, double phi_min, double phi_max, size_t n_alpha, double alpha_min, double alpha_max) -> SphericalDetector
        __init__(SphericalDetector self, SphericalDetector other) -> SphericalDetector

        SphericalDetector::SphericalDetector(const SphericalDetector &other)

        """
        this = _libBornAgainCore.new_SphericalDetector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(SphericalDetector self) -> SphericalDetector

        SphericalDetector * SphericalDetector::clone() const override

        """
        return _libBornAgainCore.SphericalDetector_clone(self)

    __swig_destroy__ = _libBornAgainCore.delete_SphericalDetector
    __del__ = lambda self: None

    def getValidAxesUnits(self):
        """
        getValidAxesUnits(SphericalDetector self) -> std::vector< IDetector2D::EAxesUnits,std::allocator< IDetector2D::EAxesUnits > >

        std::vector< IDetector2D::EAxesUnits > SphericalDetector::getValidAxesUnits() const override

        returns vector of valid axes units 

        """
        return _libBornAgainCore.SphericalDetector_getValidAxesUnits(self)


    def getDefaultAxesUnits(self):
        """
        getDefaultAxesUnits(SphericalDetector self) -> IDetector2D::EAxesUnits

        IDetector2D::EAxesUnits SphericalDetector::getDefaultAxesUnits() const override

        return default axes units 

        """
        return _libBornAgainCore.SphericalDetector_getDefaultAxesUnits(self)

SphericalDetector_swigregister = _libBornAgainCore.SphericalDetector_swigregister
SphericalDetector_swigregister(SphericalDetector)

class AngularPixelMap(IPixelMap):
    """Proxy of C++ AngularPixelMap class."""

    __swig_setmethods__ = {}
    for _s in [IPixelMap]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AngularPixelMap, name, value)
    __swig_getmethods__ = {}
    for _s in [IPixelMap]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AngularPixelMap, name)
    __repr__ = _swig_repr

    def __init__(self, alpha_bin, phi_bin):
        """
        __init__(AngularPixelMap self, Bin1D alpha_bin, Bin1D phi_bin) -> AngularPixelMap

        AngularPixelMap::AngularPixelMap(Bin1D alpha_bin, Bin1D phi_bin)

        """
        this = _libBornAgainCore.new_AngularPixelMap(alpha_bin, phi_bin)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_AngularPixelMap
    __del__ = lambda self: None

    def clone(self):
        """
        clone(AngularPixelMap self) -> AngularPixelMap

        AngularPixelMap * AngularPixelMap::clone() const override

        """
        return _libBornAgainCore.AngularPixelMap_clone(self)


    def createZeroSizeMap(self, x, y):
        """
        createZeroSizeMap(AngularPixelMap self, double x, double y) -> AngularPixelMap

        AngularPixelMap * AngularPixelMap::createZeroSizeMap(double x, double y) const override

        """
        return _libBornAgainCore.AngularPixelMap_createZeroSizeMap(self, x, y)


    def getK(self, x, y, wavelength):
        """
        getK(AngularPixelMap self, double x, double y, double wavelength) -> kvector_t

        kvector_t AngularPixelMap::getK(double x, double y, double wavelength) const override

        """
        return _libBornAgainCore.AngularPixelMap_getK(self, x, y, wavelength)


    def getIntegrationFactor(self, x, y):
        """
        getIntegrationFactor(AngularPixelMap self, double x, double y) -> double

        double AngularPixelMap::getIntegrationFactor(double x, double y) const override

        """
        return _libBornAgainCore.AngularPixelMap_getIntegrationFactor(self, x, y)


    def getSolidAngle(self):
        """
        getSolidAngle(AngularPixelMap self) -> double

        double AngularPixelMap::getSolidAngle() const override

        """
        return _libBornAgainCore.AngularPixelMap_getSolidAngle(self)

AngularPixelMap_swigregister = _libBornAgainCore.AngularPixelMap_swigregister
AngularPixelMap_swigregister(AngularPixelMap)

class IsGISAXSDetector(SphericalDetector):
    """


    A spherical detector used for validation with IsGISAXS results.

    C++ includes: IsGISAXSDetector.h

    """

    __swig_setmethods__ = {}
    for _s in [SphericalDetector]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IsGISAXSDetector, name, value)
    __swig_getmethods__ = {}
    for _s in [SphericalDetector]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IsGISAXSDetector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IsGISAXSDetector self) -> IsGISAXSDetector
        __init__(IsGISAXSDetector self, size_t n_phi, double phi_min, double phi_max, size_t n_alpha, double alpha_min, double alpha_max) -> IsGISAXSDetector
        __init__(IsGISAXSDetector self, IsGISAXSDetector other) -> IsGISAXSDetector

        IsGISAXSDetector::IsGISAXSDetector(const IsGISAXSDetector &other)

        """
        this = _libBornAgainCore.new_IsGISAXSDetector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(IsGISAXSDetector self) -> IsGISAXSDetector

        IsGISAXSDetector * IsGISAXSDetector::clone() const override

        """
        return _libBornAgainCore.IsGISAXSDetector_clone(self)

    __swig_destroy__ = _libBornAgainCore.delete_IsGISAXSDetector
    __del__ = lambda self: None
IsGISAXSDetector_swigregister = _libBornAgainCore.IsGISAXSDetector_swigregister
IsGISAXSDetector_swigregister(IsGISAXSDetector)

class Lattice(_object):
    """


    A lattice with three basis vectors.

    C++ includes: Lattice.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Lattice, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Lattice, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Lattice self, kvector_t a1, kvector_t a2, kvector_t a3) -> Lattice
        __init__(Lattice self, Lattice lattice) -> Lattice

        Lattice::Lattice(const Lattice &lattice)

        """
        this = _libBornAgainCore.new_Lattice(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_Lattice
    __del__ = lambda self: None

    def createTransformedLattice(self, transform):
        """
        createTransformedLattice(Lattice self, Transform3D const & transform) -> Lattice

        Lattice Lattice::createTransformedLattice(const Transform3D &transform) const

        Create transformed lattice. 

        """
        return _libBornAgainCore.Lattice_createTransformedLattice(self, transform)


    def initialize(self):
        """
        initialize(Lattice self)

        void Lattice::initialize() const

        Initializes cached data. 

        """
        return _libBornAgainCore.Lattice_initialize(self)


    def getBasisVectorA(self):
        """
        getBasisVectorA(Lattice self) -> kvector_t

        kvector_t Lattice::getBasisVectorA() const

        Returns basis vector a. 

        """
        return _libBornAgainCore.Lattice_getBasisVectorA(self)


    def getBasisVectorB(self):
        """
        getBasisVectorB(Lattice self) -> kvector_t

        kvector_t Lattice::getBasisVectorB() const

        Returns basis vector b. 

        """
        return _libBornAgainCore.Lattice_getBasisVectorB(self)


    def getBasisVectorC(self):
        """
        getBasisVectorC(Lattice self) -> kvector_t

        kvector_t Lattice::getBasisVectorC() const

        Returns basis vector c. 

        """
        return _libBornAgainCore.Lattice_getBasisVectorC(self)


    def getVolume(self):
        """
        getVolume(Lattice self) -> double

        double Lattice::getVolume() const

        Returns the volume of the unit cell. 

        """
        return _libBornAgainCore.Lattice_getVolume(self)


    def getReciprocalLatticeBasis(self, b1, b2, b3):
        """
        getReciprocalLatticeBasis(Lattice self, kvector_t b1, kvector_t b2, kvector_t b3)

        void Lattice::getReciprocalLatticeBasis(kvector_t b1, kvector_t b2, kvector_t b3) const

        Returns the reciprocal basis vectors. 

        """
        return _libBornAgainCore.Lattice_getReciprocalLatticeBasis(self, b1, b2, b3)


    def getNearestLatticeVectorCoordinates(self, vector_in):
        """
        getNearestLatticeVectorCoordinates(Lattice self, kvector_t vector_in) -> ivector_t

        ivector_t Lattice::getNearestLatticeVectorCoordinates(const kvector_t vector_in) const

        Returns the nearest lattice point from a given vector. 

        """
        return _libBornAgainCore.Lattice_getNearestLatticeVectorCoordinates(self, vector_in)


    def getNearestReciprocalLatticeVectorCoordinates(self, vector_in):
        """
        getNearestReciprocalLatticeVectorCoordinates(Lattice self, kvector_t vector_in) -> ivector_t

        ivector_t Lattice::getNearestReciprocalLatticeVectorCoordinates(const kvector_t vector_in) const

        Returns the nearest reciprocal lattice point from a given vector. 

        """
        return _libBornAgainCore.Lattice_getNearestReciprocalLatticeVectorCoordinates(self, vector_in)


    def reciprocalLatticeVectorsWithinRadius(self, input_vector, radius):
        """
        reciprocalLatticeVectorsWithinRadius(Lattice self, kvector_t input_vector, double radius) -> vector_kvector_t

        std::vector< kvector_t > Lattice::reciprocalLatticeVectorsWithinRadius(const kvector_t input_vector, double radius) const

        Computes a list of reciprocal lattice vectors within a specified distance of a given vector. 

        """
        return _libBornAgainCore.Lattice_reciprocalLatticeVectorsWithinRadius(self, input_vector, radius)


    def setSelectionRule(self, p_selection_rule):
        """
        setSelectionRule(Lattice self, ISelectionRule p_selection_rule)

        void Lattice::setSelectionRule(const ISelectionRule &p_selection_rule)

        Sets a selection rule for the reciprocal vectors. 

        """
        return _libBornAgainCore.Lattice_setSelectionRule(self, p_selection_rule)


    def createFCCLattice(a):
        """createFCCLattice(double a) -> Lattice"""
        return _libBornAgainCore.Lattice_createFCCLattice(a)

    if _newclass:
        createFCCLattice = staticmethod(createFCCLattice)
    __swig_getmethods__["createFCCLattice"] = lambda x: createFCCLattice

    def createTrigonalLattice(a, c):
        """createTrigonalLattice(double a, double c) -> Lattice"""
        return _libBornAgainCore.Lattice_createTrigonalLattice(a, c)

    if _newclass:
        createTrigonalLattice = staticmethod(createTrigonalLattice)
    __swig_getmethods__["createTrigonalLattice"] = lambda x: createTrigonalLattice
Lattice_swigregister = _libBornAgainCore.Lattice_swigregister
Lattice_swigregister(Lattice)

def Lattice_createFCCLattice(a):
    """Lattice_createFCCLattice(double a) -> Lattice"""
    return _libBornAgainCore.Lattice_createFCCLattice(a)

def Lattice_createTrigonalLattice(a, c):
    """Lattice_createTrigonalLattice(double a, double c) -> Lattice"""
    return _libBornAgainCore.Lattice_createTrigonalLattice(a, c)

class Lattice1DParameters(_object):
    """


    Basic parameters of a one-dimensional lattice.

    C++ includes: Lattice1DParameters.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Lattice1DParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Lattice1DParameters, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Lattice1DParameters self) -> Lattice1DParameters
        __init__(Lattice1DParameters self, double length, double xi) -> Lattice1DParameters

        Lattice1DParameters::Lattice1DParameters(double length, double xi)

        Parameters:
        -----------

        length: 
         Lattice constant.

        xi: 
        TODO: seems unused; explain or remove 

        """
        this = _libBornAgainCore.new_Lattice1DParameters(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["m_length"] = _libBornAgainCore.Lattice1DParameters_m_length_set
    __swig_getmethods__["m_length"] = _libBornAgainCore.Lattice1DParameters_m_length_get
    if _newclass:
        m_length = _swig_property(_libBornAgainCore.Lattice1DParameters_m_length_get, _libBornAgainCore.Lattice1DParameters_m_length_set)
    __swig_setmethods__["m_xi"] = _libBornAgainCore.Lattice1DParameters_m_xi_set
    __swig_getmethods__["m_xi"] = _libBornAgainCore.Lattice1DParameters_m_xi_get
    if _newclass:
        m_xi = _swig_property(_libBornAgainCore.Lattice1DParameters_m_xi_get, _libBornAgainCore.Lattice1DParameters_m_xi_set)
    __swig_destroy__ = _libBornAgainCore.delete_Lattice1DParameters
    __del__ = lambda self: None
Lattice1DParameters_swigregister = _libBornAgainCore.Lattice1DParameters_swigregister
Lattice1DParameters_swigregister(Lattice1DParameters)

class Lattice2DParameters(_object):
    """


    Additional parameters for 2D lattice.

    C++ includes: Lattice2DParameters.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Lattice2DParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Lattice2DParameters, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(Lattice2DParameters self) -> Lattice2DParameters

        Lattice2DParameters::Lattice2DParameters()

        """
        this = _libBornAgainCore.new_Lattice2DParameters()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def getUnitCellArea(self):
        """
        getUnitCellArea(Lattice2DParameters self) -> double

        double Lattice2DParameters::getUnitCellArea() const

        """
        return _libBornAgainCore.Lattice2DParameters_getUnitCellArea(self)

    __swig_setmethods__["m_length_1"] = _libBornAgainCore.Lattice2DParameters_m_length_1_set
    __swig_getmethods__["m_length_1"] = _libBornAgainCore.Lattice2DParameters_m_length_1_get
    if _newclass:
        m_length_1 = _swig_property(_libBornAgainCore.Lattice2DParameters_m_length_1_get, _libBornAgainCore.Lattice2DParameters_m_length_1_set)
    __swig_setmethods__["m_length_2"] = _libBornAgainCore.Lattice2DParameters_m_length_2_set
    __swig_getmethods__["m_length_2"] = _libBornAgainCore.Lattice2DParameters_m_length_2_get
    if _newclass:
        m_length_2 = _swig_property(_libBornAgainCore.Lattice2DParameters_m_length_2_get, _libBornAgainCore.Lattice2DParameters_m_length_2_set)
    __swig_setmethods__["m_angle"] = _libBornAgainCore.Lattice2DParameters_m_angle_set
    __swig_getmethods__["m_angle"] = _libBornAgainCore.Lattice2DParameters_m_angle_get
    if _newclass:
        m_angle = _swig_property(_libBornAgainCore.Lattice2DParameters_m_angle_get, _libBornAgainCore.Lattice2DParameters_m_angle_set)
    __swig_setmethods__["m_xi"] = _libBornAgainCore.Lattice2DParameters_m_xi_set
    __swig_getmethods__["m_xi"] = _libBornAgainCore.Lattice2DParameters_m_xi_get
    if _newclass:
        m_xi = _swig_property(_libBornAgainCore.Lattice2DParameters_m_xi_get, _libBornAgainCore.Lattice2DParameters_m_xi_set)
    __swig_destroy__ = _libBornAgainCore.delete_Lattice2DParameters
    __del__ = lambda self: None
Lattice2DParameters_swigregister = _libBornAgainCore.Lattice2DParameters_swigregister
Lattice2DParameters_swigregister(Lattice2DParameters)

class Layer(ICompositeSample):
    """


    A layer, with thickness (in nanometer) and material.

    C++ includes: Layer.h

    """

    __swig_setmethods__ = {}
    for _s in [ICompositeSample]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Layer, name, value)
    __swig_getmethods__ = {}
    for _s in [ICompositeSample]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Layer, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Layer self) -> Layer
        __init__(Layer self, IMaterial material, double thickness=0) -> Layer
        __init__(Layer self, IMaterial material) -> Layer

        Layer::Layer(const IMaterial &material, double thickness=0)

        """
        this = _libBornAgainCore.new_Layer(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_Layer
    __del__ = lambda self: None

    def clone(self):
        """
        clone(Layer self) -> Layer

        Layer* Layer::clone() const final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.Layer_clone(self)


    def cloneInvertB(self):
        """
        cloneInvertB(Layer self) -> Layer

        Layer * Layer::cloneInvertB() const final

        Returns a clone with inverted magnetic fields. 

        """
        return _libBornAgainCore.Layer_cloneInvertB(self)


    def accept(self, visitor):
        """
        accept(Layer self, ISampleVisitor visitor)

        void Layer::accept(ISampleVisitor *visitor) const final

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.Layer_accept(self, visitor)


    def to_str(self, indent=0):
        """
        to_str(Layer self, int indent=0) -> std::string
        to_str(Layer self) -> std::string

        std::string Layer::to_str(int indent=0) const final

        Returns textual representation of this and its descendants. 

        """
        return _libBornAgainCore.Layer_to_str(self, indent)


    def setThickness(self, thickness):
        """
        setThickness(Layer self, double thickness)

        void Layer::setThickness(double thickness)

        Sets layer thickness in nanometers. 

        """
        return _libBornAgainCore.Layer_setThickness(self, thickness)


    def getThickness(self):
        """
        getThickness(Layer self) -> double

        double Layer::getThickness() const

        """
        return _libBornAgainCore.Layer_getThickness(self)


    def setMaterial(self, material):
        """
        setMaterial(Layer self, IMaterial material)

        void Layer::setMaterial(const IMaterial &material)

        Sets  material of the layer. 

        """
        return _libBornAgainCore.Layer_setMaterial(self, material)


    def getMaterial(self):
        """
        getMaterial(Layer self) -> IMaterial

        const IMaterial* Layer::getMaterial() const

        Returns nullptr, unless overwritten to return a specific material. 

        """
        return _libBornAgainCore.Layer_getMaterial(self)


    def getRefractiveIndex(self):
        """
        getRefractiveIndex(Layer self) -> complex_t

        complex_t Layer::getRefractiveIndex() const

        """
        return _libBornAgainCore.Layer_getRefractiveIndex(self)


    def getRefractiveIndex2(self):
        """
        getRefractiveIndex2(Layer self) -> complex_t

        complex_t Layer::getRefractiveIndex2() const

        squared refractive index 

        """
        return _libBornAgainCore.Layer_getRefractiveIndex2(self)


    def addLayout(self, decoration):
        """
        addLayout(Layer self, ILayout decoration)

        void Layer::addLayout(const ILayout &decoration)

        """
        return _libBornAgainCore.Layer_addLayout(self, decoration)


    def getNumberOfLayouts(self):
        """
        getNumberOfLayouts(Layer self) -> size_t

        size_t Layer::getNumberOfLayouts() const

        """
        return _libBornAgainCore.Layer_getNumberOfLayouts(self)


    def getLayout(self, i):
        """
        getLayout(Layer self, size_t i) -> ILayout

        const ILayout * Layer::getLayout(size_t i) const

        """
        return _libBornAgainCore.Layer_getLayout(self, i)


    def hasComputation(self):
        """
        hasComputation(Layer self) -> bool

        bool Layer::hasComputation() const

        Returns true if decoration is present. 

        """
        return _libBornAgainCore.Layer_hasComputation(self)


    def getTotalParticleSurfaceDensity(self, layout_index):
        """
        getTotalParticleSurfaceDensity(Layer self, size_t layout_index) -> double

        double Layer::getTotalParticleSurfaceDensity(size_t layout_index) const

        """
        return _libBornAgainCore.Layer_getTotalParticleSurfaceDensity(self, layout_index)


    def getTotalAbundance(self):
        """
        getTotalAbundance(Layer self) -> double

        double Layer::getTotalAbundance() const

        """
        return _libBornAgainCore.Layer_getTotalAbundance(self)


    def setNumberOfLayers(self, n_layers):
        """
        setNumberOfLayers(Layer self, size_t n_layers)

        void Layer::setNumberOfLayers(size_t n_layers)

        """
        return _libBornAgainCore.Layer_setNumberOfLayers(self, n_layers)


    def getNumberOfLayers(self):
        """
        getNumberOfLayers(Layer self) -> size_t

        size_t Layer::getNumberOfLayers() const

        """
        return _libBornAgainCore.Layer_getNumberOfLayers(self)

Layer_swigregister = _libBornAgainCore.Layer_swigregister
Layer_swigregister(Layer)

class IRoughness(ISample):
    """


    Interface to equip an interface with a roughness.

    C++ includes: IRoughness.h

    """

    __swig_setmethods__ = {}
    for _s in [ISample]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IRoughness, name, value)
    __swig_getmethods__ = {}
    for _s in [ISample]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IRoughness, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libBornAgainCore.delete_IRoughness
    __del__ = lambda self: None

    def accept(self, visitor):
        """
        accept(IRoughness self, ISampleVisitor visitor)

        virtual void IRoughness::accept(ISampleVisitor *visitor) const

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.IRoughness_accept(self, visitor)

IRoughness_swigregister = _libBornAgainCore.IRoughness_swigregister
IRoughness_swigregister(IRoughness)

class LayerRoughness(IRoughness):
    """


    A Roughness of interface between two layers.

    Based on the article D.K.G. de Boer, Physical review B, Volume 51, Number 8, 15 February 1995 "X-ray reflection and transmission by rough surfaces"

    C++ includes: LayerRoughness.h

    """

    __swig_setmethods__ = {}
    for _s in [IRoughness]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LayerRoughness, name, value)
    __swig_getmethods__ = {}
    for _s in [IRoughness]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LayerRoughness, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LayerRoughness self) -> LayerRoughness
        __init__(LayerRoughness self, double sigma, double hurstParameter, double lateralCorrLength) -> LayerRoughness

        LayerRoughness::LayerRoughness(double sigma, double hurstParameter, double latteralCorrLength)

        """
        this = _libBornAgainCore.new_LayerRoughness(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(LayerRoughness self) -> LayerRoughness

        LayerRoughness* LayerRoughness::clone() const

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.LayerRoughness_clone(self)


    def accept(self, visitor):
        """
        accept(LayerRoughness self, ISampleVisitor visitor)

        virtual void LayerRoughness::accept(ISampleVisitor *visitor) const

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.LayerRoughness_accept(self, visitor)


    def getSpectralFun(self, kvec):
        """
        getSpectralFun(LayerRoughness self, kvector_t kvec) -> double

        double LayerRoughness::getSpectralFun(const kvector_t kvec) const

        Returns power spectral density of the surface roughness.

        Power spectral density of the surface roughness is a result of two-dimensional Fourier transform of the correlation function of the roughness profile.

        Based on the article D.K.G. de Boer, Physical review B, Volume 51, Number 8, 15 February 1995 "X-ray reflection and transmission by rough surfaces" 

        """
        return _libBornAgainCore.LayerRoughness_getSpectralFun(self, kvec)


    def getCorrFun(self, k):
        """
        getCorrFun(LayerRoughness self, kvector_t k) -> double

        double LayerRoughness::getCorrFun(const kvector_t k) const

        Correlation function of the roughness profile. 

        """
        return _libBornAgainCore.LayerRoughness_getCorrFun(self, k)


    def setSigma(self, sigma):
        """
        setSigma(LayerRoughness self, double sigma)

        void LayerRoughness::setSigma(double sigma)

        Sets rms of roughness. 

        """
        return _libBornAgainCore.LayerRoughness_setSigma(self, sigma)


    def getSigma(self):
        """
        getSigma(LayerRoughness self) -> double

        double LayerRoughness::getSigma() const

        Returns rms of roughness. 

        """
        return _libBornAgainCore.LayerRoughness_getSigma(self)


    def setHurstParameter(self, hurstParameter):
        """
        setHurstParameter(LayerRoughness self, double hurstParameter)

        void LayerRoughness::setHurstParameter(double hurstParameter)

        Sets hurst parameter. It describes how jagged the surface is. 

        """
        return _libBornAgainCore.LayerRoughness_setHurstParameter(self, hurstParameter)


    def getHurstParameter(self):
        """
        getHurstParameter(LayerRoughness self) -> double

        double LayerRoughness::getHurstParameter() const

        Returns hurst parameter. 

        """
        return _libBornAgainCore.LayerRoughness_getHurstParameter(self)


    def setLatteralCorrLength(self, lateralCorrLength):
        """
        setLatteralCorrLength(LayerRoughness self, double lateralCorrLength)

        void LayerRoughness::setLatteralCorrLength(double latteralCorrLength)

        Sets lateral correlation length. 

        """
        return _libBornAgainCore.LayerRoughness_setLatteralCorrLength(self, lateralCorrLength)


    def getLatteralCorrLength(self):
        """
        getLatteralCorrLength(LayerRoughness self) -> double

        double LayerRoughness::getLatteralCorrLength() const

        Returns latteral correlation length. 

        """
        return _libBornAgainCore.LayerRoughness_getLatteralCorrLength(self)

    __swig_destroy__ = _libBornAgainCore.delete_LayerRoughness
    __del__ = lambda self: None
LayerRoughness_swigregister = _libBornAgainCore.LayerRoughness_swigregister
LayerRoughness_swigregister(LayerRoughness)

class Line(IShape2D):
    """Proxy of C++ Line class."""

    __swig_setmethods__ = {}
    for _s in [IShape2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Line, name, value)
    __swig_getmethods__ = {}
    for _s in [IShape2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Line, name)
    __repr__ = _swig_repr

    def __init__(self, x1, y1, x2, y2):
        """__init__(Line self, double x1, double y1, double x2, double y2) -> Line"""
        this = _libBornAgainCore.new_Line(x1, y1, x2, y2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(Line self) -> Line

        virtual ICloneable* ICloneable::clone() const =0

        """
        return _libBornAgainCore.Line_clone(self)


    def contains(self, *args):
        """
        contains(Line self, double x, double y) -> bool
        contains(Line self, Bin1D binx, Bin1D biny) -> bool
        """
        return _libBornAgainCore.Line_contains(self, *args)

    __swig_destroy__ = _libBornAgainCore.delete_Line
    __del__ = lambda self: None
Line_swigregister = _libBornAgainCore.Line_swigregister
Line_swigregister(Line)

class VerticalLine(IShape2D):
    """Proxy of C++ VerticalLine class."""

    __swig_setmethods__ = {}
    for _s in [IShape2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VerticalLine, name, value)
    __swig_getmethods__ = {}
    for _s in [IShape2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VerticalLine, name)
    __repr__ = _swig_repr

    def __init__(self, x):
        """__init__(VerticalLine self, double x) -> VerticalLine"""
        this = _libBornAgainCore.new_VerticalLine(x)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(VerticalLine self) -> VerticalLine

        virtual ICloneable* ICloneable::clone() const =0

        """
        return _libBornAgainCore.VerticalLine_clone(self)


    def contains(self, *args):
        """
        contains(VerticalLine self, double x, double y) -> bool
        contains(VerticalLine self, Bin1D binx, Bin1D biny) -> bool
        """
        return _libBornAgainCore.VerticalLine_contains(self, *args)


    def getXpos(self):
        """getXpos(VerticalLine self) -> double"""
        return _libBornAgainCore.VerticalLine_getXpos(self)

    __swig_destroy__ = _libBornAgainCore.delete_VerticalLine
    __del__ = lambda self: None
VerticalLine_swigregister = _libBornAgainCore.VerticalLine_swigregister
VerticalLine_swigregister(VerticalLine)

class HorizontalLine(IShape2D):
    """Proxy of C++ HorizontalLine class."""

    __swig_setmethods__ = {}
    for _s in [IShape2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HorizontalLine, name, value)
    __swig_getmethods__ = {}
    for _s in [IShape2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HorizontalLine, name)
    __repr__ = _swig_repr

    def __init__(self, y):
        """__init__(HorizontalLine self, double y) -> HorizontalLine"""
        this = _libBornAgainCore.new_HorizontalLine(y)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(HorizontalLine self) -> HorizontalLine

        virtual ICloneable* ICloneable::clone() const =0

        """
        return _libBornAgainCore.HorizontalLine_clone(self)


    def contains(self, *args):
        """
        contains(HorizontalLine self, double x, double y) -> bool
        contains(HorizontalLine self, Bin1D binx, Bin1D biny) -> bool
        """
        return _libBornAgainCore.HorizontalLine_contains(self, *args)


    def getYpos(self):
        """getYpos(HorizontalLine self) -> double"""
        return _libBornAgainCore.HorizontalLine_getYpos(self)

    __swig_destroy__ = _libBornAgainCore.delete_HorizontalLine
    __del__ = lambda self: None
HorizontalLine_swigregister = _libBornAgainCore.HorizontalLine_swigregister
HorizontalLine_swigregister(HorizontalLine)

class MesoCrystal(IParticle):
    """


    A particle with an internal structure of smaller particles.

    C++ includes: MesoCrystal.h

    """

    __swig_setmethods__ = {}
    for _s in [IParticle]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MesoCrystal, name, value)
    __swig_getmethods__ = {}
    for _s in [IParticle]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MesoCrystal, name)
    __repr__ = _swig_repr

    def __init__(self, particle_structure, form_factor):
        """
        __init__(MesoCrystal self, IClusteredParticles particle_structure, IFormFactor form_factor) -> MesoCrystal

        MesoCrystal::MesoCrystal(const IClusteredParticles &particle_structure, IFormFactor &form_factor)

        """
        this = _libBornAgainCore.new_MesoCrystal(particle_structure, form_factor)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_MesoCrystal
    __del__ = lambda self: None

    def clone(self):
        """
        clone(MesoCrystal self) -> MesoCrystal

        MesoCrystal * MesoCrystal::clone() const

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.MesoCrystal_clone(self)


    def cloneInvertB(self):
        """
        cloneInvertB(MesoCrystal self) -> MesoCrystal

        MesoCrystal * MesoCrystal::cloneInvertB() const

        Returns a clone with inverted magnetic fields. 

        """
        return _libBornAgainCore.MesoCrystal_cloneInvertB(self)


    def accept(self, visitor):
        """
        accept(MesoCrystal self, ISampleVisitor visitor)

        void MesoCrystal::accept(ISampleVisitor *visitor) const

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.MesoCrystal_accept(self, visitor)


    def setAmbientMaterial(self, material):
        """
        setAmbientMaterial(MesoCrystal self, IMaterial material)

        void MesoCrystal::setAmbientMaterial(const IMaterial &material)

        Sets the refractive index of the ambient material (which influences its scattering power) 

        """
        return _libBornAgainCore.MesoCrystal_setAmbientMaterial(self, material)


    def getAmbientMaterial(self):
        """
        getAmbientMaterial(MesoCrystal self) -> IMaterial

        const IMaterial * MesoCrystal::getAmbientMaterial() const

        Returns nullptr, unless overwritten to return a specific material. 

        """
        return _libBornAgainCore.MesoCrystal_getAmbientMaterial(self)


    def createTransformedFormFactor(self, p_rotation, translation):
        """
        createTransformedFormFactor(MesoCrystal self, IRotation p_rotation, kvector_t translation) -> IFormFactor

        IFormFactor * MesoCrystal::createTransformedFormFactor(const IRotation *p_rotation, kvector_t translation) const

        Create a form factor for this particle with an extra scattering factor. 

        """
        return _libBornAgainCore.MesoCrystal_createTransformedFormFactor(self, p_rotation, translation)


    def getClusteredParticles(self):
        """
        getClusteredParticles(MesoCrystal self) -> IClusteredParticles

        const IClusteredParticles* MesoCrystal::getClusteredParticles() const

        get the internal structure, which is in principle unbounded in space (e.g. an infinite crystal) 

        """
        return _libBornAgainCore.MesoCrystal_getClusteredParticles(self)

MesoCrystal_swigregister = _libBornAgainCore.MesoCrystal_swigregister
MesoCrystal_swigregister(MesoCrystal)


_libBornAgainCore.VERBOSE_swigconstant(_libBornAgainCore)
VERBOSE = _libBornAgainCore.VERBOSE

_libBornAgainCore.DEBUG2_swigconstant(_libBornAgainCore)
DEBUG2 = _libBornAgainCore.DEBUG2

_libBornAgainCore.DEBUG_swigconstant(_libBornAgainCore)
DEBUG = _libBornAgainCore.DEBUG

_libBornAgainCore.INFO_swigconstant(_libBornAgainCore)
INFO = _libBornAgainCore.INFO

_libBornAgainCore.WARNING_swigconstant(_libBornAgainCore)
WARNING = _libBornAgainCore.WARNING

_libBornAgainCore.ERROR_swigconstant(_libBornAgainCore)
ERROR = _libBornAgainCore.ERROR

_libBornAgainCore.FATAL_swigconstant(_libBornAgainCore)
FATAL = _libBornAgainCore.FATAL
class Logger(_object):
    """Proxy of C++ Logging::Logger class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Logger, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Logger, name)
    __repr__ = _swig_repr

    def __init__(self, level):
        """__init__(Logging::Logger self, Logging::EMessageLevel level) -> Logger"""
        this = _libBornAgainCore.new_Logger(level)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_Logger
    __del__ = lambda self: None

    def nowTime(self):
        """nowTime(Logger self) -> std::string"""
        return _libBornAgainCore.Logger_nowTime(self)


    def toString(self, level):
        """toString(Logger self, Logging::EMessageLevel level) -> std::string const &"""
        return _libBornAgainCore.Logger_toString(self, level)


    def setLevel(*args):
        """
        setLevel(Logging::EMessageLevel level)
        setLevel(std::string const & levelname)
        """
        return _libBornAgainCore.Logger_setLevel(*args)

    if _newclass:
        setLevel = staticmethod(setLevel)
    __swig_getmethods__["setLevel"] = lambda x: setLevel

    def level():
        """level() -> Logging::EMessageLevel"""
        return _libBornAgainCore.Logger_level()

    if _newclass:
        level = staticmethod(level)
    __swig_getmethods__["level"] = lambda x: level
Logger_swigregister = _libBornAgainCore.Logger_swigregister
Logger_swigregister(Logger)

def Logger_setLevel(*args):
    """
    setLevel(Logging::EMessageLevel level)
    Logger_setLevel(std::string const & levelname)
    """
    return _libBornAgainCore.Logger_setLevel(*args)

def Logger_level():
    """Logger_level() -> Logging::EMessageLevel"""
    return _libBornAgainCore.Logger_level()


def setLevel(*args):
    """
    setLevel(Logging::EMessageLevel level)
    setLevel(std::string const & levelname)
    """
    return _libBornAgainCore.setLevel(*args)
class MultiLayer(ICompositeSample):
    """


    Our sample model: a stack of layers one below the other.Example of system of 4 layers (3 interfaces):

    ambience layer #0 z=getLayerBottomZ(0)=0.0 ------ interface #0 Fe, 20A layer #1 z=getLayerBottomZ(1)=-20.0 ------ interface #1 Cr, 40A layer #2 z=getLayerBottomZ(2)=-60.0 ------ interface #2 substrate layer #3 z=getLayerBottomZ(3)=-60.0

    C++ includes: MultiLayer.h

    """

    __swig_setmethods__ = {}
    for _s in [ICompositeSample]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiLayer, name, value)
    __swig_getmethods__ = {}
    for _s in [ICompositeSample]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MultiLayer, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(MultiLayer self) -> MultiLayer

        MultiLayer::MultiLayer()

        """
        this = _libBornAgainCore.new_MultiLayer()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_MultiLayer
    __del__ = lambda self: None

    def accept(self, visitor):
        """
        accept(MultiLayer self, ISampleVisitor visitor)

        virtual void MultiLayer::accept(ISampleVisitor *visitor) const

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.MultiLayer_accept(self, visitor)


    def to_str(self, indent=0):
        """
        to_str(MultiLayer self, int indent=0) -> std::string
        to_str(MultiLayer self) -> std::string

        std::string MultiLayer::to_str(int indent=0) const

        Returns textual representation of this and its descendants. 

        """
        return _libBornAgainCore.MultiLayer_to_str(self, indent)


    def getNumberOfLayers(self):
        """
        getNumberOfLayers(MultiLayer self) -> size_t

        size_t MultiLayer::getNumberOfLayers() const

        """
        return _libBornAgainCore.MultiLayer_getNumberOfLayers(self)


    def getNumberOfInterfaces(self):
        """
        getNumberOfInterfaces(MultiLayer self) -> size_t

        size_t MultiLayer::getNumberOfInterfaces() const

        """
        return _libBornAgainCore.MultiLayer_getNumberOfInterfaces(self)


    def addLayer(self, p_child):
        """
        addLayer(MultiLayer self, Layer p_child)

        void MultiLayer::addLayer(const Layer &p_child)

        Adds object to multilayer, overrides from  ISample.

        Adds layer with default (zero) roughness. 

        """
        return _libBornAgainCore.MultiLayer_addLayer(self, p_child)


    def addLayerWithTopRoughness(self, layer, roughness):
        """
        addLayerWithTopRoughness(MultiLayer self, Layer layer, LayerRoughness roughness)

        void MultiLayer::addLayerWithTopRoughness(const Layer &layer, const LayerRoughness &roughness)

        Adds layer with top roughness. 

        """
        return _libBornAgainCore.MultiLayer_addLayerWithTopRoughness(self, layer, roughness)


    def getLayer(self, i_layer):
        """
        getLayer(MultiLayer self, size_t i_layer) -> Layer

        const Layer* MultiLayer::getLayer(size_t i_layer) const

        Returns layer with given index. 

        """
        return _libBornAgainCore.MultiLayer_getLayer(self, i_layer)


    def getLayerInterface(self, i_interface):
        """
        getLayerInterface(MultiLayer self, size_t i_interface) -> LayerInterface const *

        const LayerInterface* MultiLayer::getLayerInterface(size_t i_interface) const

        Returns layer with given index. 

        """
        return _libBornAgainCore.MultiLayer_getLayerInterface(self, i_interface)


    def getLayerBottomZ(self, i_layer):
        """
        getLayerBottomZ(MultiLayer self, size_t i_layer) -> double

        double MultiLayer::getLayerBottomZ(size_t i_layer) const

        Returns z-coordinate of the layer's bottom. 

        """
        return _libBornAgainCore.MultiLayer_getLayerBottomZ(self, i_layer)


    def getLayerThickness(self, i_layer):
        """
        getLayerThickness(MultiLayer self, size_t i_layer) -> double

        double MultiLayer::getLayerThickness(size_t i_layer) const

        Returns thickness of layer. 

        """
        return _libBornAgainCore.MultiLayer_getLayerThickness(self, i_layer)


    def getLayerTopInterface(self, i_layer):
        """
        getLayerTopInterface(MultiLayer self, size_t i_layer) -> LayerInterface const *

        const LayerInterface * MultiLayer::getLayerTopInterface(size_t i_layer) const

        Returns top interface of layer.

        Returns pointer to the top interface of the layer. nInterfaces = nLayers-1, first layer in multilayer doesn't have interface. 

        """
        return _libBornAgainCore.MultiLayer_getLayerTopInterface(self, i_layer)


    def getLayerBottomInterface(self, i_layer):
        """
        getLayerBottomInterface(MultiLayer self, size_t i_layer) -> LayerInterface const *

        const LayerInterface * MultiLayer::getLayerBottomInterface(size_t i_layer) const

        Returns bottom interface of layer.

        Returns pointer to the bottom interface of the layer. 

        """
        return _libBornAgainCore.MultiLayer_getLayerBottomInterface(self, i_layer)


    def clear(self):
        """
        clear(MultiLayer self)

        void MultiLayer::clear()

        Destructs allocated objects. 

        """
        return _libBornAgainCore.MultiLayer_clear(self)


    def clone(self):
        """
        clone(MultiLayer self) -> MultiLayer

        MultiLayer * MultiLayer::clone() const

        Returns alone of multilayer with clones of all layers and recreated interfaces between layers 

        """
        return _libBornAgainCore.MultiLayer_clone(self)


    def cloneInvertB(self):
        """
        cloneInvertB(MultiLayer self) -> MultiLayer

        MultiLayer * MultiLayer::cloneInvertB() const

        Returns a clone with inverted magnetic fields. 

        """
        return _libBornAgainCore.MultiLayer_cloneInvertB(self)


    def setCrossCorrLength(self, crossCorrLength):
        """
        setCrossCorrLength(MultiLayer self, double crossCorrLength)

        void MultiLayer::setCrossCorrLength(double crossCorrLength)

        Sets cross correlation length of roughnesses between interfaces. 

        """
        return _libBornAgainCore.MultiLayer_setCrossCorrLength(self, crossCorrLength)


    def getCrossCorrLength(self):
        """
        getCrossCorrLength(MultiLayer self) -> double

        double MultiLayer::getCrossCorrLength() const

        Returns cross correlation length of roughnesses between interfaces. 

        """
        return _libBornAgainCore.MultiLayer_getCrossCorrLength(self)


    def getCrossCorrSpectralFun(self, kvec, j, k):
        """
        getCrossCorrSpectralFun(MultiLayer self, kvector_t kvec, size_t j, size_t k) -> double

        double MultiLayer::getCrossCorrSpectralFun(const kvector_t kvec, size_t j, size_t k) const

        ! correlation function of roughnesses between the interfaces

        Fourier transform of the correlation function of roughnesses between the interfaces

        Fourier transform of the correlation function of roughnesses between the interfaces j,k - indexes of layers in multilayer whose bottom interfaces we are considering 

        """
        return _libBornAgainCore.MultiLayer_getCrossCorrSpectralFun(self, kvec, j, k)


    def setLayerThickness(self, i_layer, thickness):
        """
        setLayerThickness(MultiLayer self, size_t i_layer, double thickness)

        void MultiLayer::setLayerThickness(size_t i_layer, double thickness)

        Sets thickness of layer. 

        """
        return _libBornAgainCore.MultiLayer_setLayerThickness(self, i_layer, thickness)


    def getIndexOfLayer(self, layer):
        """
        getIndexOfLayer(MultiLayer self, Layer layer) -> int

        int MultiLayer::getIndexOfLayer(const Layer *layer) const

        returns layer index 

        """
        return _libBornAgainCore.MultiLayer_getIndexOfLayer(self, layer)


    def requiresMatrixRTCoefficients(self):
        """
        requiresMatrixRTCoefficients(MultiLayer self) -> bool

        bool MultiLayer::requiresMatrixRTCoefficients() const

        returns true if contains magnetic materials and matrix calculations are required 

        """
        return _libBornAgainCore.MultiLayer_requiresMatrixRTCoefficients(self)


    def zToLayerIndex(self, z_value):
        """
        zToLayerIndex(MultiLayer self, double z_value) -> size_t

        size_t MultiLayer::zToLayerIndex(double z_value)

        returns layer index corresponding to given global z coordinate 

        """
        return _libBornAgainCore.MultiLayer_zToLayerIndex(self, z_value)


    def containsMagneticMaterial(self):
        """
        containsMagneticMaterial(MultiLayer self) -> bool

        bool MultiLayer::containsMagneticMaterial() const

        """
        return _libBornAgainCore.MultiLayer_containsMagneticMaterial(self)


    def hasRoughness(self):
        """
        hasRoughness(MultiLayer self) -> bool

        bool MultiLayer::hasRoughness() const

        """
        return _libBornAgainCore.MultiLayer_hasRoughness(self)


    def totalNofLayouts(self):
        """
        totalNofLayouts(MultiLayer self) -> size_t

        size_t MultiLayer::totalNofLayouts() const

        """
        return _libBornAgainCore.MultiLayer_totalNofLayouts(self)

MultiLayer_swigregister = _libBornAgainCore.MultiLayer_swigregister
MultiLayer_swigregister(MultiLayer)

class OffSpecSimulation(Simulation):
    """


    Main class to run an off-specular simulation.

    C++ includes: OffSpecSimulation.h

    """

    __swig_setmethods__ = {}
    for _s in [Simulation]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OffSpecSimulation, name, value)
    __swig_getmethods__ = {}
    for _s in [Simulation]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OffSpecSimulation, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OffSpecSimulation self) -> OffSpecSimulation
        __init__(OffSpecSimulation self, MultiLayer p_sample) -> OffSpecSimulation
        __init__(OffSpecSimulation self, std::shared_ptr< IMultiLayerBuilder > const p_sample_builder) -> OffSpecSimulation

        OffSpecSimulation::OffSpecSimulation(const std::shared_ptr< class IMultiLayerBuilder > p_sample_builder)

        """
        this = _libBornAgainCore.new_OffSpecSimulation(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_OffSpecSimulation
    __del__ = lambda self: None

    def clone(self):
        """
        clone(OffSpecSimulation self) -> OffSpecSimulation

        OffSpecSimulation* OffSpecSimulation::clone() const

        """
        return _libBornAgainCore.OffSpecSimulation_clone(self)


    def prepareSimulation(self):
        """
        prepareSimulation(OffSpecSimulation self)

        void OffSpecSimulation::prepareSimulation() final

        Put into a clean state for running a simulation. 

        """
        return _libBornAgainCore.OffSpecSimulation_prepareSimulation(self)


    def numberOfSimulationElements(self):
        """
        numberOfSimulationElements(OffSpecSimulation self) -> int

        int OffSpecSimulation::numberOfSimulationElements() const final

        Gets the number of elements this simulation needs to calculate. 

        """
        return _libBornAgainCore.OffSpecSimulation_numberOfSimulationElements(self)


    def getDetectorIntensity(self, *args):
        """
        getDetectorIntensity(OffSpecSimulation self, IDetector2D::EAxesUnits units_type) -> IntensityData
        getDetectorIntensity(OffSpecSimulation self) -> IntensityData

        OutputData<double>* OffSpecSimulation::getDetectorIntensity(IDetector2D::EAxesUnits units_type=IDetector2D::DEFAULT) const

        Returns clone of the detector intensity map. 

        """
        return _libBornAgainCore.OffSpecSimulation_getDetectorIntensity(self, *args)


    def getIntensityData(self):
        """
        getIntensityData(OffSpecSimulation self) -> Histogram2D

        Histogram2D * OffSpecSimulation::getIntensityData() const

        Returns clone of the detector intensity map in the form of 2D histogram. 

        """
        return _libBornAgainCore.OffSpecSimulation_getIntensityData(self)


    def setBeamParameters(self, arg2, alpha_axis, phi_i):
        """
        setBeamParameters(OffSpecSimulation self, double arg2, IAxis alpha_axis, double phi_i)

        void OffSpecSimulation::setBeamParameters(double lambda, const IAxis &alpha_axis, double phi_i)

        Sets beam parameters from here (forwarded to  Instrument) 

        """
        return _libBornAgainCore.OffSpecSimulation_setBeamParameters(self, arg2, alpha_axis, phi_i)


    def setDetectorParameters(self, n_x, x_min, x_max, n_y, y_min, y_max):
        """
        setDetectorParameters(OffSpecSimulation self, size_t n_x, double x_min, double x_max, size_t n_y, double y_min, double y_max)

        void OffSpecSimulation::setDetectorParameters(size_t n_x, double x_min, double x_max, size_t n_y, double y_min, double y_max)

        Sets detector parameters using angle ranges. 

        """
        return _libBornAgainCore.OffSpecSimulation_setDetectorParameters(self, n_x, x_min, x_max, n_y, y_min, y_max)

OffSpecSimulation_swigregister = _libBornAgainCore.OffSpecSimulation_swigregister
OffSpecSimulation_swigregister(OffSpecSimulation)

class IntensityData(_object):
    """


    Template class to store data of any type in multi-dimensional space.Used with data type double to hold simulation results. Used with data type  CumulativeValue in  IHistogram classes. Used with data type bool to hold a detector mask (-> class  DetectorMask)

    C++ includes: OutputData.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntensityData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntensityData, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(OutputData<(double)> self) -> IntensityData

        OutputData< T >::OutputData(const OutputData &)=delete

        """
        this = _libBornAgainCore.new_IntensityData()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_IntensityData
    __del__ = lambda self: None

    def clone(self):
        """
        clone(IntensityData self) -> IntensityData

        OutputData< T > * OutputData< T >::clone() const

        """
        return _libBornAgainCore.IntensityData_clone(self)


    def copyFrom(self, x):
        """
        copyFrom(IntensityData self, IntensityData x)

        void OutputData< T >::copyFrom(const OutputData< T > &x)

        """
        return _libBornAgainCore.IntensityData_copyFrom(self, x)


    def meanValues(self):
        """
        meanValues(IntensityData self) -> IntensityData

        OutputData< double > * OutputData< T >::meanValues() const

        """
        return _libBornAgainCore.IntensityData_meanValues(self)


    def addAxis(self, *args):
        """
        addAxis(IntensityData self, IAxis new_axis)
        addAxis(IntensityData self, std::string const & name, size_t size, double start, double end)

        void OutputData< T >::addAxis(const std::string &name, size_t size, double start, double end)

        """
        return _libBornAgainCore.IntensityData_addAxis(self, *args)


    def getAxis(self, *args):
        """
        getAxis(IntensityData self, size_t serial_number) -> IAxis
        getAxis(IntensityData self, std::string const & axis_name) -> IAxis

        const IAxis & OutputData< T >::getAxis(const std::string &axis_name) const

        returns axis with given name 

        """
        return _libBornAgainCore.IntensityData_getAxis(self, *args)


    def getRank(self):
        """
        getRank(IntensityData self) -> size_t

        size_t OutputData< T >::getRank() const

        Returns number of dimensions. 

        """
        return _libBornAgainCore.IntensityData_getRank(self)


    def getAllocatedSize(self):
        """
        getAllocatedSize(IntensityData self) -> size_t

        size_t OutputData< T >::getAllocatedSize() const

        Returns total size of data buffer (product of bin number in every dimension). 

        """
        return _libBornAgainCore.IntensityData_getAllocatedSize(self)


    def getAllSizes(self):
        """
        getAllSizes(IntensityData self) -> std::vector< size_t,std::allocator< size_t > >

        std::vector< size_t > OutputData< T >::getAllSizes() const

        Returns all sizes of its axes. 

        """
        return _libBornAgainCore.IntensityData_getAllSizes(self)


    def getRawDataVector(self):
        """
        getRawDataVector(IntensityData self) -> vdouble1d_t

        std::vector< T > OutputData< T >::getRawDataVector() const

        Returns copy of raw data vector. 

        """
        return _libBornAgainCore.IntensityData_getRawDataVector(self)


    def fillRawDataArray(self, destination):
        """
        fillRawDataArray(IntensityData self, double * destination)

        void OutputData< T >::fillRawDataArray(T *destination) const

        fill raw array with data 

        """
        return _libBornAgainCore.IntensityData_fillRawDataArray(self, destination)


    def totalSum(self):
        """
        totalSum(IntensityData self) -> double

        T OutputData< T >::totalSum() const

        Returns sum of all values in the data structure. 

        """
        return _libBornAgainCore.IntensityData_totalSum(self)


    def begin(self, *args):
        """
        begin(IntensityData self) -> OutputData< double >::iterator
        begin(IntensityData self) -> OutputData< double >::const_iterator

        OutputData< T >::const_iterator OutputData< T >::begin() const

        Returns read-only iterator that points to the first element. 

        """
        return _libBornAgainCore.IntensityData_begin(self, *args)


    def end(self, *args):
        """
        end(IntensityData self) -> OutputData< double >::iterator
        end(IntensityData self) -> OutputData< double >::const_iterator

        const_iterator OutputData< T >::end() const

        Returns read-only iterator that points to the one past last element. 

        """
        return _libBornAgainCore.IntensityData_end(self, *args)


    def getAxesBinIndices(self, global_index):
        """
        getAxesBinIndices(IntensityData self, size_t global_index) -> vector_integer_t

        std::vector< int > OutputData< T >::getAxesBinIndices(size_t global_index) const

        Returns vector of axes indices for given global index

        Parameters:
        -----------

        global_index: 
        The global index of this data structure.

        Vector of bin indices for all axes defined 

        """
        return _libBornAgainCore.IntensityData_getAxesBinIndices(self, global_index)


    def getAxisBinIndex(self, *args):
        """
        getAxisBinIndex(IntensityData self, size_t global_index, size_t i_selected_axis) -> int
        getAxisBinIndex(IntensityData self, size_t global_index, std::string const & axis_name) -> int

        int OutputData< T >::getAxisBinIndex(size_t global_index, const std::string &axis_name) const

        Returns axis bin index for given global index

        Parameters:
        -----------

        global_index: 
        The global index of this data structure.

        axis_name: 
        The name of selected axis.

        Corresponding bin index for selected axis 

        """
        return _libBornAgainCore.IntensityData_getAxisBinIndex(self, *args)


    def toGlobalIndex(self, axes_indices):
        """
        toGlobalIndex(IntensityData self, vector_integer_t axes_indices) -> size_t

        size_t OutputData< T >::toGlobalIndex(const std::vector< int > &axes_indices) const

        Returns global index for specified indices of axes

        Parameters:
        -----------

        axes_indices: 
        Vector of axes indices for all specified axes in this dataset

        Corresponding global index 

        """
        return _libBornAgainCore.IntensityData_toGlobalIndex(self, axes_indices)


    def findGlobalIndex(self, coordinates):
        """
        findGlobalIndex(IntensityData self, vdouble1d_t coordinates) -> size_t

        size_t OutputData< T >::findGlobalIndex(const std::vector< double > &coordinates) const

        Returns global index for specified axes values

        Parameters:
        -----------

        coordinates: 
        Vector of axes coordinates for all specified axes in this dataset

        Closest global index 

        """
        return _libBornAgainCore.IntensityData_findGlobalIndex(self, coordinates)


    def getAxisValue(self, *args):
        """
        getAxisValue(IntensityData self, size_t global_index, size_t i_selected_axis) -> double
        getAxisValue(IntensityData self, size_t global_index, std::string const & axis_name) -> double

        double OutputData< T >::getAxisValue(size_t global_index, const std::string &axis_name) const

        Returns the value of selected axis for given global_index.

        Parameters:
        -----------

        global_index: 
        The global index of this data structure.

        axis_name: 
        The name of selected axis.

        corresponding bin center of selected axis 

        """
        return _libBornAgainCore.IntensityData_getAxisValue(self, *args)


    def getAxesValues(self, global_index):
        """
        getAxesValues(IntensityData self, size_t global_index) -> vdouble1d_t

        std::vector< double > OutputData< T >::getAxesValues(size_t global_index) const

        Returns values on all defined axes for given globalbin number

        Parameters:
        -----------

        global_index: 
        The global index of this data structure.

        Vector of corresponding bin centers 

        """
        return _libBornAgainCore.IntensityData_getAxesValues(self, global_index)


    def getAxisBin(self, *args):
        """
        getAxisBin(IntensityData self, size_t global_index, size_t i_selected_axis) -> Bin1D
        getAxisBin(IntensityData self, size_t global_index, std::string const & axis_name) -> Bin1D

        Bin1D OutputData< T >::getAxisBin(size_t global_index, const std::string &axis_name) const

        Returns bin of selected axis for given global_index.

        Parameters:
        -----------

        global_index: 
        The global index of this data structure.

        axis_name: 
        The name of selected axis.

        Corresponding  Bin1D object 

        """
        return _libBornAgainCore.IntensityData_getAxisBin(self, *args)


    def clear(self):
        """
        clear(IntensityData self)

        void OutputData< T >::clear()

        Sets object into initial state (no dimensions, data) 

        """
        return _libBornAgainCore.IntensityData_clear(self)


    def setAllTo(self, value):
        """
        setAllTo(IntensityData self, double const & value)

        void OutputData< T >::setAllTo(const T &value)

        Sets content of output data to specific value. 

        """
        return _libBornAgainCore.IntensityData_setAllTo(self, value)


    def scaleAll(self, factor):
        """
        scaleAll(IntensityData self, double const & factor)

        void OutputData< T >::scaleAll(const T &factor)

        multiply every item of this output data by value 

        """
        return _libBornAgainCore.IntensityData_scaleAll(self, factor)


    def setAxisSizes(self, rank, n_dims):
        """
        setAxisSizes(IntensityData self, size_t rank, int * n_dims)

        void OutputData< T >::setAxisSizes(size_t rank, int *n_dims)

        Adds 'rank' axes with indicated sizes. 

        """
        return _libBornAgainCore.IntensityData_setAxisSizes(self, rank, n_dims)


    def setRawDataVector(self, data_vector):
        """
        setRawDataVector(IntensityData self, vdouble1d_t data_vector)

        void OutputData< T >::setRawDataVector(const std::vector< T > &data_vector)

        Sets new values to raw data vector. 

        """
        return _libBornAgainCore.IntensityData_setRawDataVector(self, data_vector)


    def setRawDataArray(self, source):
        """
        setRawDataArray(IntensityData self, double const * source)

        void OutputData< T >::setRawDataArray(const T *source)

        Sets new values to raw data array. 

        """
        return _libBornAgainCore.IntensityData_setRawDataArray(self, source)


    def __iadd__(self, right):
        """__iadd__(IntensityData self, IntensityData right) -> IntensityData"""
        return _libBornAgainCore.IntensityData___iadd__(self, right)


    def __isub__(self, right):
        """__isub__(IntensityData self, IntensityData right) -> IntensityData"""
        return _libBornAgainCore.IntensityData___isub__(self, right)


    def __idiv__(self, right):
        """__idiv__(IntensityData self, IntensityData right) -> IntensityData"""
        return _libBornAgainCore.IntensityData___idiv__(self, right)


    def __imul__(self, right):
        """__imul__(IntensityData self, IntensityData right) -> IntensityData"""
        return _libBornAgainCore.IntensityData___imul__(self, right)


    def getValue(self, index):
        """
        getValue(IntensityData self, size_t index) -> double

        double OutputData< T >::getValue(size_t index) const

        Returns value or summed value, depending on T. 

        """
        return _libBornAgainCore.IntensityData_getValue(self, index)


    def getArray(self):
        """getArray(IntensityData self) -> PyObject *"""
        return _libBornAgainCore.IntensityData_getArray(self)


    def isInitialized(self):
        """
        isInitialized(IntensityData self) -> bool

        bool OutputData< T >::isInitialized() const

        returns data as Python numpy array

        returns true if object is correctly initialized 

        """
        return _libBornAgainCore.IntensityData_isInitialized(self)


    def allocate(self):
        """
        allocate(IntensityData self)

        void OutputData< T >::allocate()

        memory allocation for current dimensions configuration 

        """
        return _libBornAgainCore.IntensityData_allocate(self)


    def __getitem__(self, i):
        """__getitem__(IntensityData self, unsigned int i) -> double"""
        return _libBornAgainCore.IntensityData___getitem__(self, i)


    def __setitem__(self, i, value):
        """__setitem__(IntensityData self, unsigned int i, double value) -> double"""
        return _libBornAgainCore.IntensityData___setitem__(self, i, value)

IntensityData_swigregister = _libBornAgainCore.IntensityData_swigregister
IntensityData_swigregister(IntensityData)

class ParameterDistribution(IParameterized):
    """Proxy of C++ ParameterDistribution class."""

    __swig_setmethods__ = {}
    for _s in [IParameterized]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParameterDistribution, name, value)
    __swig_getmethods__ = {}
    for _s in [IParameterized]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ParameterDistribution, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ParameterDistribution self, std::string const & par_name, IDistribution1D distribution, size_t nbr_samples, double sigma_factor=0.0, RealLimits limits) -> ParameterDistribution
        __init__(ParameterDistribution self, std::string const & par_name, IDistribution1D distribution, size_t nbr_samples, double sigma_factor=0.0) -> ParameterDistribution
        __init__(ParameterDistribution self, std::string const & par_name, IDistribution1D distribution, size_t nbr_samples) -> ParameterDistribution
        __init__(ParameterDistribution self, std::string const & par_name, IDistribution1D distribution, size_t nbr_samples, double xmin, double xmax) -> ParameterDistribution
        __init__(ParameterDistribution self, ParameterDistribution other) -> ParameterDistribution

        ParameterDistribution::ParameterDistribution(const ParameterDistribution &other)

        """
        this = _libBornAgainCore.new_ParameterDistribution(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_ParameterDistribution
    __del__ = lambda self: None

    def linkParameter(self, par_name):
        """
        linkParameter(ParameterDistribution self, std::string par_name) -> ParameterDistribution

        ParameterDistribution & ParameterDistribution::linkParameter(std::string par_name)

        """
        return _libBornAgainCore.ParameterDistribution_linkParameter(self, par_name)


    def getMainParameterName(self):
        """
        getMainParameterName(ParameterDistribution self) -> std::string

        std::string ParameterDistribution::getMainParameterName() const

        get the main parameter's name 

        """
        return _libBornAgainCore.ParameterDistribution_getMainParameterName(self)


    def getNbrSamples(self):
        """
        getNbrSamples(ParameterDistribution self) -> size_t

        size_t ParameterDistribution::getNbrSamples() const

        get number of samples for this distribution 

        """
        return _libBornAgainCore.ParameterDistribution_getNbrSamples(self)


    def getSigmaFactor(self):
        """
        getSigmaFactor(ParameterDistribution self) -> double

        double ParameterDistribution::getSigmaFactor() const

        get the sigma factor 

        """
        return _libBornAgainCore.ParameterDistribution_getSigmaFactor(self)


    def getDistribution(self):
        """
        getDistribution(ParameterDistribution self) -> IDistribution1D

        const IDistribution1D * ParameterDistribution::getDistribution() const

        """
        return _libBornAgainCore.ParameterDistribution_getDistribution(self)


    def generateSamples(self):
        """
        generateSamples(ParameterDistribution self) -> std::vector< ParameterSample,std::allocator< ParameterSample > >

        std::vector< ParameterSample > ParameterDistribution::generateSamples() const

        generate list of sampled values with their weight 

        """
        return _libBornAgainCore.ParameterDistribution_generateSamples(self)


    def getLinkedParameterNames(self):
        """
        getLinkedParameterNames(ParameterDistribution self) -> vector_string_t

        std::vector<std::string> ParameterDistribution::getLinkedParameterNames() const

        get list of linked parameter names 

        """
        return _libBornAgainCore.ParameterDistribution_getLinkedParameterNames(self)


    def getLimits(self):
        """
        getLimits(ParameterDistribution self) -> RealLimits

        RealLimits ParameterDistribution::getLimits() const

        """
        return _libBornAgainCore.ParameterDistribution_getLimits(self)


    def getMinValue(self):
        """
        getMinValue(ParameterDistribution self) -> double

        double ParameterDistribution::getMinValue() const

        """
        return _libBornAgainCore.ParameterDistribution_getMinValue(self)


    def getMaxValue(self):
        """
        getMaxValue(ParameterDistribution self) -> double

        double ParameterDistribution::getMaxValue() const

        """
        return _libBornAgainCore.ParameterDistribution_getMaxValue(self)

ParameterDistribution_swigregister = _libBornAgainCore.ParameterDistribution_swigregister
ParameterDistribution_swigregister(ParameterDistribution)

class ParameterPool(_object):
    """


    Holds a map of pointers to parameters.Used in  IParameterized, which has a member ParameterPool* m_pool. So this is pimpl (pointer to implementation) idiom, with  ParameterPool providing the implementation of all the nontrivial functionality of  IParameterized.

    Parameter names must be unique since we use them as map keys.

    C++ includes: ParameterPool.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParameterPool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ParameterPool, name)
    __repr__ = _swig_repr

    def __init__(self, name, onChange):
        """
        __init__(ParameterPool self, std::string const & name, std::function< void () > const & onChange) -> ParameterPool

        ParameterPool::ParameterPool(const ParameterPool &)=delete

        """
        this = _libBornAgainCore.new_ParameterPool(name, onChange)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_ParameterPool
    __del__ = lambda self: None

    def clone(self):
        """
        clone(ParameterPool self) -> ParameterPool

        ParameterPool * ParameterPool::clone() const

        Returns a literal clone. 

        """
        return _libBornAgainCore.ParameterPool_clone(self)


    def cloneWithPrefix(self, prefix):
        """
        cloneWithPrefix(ParameterPool self, std::string const & prefix) -> ParameterPool

        ParameterPool * ParameterPool::cloneWithPrefix(const std::string &prefix) const

        Returns a clone with  prefix prepended to every parameter key. 

        """
        return _libBornAgainCore.ParameterPool_cloneWithPrefix(self, prefix)


    def copyToExternalPool(self, prefix, external_pool):
        """
        copyToExternalPool(ParameterPool self, std::string const & prefix, ParameterPool external_pool)

        void ParameterPool::copyToExternalPool(const std::string &prefix, ParameterPool *external_pool) const

        Copies parameters of given pool to  other pool, prepeding  prefix to the parameter names. 

        """
        return _libBornAgainCore.ParameterPool_copyToExternalPool(self, prefix, external_pool)


    def clear(self):
        """
        clear(ParameterPool self)

        void ParameterPool::clear()

        Clears the parameter map. 

        """
        return _libBornAgainCore.ParameterPool_clear(self)


    def getName(self):
        """
        getName(ParameterPool self) -> std::string

        std::string ParameterPool::getName() const

        """
        return _libBornAgainCore.ParameterPool_getName(self)


    def size(self):
        """
        size(ParameterPool self) -> size_t

        size_t ParameterPool::size() const

        Returns number of parameters in the pool. 

        """
        return _libBornAgainCore.ParameterPool_size(self)


    def addParameter(self, par):
        """
        addParameter(ParameterPool self, RealParameter par) -> RealParameter

        RealParameter & ParameterPool::addParameter(RealParameter *par)

        Adds parameter to the pool, and returns reference to the input pointer.

        Returning the input pointer allows us to concatenate function calls like pool->addParameter( new  RealParameter(...) ).setLimits(-1,+1).setFixed().setUnit("nm") 

        """
        return _libBornAgainCore.ParameterPool_addParameter(self, par)


    def getParameter(self, *args):
        """
        getParameter(ParameterPool self, std::string const & name) -> RealParameter
        getParameter(ParameterPool self, std::string const & name) -> RealParameter

        const RealParameter * ParameterPool::getParameter(const std::string &name) const

        Returns parameter with given  name. 

        """
        return _libBornAgainCore.ParameterPool_getParameter(self, *args)


    def getParameters(self):
        """
        getParameters(ParameterPool self) -> std::vector< RealParameter *,std::allocator< RealParameter * > > const

        const std::vector<RealParameter*> ParameterPool::getParameters() const

        Returns full vector of parameters. 

        """
        return _libBornAgainCore.ParameterPool_getParameters(self)


    def getMatchedParameters(self, wildcards):
        """
        getMatchedParameters(ParameterPool self, std::string const & wildcards) -> std::vector< RealParameter *,std::allocator< RealParameter * > >

        std::vector< RealParameter * > ParameterPool::getMatchedParameters(const std::string &wildcards) const

        Returns vector of parameters that match the  pattern (wildcards '*' allowed). 

        """
        return _libBornAgainCore.ParameterPool_getMatchedParameters(self, wildcards)


    def getUniqueMatch(self, pattern):
        """getUniqueMatch(ParameterPool self, std::string const & pattern) -> RealParameter"""
        return _libBornAgainCore.ParameterPool_getUniqueMatch(self, pattern)


    def setParameterValue(self, name, value):
        """
        setParameterValue(ParameterPool self, std::string const & name, double value)

        void ParameterPool::setParameterValue(const std::string &name, double value)

        Sets parameter value. 

        """
        return _libBornAgainCore.ParameterPool_setParameterValue(self, name, value)


    def setMatchedParametersValue(self, wildcards, value):
        """
        setMatchedParametersValue(ParameterPool self, std::string const & wildcards, double value) -> int

        int ParameterPool::setMatchedParametersValue(const std::string &wildcards, double value)

        Sets parameter value. 

        """
        return _libBornAgainCore.ParameterPool_setMatchedParametersValue(self, wildcards, value)


    def setUniqueMatchValue(self, pattern, value):
        """setUniqueMatchValue(ParameterPool self, std::string const & pattern, double value)"""
        return _libBornAgainCore.ParameterPool_setUniqueMatchValue(self, pattern, value)


    def getParameterNames(self):
        """
        getParameterNames(ParameterPool self) -> vector_string_t

        std::vector< std::string > ParameterPool::getParameterNames() const

        """
        return _libBornAgainCore.ParameterPool_getParameterNames(self)

ParameterPool_swigregister = _libBornAgainCore.ParameterPool_swigregister
ParameterPool_swigregister(ParameterPool)

class Particle(IParticle):
    """


    A particle with a form factor and refractive index.

    C++ includes: Particle.h

    """

    __swig_setmethods__ = {}
    for _s in [IParticle]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Particle, name, value)
    __swig_getmethods__ = {}
    for _s in [IParticle]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Particle, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Particle self) -> Particle
        __init__(Particle self, IMaterial p_material) -> Particle
        __init__(Particle self, IMaterial p_material, IFormFactor form_factor) -> Particle
        __init__(Particle self, IMaterial p_material, IFormFactor form_factor, IRotation rotation) -> Particle

        Particle::Particle(const IMaterial &p_material, const IFormFactor &form_factor, const IRotation &rotation)

        """
        this = _libBornAgainCore.new_Particle(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(Particle self) -> Particle

        Particle * Particle::clone() const

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.Particle_clone(self)


    def cloneInvertB(self):
        """
        cloneInvertB(Particle self) -> Particle

        Particle * Particle::cloneInvertB() const

        Returns a clone with inverted magnetic fields. 

        """
        return _libBornAgainCore.Particle_cloneInvertB(self)


    def accept(self, visitor):
        """
        accept(Particle self, ISampleVisitor visitor)

        virtual void Particle::accept(ISampleVisitor *visitor) const

        calls the  ISampleVisitor's visit method 

        """
        return _libBornAgainCore.Particle_accept(self, visitor)


    def to_str(self, indent=0):
        """
        to_str(Particle self, int indent=0) -> std::string
        to_str(Particle self) -> std::string

        std::string Particle::to_str(int indent=0) const

        Returns textual representation of this and its descendants. 

        """
        return _libBornAgainCore.Particle_to_str(self, indent)


    def setAmbientMaterial(self, material):
        """
        setAmbientMaterial(Particle self, IMaterial material)

        void Particle::setAmbientMaterial(const IMaterial &material) final

        Sets the refractive index of the ambient material (which influences its scattering power) 

        """
        return _libBornAgainCore.Particle_setAmbientMaterial(self, material)


    def getAmbientMaterial(self):
        """
        getAmbientMaterial(Particle self) -> IMaterial

        const IMaterial* Particle::getAmbientMaterial() const final

        Returns nullptr, unless overwritten to return a specific material. 

        """
        return _libBornAgainCore.Particle_getAmbientMaterial(self)


    def createTransformedFormFactor(self, p_rotation, translation):
        """
        createTransformedFormFactor(Particle self, IRotation p_rotation, kvector_t translation) -> IFormFactor

        IFormFactor * Particle::createTransformedFormFactor(const IRotation *p_rotation, kvector_t translation) const

        Create a form factor for this particle with an extra scattering factor. 

        """
        return _libBornAgainCore.Particle_createTransformedFormFactor(self, p_rotation, translation)


    def setMaterial(self, material):
        """
        setMaterial(Particle self, IMaterial material)

        void Particle::setMaterial(const IMaterial &material)

        """
        return _libBornAgainCore.Particle_setMaterial(self, material)


    def getMaterial(self):
        """
        getMaterial(Particle self) -> IMaterial

        const IMaterial* Particle::getMaterial() const

        Returns nullptr, unless overwritten to return a specific material. 

        """
        return _libBornAgainCore.Particle_getMaterial(self)


    def getRefractiveIndex(self):
        """
        getRefractiveIndex(Particle self) -> complex_t

        complex_t Particle::getRefractiveIndex() const

        """
        return _libBornAgainCore.Particle_getRefractiveIndex(self)


    def setFormFactor(self, form_factor):
        """
        setFormFactor(Particle self, IFormFactor form_factor)

        void Particle::setFormFactor(const IFormFactor &form_factor)

        """
        return _libBornAgainCore.Particle_setFormFactor(self, form_factor)


    def getFormFactor(self):
        """
        getFormFactor(Particle self) -> IFormFactor

        const IFormFactor* Particle::getFormFactor() const

        """
        return _libBornAgainCore.Particle_getFormFactor(self)

    __swig_destroy__ = _libBornAgainCore.delete_Particle
    __del__ = lambda self: None
Particle_swigregister = _libBornAgainCore.Particle_swigregister
Particle_swigregister(Particle)

class ParticleComposition(IParticle):
    """


    A composition of particles at fixed positions

    C++ includes: ParticleComposition.h

    """

    __swig_setmethods__ = {}
    for _s in [IParticle]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParticleComposition, name, value)
    __swig_getmethods__ = {}
    for _s in [IParticle]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ParticleComposition, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ParticleComposition self) -> ParticleComposition
        __init__(ParticleComposition self, IParticle particle) -> ParticleComposition
        __init__(ParticleComposition self, IParticle particle, kvector_t position) -> ParticleComposition
        __init__(ParticleComposition self, IParticle particle, vector_kvector_t positions) -> ParticleComposition

        ParticleComposition::ParticleComposition(const IParticle &particle, std::vector< kvector_t > positions)

        """
        this = _libBornAgainCore.new_ParticleComposition(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_ParticleComposition
    __del__ = lambda self: None

    def clone(self):
        """
        clone(ParticleComposition self) -> ParticleComposition

        ParticleComposition * ParticleComposition::clone() const

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.ParticleComposition_clone(self)


    def cloneInvertB(self):
        """
        cloneInvertB(ParticleComposition self) -> ParticleComposition

        ParticleComposition * ParticleComposition::cloneInvertB() const

        Returns a clone with inverted magnetic fields. 

        """
        return _libBornAgainCore.ParticleComposition_cloneInvertB(self)


    def accept(self, visitor):
        """
        accept(ParticleComposition self, ISampleVisitor visitor)

        virtual void ParticleComposition::accept(ISampleVisitor *visitor) const

        calls the  ISampleVisitor's visit method 

        """
        return _libBornAgainCore.ParticleComposition_accept(self, visitor)


    def addParticle(self, *args):
        """
        addParticle(ParticleComposition self, IParticle particle)
        addParticle(ParticleComposition self, IParticle particle, kvector_t position)

        void ParticleComposition::addParticle(const IParticle &particle, kvector_t position)

        """
        return _libBornAgainCore.ParticleComposition_addParticle(self, *args)


    def addParticles(self, particle, positions):
        """
        addParticles(ParticleComposition self, IParticle particle, vector_kvector_t positions)

        void ParticleComposition::addParticles(const IParticle &particle, std::vector< kvector_t > positions)

        """
        return _libBornAgainCore.ParticleComposition_addParticles(self, particle, positions)


    def setAmbientMaterial(self, material):
        """
        setAmbientMaterial(ParticleComposition self, IMaterial material)

        void ParticleComposition::setAmbientMaterial(const IMaterial &material)

        Sets the refractive index of the ambient material (which influences its scattering power) 

        """
        return _libBornAgainCore.ParticleComposition_setAmbientMaterial(self, material)


    def getAmbientMaterial(self):
        """
        getAmbientMaterial(ParticleComposition self) -> IMaterial

        const IMaterial * ParticleComposition::getAmbientMaterial() const

        Returns nullptr, unless overwritten to return a specific material. 

        """
        return _libBornAgainCore.ParticleComposition_getAmbientMaterial(self)


    def createTransformedFormFactor(self, p_rotation, translation):
        """
        createTransformedFormFactor(ParticleComposition self, IRotation p_rotation, kvector_t translation) -> IFormFactor

        IFormFactor * ParticleComposition::createTransformedFormFactor(const IRotation *p_rotation, kvector_t translation) const

        Create a form factor for this particle with an extra scattering factor. 

        """
        return _libBornAgainCore.ParticleComposition_createTransformedFormFactor(self, p_rotation, translation)


    def getNbrParticles(self):
        """
        getNbrParticles(ParticleComposition self) -> size_t

        size_t ParticleComposition::getNbrParticles() const

        Returns number of different particles. 

        """
        return _libBornAgainCore.ParticleComposition_getNbrParticles(self)


    def getParticle(self, index):
        """
        getParticle(ParticleComposition self, size_t index) -> IParticle

        const IParticle * ParticleComposition::getParticle(size_t index) const

        Returns particle with given index. 

        """
        return _libBornAgainCore.ParticleComposition_getParticle(self, index)


    def getParticlePosition(self, index):
        """
        getParticlePosition(ParticleComposition self, size_t index) -> kvector_t

        kvector_t ParticleComposition::getParticlePosition(size_t index) const

        """
        return _libBornAgainCore.ParticleComposition_getParticlePosition(self, index)

ParticleComposition_swigregister = _libBornAgainCore.ParticleComposition_swigregister
ParticleComposition_swigregister(ParticleComposition)

class ParticleCoreShell(IParticle):
    """


    A particle with a core/shell geometry.

    C++ includes: ParticleCoreShell.h

    """

    __swig_setmethods__ = {}
    for _s in [IParticle]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParticleCoreShell, name, value)
    __swig_getmethods__ = {}
    for _s in [IParticle]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ParticleCoreShell, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ParticleCoreShell self, Particle shell, Particle core, kvector_t relative_core_position) -> ParticleCoreShell
        __init__(ParticleCoreShell self, Particle shell, Particle core) -> ParticleCoreShell

        ParticleCoreShell::ParticleCoreShell(const Particle &shell, const Particle &core, kvector_t relative_core_position=kvector_t(0.0, 0.0, 0.0))

        """
        this = _libBornAgainCore.new_ParticleCoreShell(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_ParticleCoreShell
    __del__ = lambda self: None

    def clone(self):
        """
        clone(ParticleCoreShell self) -> ParticleCoreShell

        ParticleCoreShell * ParticleCoreShell::clone() const

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.ParticleCoreShell_clone(self)


    def cloneInvertB(self):
        """
        cloneInvertB(ParticleCoreShell self) -> ParticleCoreShell

        ParticleCoreShell * ParticleCoreShell::cloneInvertB() const

        Returns a clone with inverted magnetic fields. 

        """
        return _libBornAgainCore.ParticleCoreShell_cloneInvertB(self)


    def accept(self, visitor):
        """
        accept(ParticleCoreShell self, ISampleVisitor visitor)

        virtual void ParticleCoreShell::accept(ISampleVisitor *visitor) const

        Calls the  ISampleVisitor's visit method. 

        """
        return _libBornAgainCore.ParticleCoreShell_accept(self, visitor)


    def setAmbientMaterial(self, material):
        """
        setAmbientMaterial(ParticleCoreShell self, IMaterial material)

        void ParticleCoreShell::setAmbientMaterial(const IMaterial &material)

        Sets the refractive index of the ambient material (which influences its scattering power) 

        """
        return _libBornAgainCore.ParticleCoreShell_setAmbientMaterial(self, material)


    def getAmbientMaterial(self):
        """
        getAmbientMaterial(ParticleCoreShell self) -> IMaterial

        const IMaterial * ParticleCoreShell::getAmbientMaterial() const

        Returns nullptr, unless overwritten to return a specific material. 

        """
        return _libBornAgainCore.ParticleCoreShell_getAmbientMaterial(self)


    def createTransformedFormFactor(self, p_rotation, translation):
        """
        createTransformedFormFactor(ParticleCoreShell self, IRotation p_rotation, kvector_t translation) -> IFormFactor

        IFormFactor * ParticleCoreShell::createTransformedFormFactor(const IRotation *p_rotation, kvector_t translation) const

        Create a form factor for this particle with an extra scattering factor. 

        """
        return _libBornAgainCore.ParticleCoreShell_createTransformedFormFactor(self, p_rotation, translation)


    def getCoreParticle(self):
        """
        getCoreParticle(ParticleCoreShell self) -> Particle

        const Particle* ParticleCoreShell::getCoreParticle() const

        Returns the core particle. 

        """
        return _libBornAgainCore.ParticleCoreShell_getCoreParticle(self)


    def getShellParticle(self):
        """
        getShellParticle(ParticleCoreShell self) -> Particle

        const Particle* ParticleCoreShell::getShellParticle() const

        Returns the shell particle. 

        """
        return _libBornAgainCore.ParticleCoreShell_getShellParticle(self)

ParticleCoreShell_swigregister = _libBornAgainCore.ParticleCoreShell_swigregister
ParticleCoreShell_swigregister(ParticleCoreShell)

class ParticleDistribution(IAbstractParticle):
    """


    A particle type that is a parametric distribution of  IParticle's.

    C++ includes: ParticleDistribution.h

    """

    __swig_setmethods__ = {}
    for _s in [IAbstractParticle]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParticleDistribution, name, value)
    __swig_getmethods__ = {}
    for _s in [IAbstractParticle]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ParticleDistribution, name)
    __repr__ = _swig_repr

    def __init__(self, prototype, par_distr):
        """
        __init__(ParticleDistribution self, IParticle prototype, ParameterDistribution par_distr) -> ParticleDistribution

        ParticleDistribution::ParticleDistribution(const IParticle &prototype, const ParameterDistribution &par_distr)

        """
        this = _libBornAgainCore.new_ParticleDistribution(prototype, par_distr)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(ParticleDistribution self) -> ParticleDistribution

        ParticleDistribution * ParticleDistribution::clone() const

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.ParticleDistribution_clone(self)


    def cloneInvertB(self):
        """
        cloneInvertB(ParticleDistribution self) -> ParticleDistribution

        ParticleDistribution * ParticleDistribution::cloneInvertB() const

        Returns a clone with inverted magnetic fields. 

        """
        return _libBornAgainCore.ParticleDistribution_cloneInvertB(self)


    def accept(self, visitor):
        """
        accept(ParticleDistribution self, ISampleVisitor visitor)

        void ParticleDistribution::accept(ISampleVisitor *visitor) const

        calls the  ISampleVisitor's visit method 

        """
        return _libBornAgainCore.ParticleDistribution_accept(self, visitor)


    def to_str(self, indent=0):
        """
        to_str(ParticleDistribution self, int indent=0) -> std::string
        to_str(ParticleDistribution self) -> std::string

        std::string ParticleDistribution::to_str(int indent=0) const

        Returns textual representation of* this and its descendants. 

        """
        return _libBornAgainCore.ParticleDistribution_to_str(self, indent)


    def setAmbientMaterial(self, material):
        """
        setAmbientMaterial(ParticleDistribution self, IMaterial material)

        void ParticleDistribution::setAmbientMaterial(const IMaterial &material)

        Sets the refractive index of the ambient material (which influences its scattering power) 

        """
        return _libBornAgainCore.ParticleDistribution_setAmbientMaterial(self, material)


    def getAmbientMaterial(self):
        """
        getAmbientMaterial(ParticleDistribution self) -> IMaterial

        const IMaterial * ParticleDistribution::getAmbientMaterial() const

        Returns particle's material. 

        """
        return _libBornAgainCore.ParticleDistribution_getAmbientMaterial(self)


    def generateParticles(self):
        """
        generateParticles(ParticleDistribution self) -> std::vector< IParticle const *,std::allocator< IParticle const * > >

        void ParticleDistribution::generateParticles(std::vector< const IParticle * > &particle_vector) const

        Initializes list of new particles generated according to a distribution. 

        """
        return _libBornAgainCore.ParticleDistribution_generateParticles(self)


    def getParameterDistribution(self):
        """
        getParameterDistribution(ParticleDistribution self) -> ParameterDistribution

        ParameterDistribution ParticleDistribution::getParameterDistribution() const

        Returns the distributed parameter data. 

        """
        return _libBornAgainCore.ParticleDistribution_getParameterDistribution(self)


    def getParticle(self):
        """
        getParticle(ParticleDistribution self) -> IParticle

        const IParticle * ParticleDistribution::getParticle() const

        Returns particle. 

        """
        return _libBornAgainCore.ParticleDistribution_getParticle(self)

    __swig_destroy__ = _libBornAgainCore.delete_ParticleDistribution
    __del__ = lambda self: None
ParticleDistribution_swigregister = _libBornAgainCore.ParticleDistribution_swigregister
ParticleDistribution_swigregister(ParticleDistribution)

class ParticleLayout(ILayout):
    """


    Decorator class that adds particles to  ISample objects.

    C++ includes: ParticleLayout.h

    """

    __swig_setmethods__ = {}
    for _s in [ILayout]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParticleLayout, name, value)
    __swig_getmethods__ = {}
    for _s in [ILayout]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ParticleLayout, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ParticleLayout self) -> ParticleLayout
        __init__(ParticleLayout self, IAbstractParticle particle) -> ParticleLayout
        __init__(ParticleLayout self, IAbstractParticle particle, double abundance) -> ParticleLayout

        ParticleLayout::ParticleLayout(const IAbstractParticle &particle, double abundance)

        """
        this = _libBornAgainCore.new_ParticleLayout(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_ParticleLayout
    __del__ = lambda self: None

    def clone(self):
        """
        clone(ParticleLayout self) -> ParticleLayout

        ParticleLayout * ParticleLayout::clone() const final

        Returns a clone of this  ISample object. 

        """
        return _libBornAgainCore.ParticleLayout_clone(self)


    def cloneInvertB(self):
        """
        cloneInvertB(ParticleLayout self) -> ParticleLayout

        ParticleLayout * ParticleLayout::cloneInvertB() const final

        Returns a clone with inverted magnetic fields. 

        """
        return _libBornAgainCore.ParticleLayout_cloneInvertB(self)


    def accept(self, visitor):
        """
        accept(ParticleLayout self, ISampleVisitor visitor)

        void ParticleLayout::accept(ISampleVisitor *visitor) const final

        calls the  ISampleVisitor's visit method 

        """
        return _libBornAgainCore.ParticleLayout_accept(self, visitor)


    def addParticle(self, *args):
        """
        addParticle(ParticleLayout self, IAbstractParticle particle)
        addParticle(ParticleLayout self, IAbstractParticle particle, double abundance)
        addParticle(ParticleLayout self, IParticle particle, double abundance, kvector_t position)
        addParticle(ParticleLayout self, IParticle particle, double abundance, kvector_t position, IRotation rotation)

        void ParticleLayout::addParticle(const IParticle &particle, double abundance, const kvector_t position, const IRotation &rotation)

        Adds particle to the layout with abundance, position and the rotation defined.

        Parameters:
        -----------

        particle: 
        to be added

        abundance: 
         Particle abundance

        position: 
         Particle position

        rotation: 
         Particle rotation 

        """
        return _libBornAgainCore.ParticleLayout_addParticle(self, *args)


    def getNumberOfParticles(self):
        """
        getNumberOfParticles(ParticleLayout self) -> size_t

        size_t ParticleLayout::getNumberOfParticles() const final

        Returns number of particles. 

        """
        return _libBornAgainCore.ParticleLayout_getNumberOfParticles(self)


    def getParticle(self, index):
        """
        getParticle(ParticleLayout self, size_t index) -> IAbstractParticle

        const IAbstractParticle * ParticleLayout::getParticle(size_t index) const final

        Returns particle info. 

        """
        return _libBornAgainCore.ParticleLayout_getParticle(self, index)


    def getParticles(self):
        """
        getParticles(ParticleLayout self) -> SafePointerVector< IParticle const >

        SafePointerVector< const IParticle > ParticleLayout::getParticles() const final

        Returns information on all particles (type and abundance) and generates new particles if an  IAbstractParticle denotes a collection 

        """
        return _libBornAgainCore.ParticleLayout_getParticles(self)


    def getAbundanceOfParticle(self, index):
        """
        getAbundanceOfParticle(ParticleLayout self, size_t index) -> double

        double ParticleLayout::getAbundanceOfParticle(size_t index) const

        Returns the abundance fraction of particle at given index. 

        """
        return _libBornAgainCore.ParticleLayout_getAbundanceOfParticle(self, index)


    def getInterferenceFunction(self):
        """
        getInterferenceFunction(ParticleLayout self) -> IInterferenceFunction

        const IInterferenceFunction* ParticleLayout::getInterferenceFunction() const final

        Returns interference function. 

        """
        return _libBornAgainCore.ParticleLayout_getInterferenceFunction(self)


    def cloneInterferenceFunction(self):
        """
        cloneInterferenceFunction(ParticleLayout self) -> IInterferenceFunction

        IInterferenceFunction * ParticleLayout::cloneInterferenceFunction() const final

        Returns a clone, or an  InterferenceFunctionNone. 

        """
        return _libBornAgainCore.ParticleLayout_cloneInterferenceFunction(self)


    def addInterferenceFunction(self, interference_function):
        """
        addInterferenceFunction(ParticleLayout self, IInterferenceFunction interference_function)

        void ParticleLayout::addInterferenceFunction(const IInterferenceFunction &interference_function)

        Adds interference functions. 

        """
        return _libBornAgainCore.ParticleLayout_addInterferenceFunction(self, interference_function)


    def getTotalParticleSurfaceDensity(self):
        """
        getTotalParticleSurfaceDensity(ParticleLayout self) -> double

        double ParticleLayout::getTotalParticleSurfaceDensity() const final

        Returns surface density of all particles. 

        """
        return _libBornAgainCore.ParticleLayout_getTotalParticleSurfaceDensity(self)


    def setTotalParticleSurfaceDensity(self, particle_density):
        """
        setTotalParticleSurfaceDensity(ParticleLayout self, double particle_density)

        void ParticleLayout::setTotalParticleSurfaceDensity(double particle_density) final

        Sets surface density of all particles. 

        """
        return _libBornAgainCore.ParticleLayout_setTotalParticleSurfaceDensity(self, particle_density)

ParticleLayout_swigregister = _libBornAgainCore.ParticleLayout_swigregister
ParticleLayout_swigregister(ParticleLayout)

class Polygon(IShape2D):
    """Proxy of C++ Polygon class."""

    __swig_setmethods__ = {}
    for _s in [IShape2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Polygon, name, value)
    __swig_getmethods__ = {}
    for _s in [IShape2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Polygon, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Polygon self, vdouble1d_t x, vdouble1d_t y) -> Polygon
        __init__(Polygon self, vdouble2d_t points) -> Polygon
        __init__(Polygon self, PolygonPrivate const * d) -> Polygon
        """
        this = _libBornAgainCore.new_Polygon(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_Polygon
    __del__ = lambda self: None

    def clone(self):
        """
        clone(Polygon self) -> Polygon

        virtual ICloneable* ICloneable::clone() const =0

        """
        return _libBornAgainCore.Polygon_clone(self)


    def contains(self, *args):
        """
        contains(Polygon self, double x, double y) -> bool
        contains(Polygon self, Bin1D binx, Bin1D biny) -> bool
        """
        return _libBornAgainCore.Polygon_contains(self, *args)


    def getArea(self):
        """getArea(Polygon self) -> double"""
        return _libBornAgainCore.Polygon_getArea(self)


    def getPoints(self, xpos, ypos):
        """getPoints(Polygon self, vdouble1d_t xpos, vdouble1d_t ypos)"""
        return _libBornAgainCore.Polygon_getPoints(self, xpos, ypos)

Polygon_swigregister = _libBornAgainCore.Polygon_swigregister
Polygon_swigregister(Polygon)

class RealParameter(IParameterReal):
    """


    Wraps a parameter of type double. In addition to name and on-change callback held by the parent class  IParameter, this class holds Limits, Attributes (currently only fixed or not), and a  Unit.

    C++ includes: RealParameter.h

    """

    __swig_setmethods__ = {}
    for _s in [IParameterReal]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RealParameter, name, value)
    __swig_getmethods__ = {}
    for _s in [IParameterReal]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RealParameter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(RealParameter self, std::string const & name, double volatile * par, std::string const & parent_name, std::function< void () > const & onChange, RealLimits limits, Attributes attr) -> RealParameter
        __init__(RealParameter self, std::string const & name, double volatile * par, std::string const & parent_name, std::function< void () > const & onChange, RealLimits limits) -> RealParameter
        __init__(RealParameter self, std::string const & name, double volatile * par, std::string const & parent_name, std::function< void () > const & onChange) -> RealParameter

        RealParameter::RealParameter(const std::string &name, volatile double *par, const std::string &parent_name, const std::function< void()> &onChange, const RealLimits &limits=RealLimits::limitless(), const Attributes &attr=Attributes::free())

        """
        this = _libBornAgainCore.new_RealParameter(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self, *args):
        """
        clone(RealParameter self, std::string const & new_name) -> RealParameter
        clone(RealParameter self) -> RealParameter

        RealParameter * RealParameter::clone(const std::string &new_name="") const

        """
        return _libBornAgainCore.RealParameter_clone(self, *args)


    def setValue(self, value):
        """
        setValue(RealParameter self, double value)

        void RealParameter::setValue(double value)

        Sets value of wrapped parameter and emit signal. 

        """
        return _libBornAgainCore.RealParameter_setValue(self, value)


    def getValue(self):
        """
        getValue(RealParameter self) -> double

        double RealParameter::getValue() const

        Returns value of wrapped parameter. 

        """
        return _libBornAgainCore.RealParameter_getValue(self)


    def setLimits(self, limits):
        """
        setLimits(RealParameter self, RealLimits limits) -> RealParameter

        RealParameter& RealParameter::setLimits(const RealLimits &limits)

        """
        return _libBornAgainCore.RealParameter_setLimits(self, limits)


    def getLimits(self):
        """
        getLimits(RealParameter self) -> RealLimits

        RealLimits RealParameter::getLimits() const

        """
        return _libBornAgainCore.RealParameter_getLimits(self)


    def setLimited(self, lower, upper):
        """
        setLimited(RealParameter self, double lower, double upper) -> RealParameter

        RealParameter & RealParameter::setLimited(double lower, double upper)

        """
        return _libBornAgainCore.RealParameter_setLimited(self, lower, upper)


    def setPositive(self):
        """
        setPositive(RealParameter self) -> RealParameter

        RealParameter & RealParameter::setPositive()

        """
        return _libBornAgainCore.RealParameter_setPositive(self)


    def setNonnegative(self):
        """
        setNonnegative(RealParameter self) -> RealParameter

        RealParameter & RealParameter::setNonnegative()

        """
        return _libBornAgainCore.RealParameter_setNonnegative(self)


    def __eq__(self, other):
        """__eq__(RealParameter self, RealParameter other) -> bool"""
        return _libBornAgainCore.RealParameter___eq__(self, other)


    def setUnit(self, name):
        """
        setUnit(RealParameter self, std::string const & name) -> RealParameter

        RealParameter& RealParameter::setUnit(const std::string &name)

        """
        return _libBornAgainCore.RealParameter_setUnit(self, name)


    def unit(self):
        """
        unit(RealParameter self) -> std::string

        std::string RealParameter::unit() const

        """
        return _libBornAgainCore.RealParameter_unit(self)

    __swig_destroy__ = _libBornAgainCore.delete_RealParameter
    __del__ = lambda self: None
RealParameter_swigregister = _libBornAgainCore.RealParameter_swigregister
RealParameter_swigregister(RealParameter)

class Rectangle(IShape2D):
    """Proxy of C++ Rectangle class."""

    __swig_setmethods__ = {}
    for _s in [IShape2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Rectangle, name, value)
    __swig_getmethods__ = {}
    for _s in [IShape2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Rectangle, name)
    __repr__ = _swig_repr

    def __init__(self, xlow, ylow, xup, yup):
        """__init__(Rectangle self, double xlow, double ylow, double xup, double yup) -> Rectangle"""
        this = _libBornAgainCore.new_Rectangle(xlow, ylow, xup, yup)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(Rectangle self) -> Rectangle

        virtual ICloneable* ICloneable::clone() const =0

        """
        return _libBornAgainCore.Rectangle_clone(self)


    def contains(self, *args):
        """
        contains(Rectangle self, double x, double y) -> bool
        contains(Rectangle self, Bin1D binx, Bin1D biny) -> bool
        """
        return _libBornAgainCore.Rectangle_contains(self, *args)


    def getArea(self):
        """getArea(Rectangle self) -> double"""
        return _libBornAgainCore.Rectangle_getArea(self)


    def getXlow(self):
        """getXlow(Rectangle self) -> double"""
        return _libBornAgainCore.Rectangle_getXlow(self)


    def getYlow(self):
        """getYlow(Rectangle self) -> double"""
        return _libBornAgainCore.Rectangle_getYlow(self)


    def getXup(self):
        """getXup(Rectangle self) -> double"""
        return _libBornAgainCore.Rectangle_getXup(self)


    def getYup(self):
        """getYup(Rectangle self) -> double"""
        return _libBornAgainCore.Rectangle_getYup(self)

    __swig_destroy__ = _libBornAgainCore.delete_Rectangle
    __del__ = lambda self: None
Rectangle_swigregister = _libBornAgainCore.Rectangle_swigregister
Rectangle_swigregister(Rectangle)

class RectangularDetector(IDetector2D):
    """


    A rectangular plane detector with axes and resolution function.

    C++ includes: RectangularDetector.h

    """

    __swig_setmethods__ = {}
    for _s in [IDetector2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RectangularDetector, name, value)
    __swig_getmethods__ = {}
    for _s in [IDetector2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RectangularDetector, name)
    __repr__ = _swig_repr
    GENERIC = _libBornAgainCore.RectangularDetector_GENERIC
    PERPENDICULAR_TO_SAMPLE = _libBornAgainCore.RectangularDetector_PERPENDICULAR_TO_SAMPLE
    PERPENDICULAR_TO_DIRECT_BEAM = _libBornAgainCore.RectangularDetector_PERPENDICULAR_TO_DIRECT_BEAM
    PERPENDICULAR_TO_REFLECTED_BEAM = _libBornAgainCore.RectangularDetector_PERPENDICULAR_TO_REFLECTED_BEAM
    PERPENDICULAR_TO_REFLECTED_BEAM_DPOS = _libBornAgainCore.RectangularDetector_PERPENDICULAR_TO_REFLECTED_BEAM_DPOS

    def __init__(self, *args):
        """
        __init__(RectangularDetector self, int nxbins, double width, int nybins, double height) -> RectangularDetector
        __init__(RectangularDetector self, RectangularDetector other) -> RectangularDetector

        RectangularDetector::RectangularDetector(const RectangularDetector &other)

        """
        this = _libBornAgainCore.new_RectangularDetector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clone(self):
        """
        clone(RectangularDetector self) -> RectangularDetector

        RectangularDetector * RectangularDetector::clone() const override

        """
        return _libBornAgainCore.RectangularDetector_clone(self)

    __swig_destroy__ = _libBornAgainCore.delete_RectangularDetector
    __del__ = lambda self: None

    def init(self, beam):
        """
        init(RectangularDetector self, Beam beam)

        void RectangularDetector::init(const Beam &beam) override

        Inits detector with the beam settings. 

        """
        return _libBornAgainCore.RectangularDetector_init(self, beam)


    def setPosition(self, *args):
        """
        setPosition(RectangularDetector self, kvector_t normal_to_detector, double u0, double v0, kvector_t direction)
        setPosition(RectangularDetector self, kvector_t normal_to_detector, double u0, double v0)

        void RectangularDetector::setPosition(const kvector_t normal_to_detector, double u0, double v0, const kvector_t direction=kvector_t(0.0, -1.0, 0.0))

        """
        return _libBornAgainCore.RectangularDetector_setPosition(self, *args)


    def setPerpendicularToSampleX(self, distance, u0, v0):
        """
        setPerpendicularToSampleX(RectangularDetector self, double distance, double u0, double v0)

        void RectangularDetector::setPerpendicularToSampleX(double distance, double u0, double v0)

        """
        return _libBornAgainCore.RectangularDetector_setPerpendicularToSampleX(self, distance, u0, v0)


    def setPerpendicularToDirectBeam(self, distance, u0, v0):
        """
        setPerpendicularToDirectBeam(RectangularDetector self, double distance, double u0, double v0)

        void RectangularDetector::setPerpendicularToDirectBeam(double distance, double u0, double v0)

        """
        return _libBornAgainCore.RectangularDetector_setPerpendicularToDirectBeam(self, distance, u0, v0)


    def setPerpendicularToReflectedBeam(self, distance, u0=0.0, v0=0.0):
        """
        setPerpendicularToReflectedBeam(RectangularDetector self, double distance, double u0=0.0, double v0=0.0)
        setPerpendicularToReflectedBeam(RectangularDetector self, double distance, double u0=0.0)
        setPerpendicularToReflectedBeam(RectangularDetector self, double distance)

        void RectangularDetector::setPerpendicularToReflectedBeam(double distance, double u0=0.0, double v0=0.0)

        """
        return _libBornAgainCore.RectangularDetector_setPerpendicularToReflectedBeam(self, distance, u0, v0)


    def setDirectBeamPosition(self, u0, v0):
        """
        setDirectBeamPosition(RectangularDetector self, double u0, double v0)

        void RectangularDetector::setDirectBeamPosition(double u0, double v0)

        """
        return _libBornAgainCore.RectangularDetector_setDirectBeamPosition(self, u0, v0)


    def getWidth(self):
        """
        getWidth(RectangularDetector self) -> double

        double RectangularDetector::getWidth() const

        """
        return _libBornAgainCore.RectangularDetector_getWidth(self)


    def getHeight(self):
        """
        getHeight(RectangularDetector self) -> double

        double RectangularDetector::getHeight() const

        """
        return _libBornAgainCore.RectangularDetector_getHeight(self)


    def getNbinsX(self):
        """
        getNbinsX(RectangularDetector self) -> size_t

        size_t RectangularDetector::getNbinsX() const

        """
        return _libBornAgainCore.RectangularDetector_getNbinsX(self)


    def getNbinsY(self):
        """
        getNbinsY(RectangularDetector self) -> size_t

        size_t RectangularDetector::getNbinsY() const

        """
        return _libBornAgainCore.RectangularDetector_getNbinsY(self)


    def getNormalVector(self):
        """
        getNormalVector(RectangularDetector self) -> kvector_t

        kvector_t RectangularDetector::getNormalVector() const

        """
        return _libBornAgainCore.RectangularDetector_getNormalVector(self)


    def getU0(self):
        """
        getU0(RectangularDetector self) -> double

        double RectangularDetector::getU0() const

        """
        return _libBornAgainCore.RectangularDetector_getU0(self)


    def getV0(self):
        """
        getV0(RectangularDetector self) -> double

        double RectangularDetector::getV0() const

        """
        return _libBornAgainCore.RectangularDetector_getV0(self)


    def getDirectionVector(self):
        """
        getDirectionVector(RectangularDetector self) -> kvector_t

        kvector_t RectangularDetector::getDirectionVector() const

        """
        return _libBornAgainCore.RectangularDetector_getDirectionVector(self)


    def getDistance(self):
        """
        getDistance(RectangularDetector self) -> double

        double RectangularDetector::getDistance() const

        """
        return _libBornAgainCore.RectangularDetector_getDistance(self)


    def getDirectBeamU0(self):
        """
        getDirectBeamU0(RectangularDetector self) -> double

        double RectangularDetector::getDirectBeamU0() const

        """
        return _libBornAgainCore.RectangularDetector_getDirectBeamU0(self)


    def getDirectBeamV0(self):
        """
        getDirectBeamV0(RectangularDetector self) -> double

        double RectangularDetector::getDirectBeamV0() const

        """
        return _libBornAgainCore.RectangularDetector_getDirectBeamV0(self)


    def getDetectorArrangment(self):
        """
        getDetectorArrangment(RectangularDetector self) -> RectangularDetector::EDetectorArrangement

        RectangularDetector::EDetectorArrangement RectangularDetector::getDetectorArrangment() const

        """
        return _libBornAgainCore.RectangularDetector_getDetectorArrangment(self)


    def getValidAxesUnits(self):
        """
        getValidAxesUnits(RectangularDetector self) -> std::vector< IDetector2D::EAxesUnits,std::allocator< IDetector2D::EAxesUnits > >

        std::vector< IDetector2D::EAxesUnits > RectangularDetector::getValidAxesUnits() const override

        returns vector of valid axes units 

        """
        return _libBornAgainCore.RectangularDetector_getValidAxesUnits(self)


    def getDefaultAxesUnits(self):
        """
        getDefaultAxesUnits(RectangularDetector self) -> IDetector2D::EAxesUnits

        IDetector2D::EAxesUnits RectangularDetector::getDefaultAxesUnits() const override

        return default axes units 

        """
        return _libBornAgainCore.RectangularDetector_getDefaultAxesUnits(self)

RectangularDetector_swigregister = _libBornAgainCore.RectangularDetector_swigregister
RectangularDetector_swigregister(RectangularDetector)

class RectPixelMap(IPixelMap):
    """Proxy of C++ RectPixelMap class."""

    __swig_setmethods__ = {}
    for _s in [IPixelMap]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RectPixelMap, name, value)
    __swig_getmethods__ = {}
    for _s in [IPixelMap]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RectPixelMap, name)
    __repr__ = _swig_repr

    def __init__(self, corner_pos, width, height):
        """
        __init__(RectPixelMap self, kvector_t corner_pos, kvector_t width, kvector_t height) -> RectPixelMap

        RectPixelMap::RectPixelMap(kvector_t corner_pos, kvector_t width, kvector_t height)

        """
        this = _libBornAgainCore.new_RectPixelMap(corner_pos, width, height)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_RectPixelMap
    __del__ = lambda self: None

    def clone(self):
        """
        clone(RectPixelMap self) -> RectPixelMap

        RectPixelMap * RectPixelMap::clone() const override

        """
        return _libBornAgainCore.RectPixelMap_clone(self)


    def createZeroSizeMap(self, x, y):
        """
        createZeroSizeMap(RectPixelMap self, double x, double y) -> RectPixelMap

        RectPixelMap * RectPixelMap::createZeroSizeMap(double x, double y) const override

        """
        return _libBornAgainCore.RectPixelMap_createZeroSizeMap(self, x, y)


    def getK(self, x, y, wavelength):
        """
        getK(RectPixelMap self, double x, double y, double wavelength) -> kvector_t

        kvector_t RectPixelMap::getK(double x, double y, double wavelength) const override

        """
        return _libBornAgainCore.RectPixelMap_getK(self, x, y, wavelength)


    def getIntegrationFactor(self, x, y):
        """
        getIntegrationFactor(RectPixelMap self, double x, double y) -> double

        double RectPixelMap::getIntegrationFactor(double x, double y) const override

        """
        return _libBornAgainCore.RectPixelMap_getIntegrationFactor(self, x, y)


    def getSolidAngle(self):
        """
        getSolidAngle(RectPixelMap self) -> double

        double RectPixelMap::getSolidAngle() const override

        """
        return _libBornAgainCore.RectPixelMap_getSolidAngle(self)

RectPixelMap_swigregister = _libBornAgainCore.RectPixelMap_swigregister
RectPixelMap_swigregister(RectPixelMap)

class ResolutionFunction2DGaussian(IResolutionFunction2D):
    """


    Simple gaussian two-dimensional resolution function.

    C++ includes: ResolutionFunction2DGaussian.h

    """

    __swig_setmethods__ = {}
    for _s in [IResolutionFunction2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ResolutionFunction2DGaussian, name, value)
    __swig_getmethods__ = {}
    for _s in [IResolutionFunction2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ResolutionFunction2DGaussian, name)
    __repr__ = _swig_repr

    def __init__(self, sigma_x, sigma_y):
        """
        __init__(ResolutionFunction2DGaussian self, double sigma_x, double sigma_y) -> ResolutionFunction2DGaussian

        ResolutionFunction2DGaussian::ResolutionFunction2DGaussian(double sigma_x, double sigma_y)

        """
        this = _libBornAgainCore.new_ResolutionFunction2DGaussian(sigma_x, sigma_y)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def evaluateCDF(self, x, y):
        """
        evaluateCDF(ResolutionFunction2DGaussian self, double x, double y) -> double

        double ResolutionFunction2DGaussian::evaluateCDF(double x, double y) const

        """
        return _libBornAgainCore.ResolutionFunction2DGaussian_evaluateCDF(self, x, y)


    def clone(self):
        """
        clone(ResolutionFunction2DGaussian self) -> ResolutionFunction2DGaussian

        ResolutionFunction2DGaussian* ResolutionFunction2DGaussian::clone() const

        """
        return _libBornAgainCore.ResolutionFunction2DGaussian_clone(self)


    def getSigmaX(self):
        """
        getSigmaX(ResolutionFunction2DGaussian self) -> double

        double ResolutionFunction2DGaussian::getSigmaX() const

        """
        return _libBornAgainCore.ResolutionFunction2DGaussian_getSigmaX(self)


    def getSigmaY(self):
        """
        getSigmaY(ResolutionFunction2DGaussian self) -> double

        double ResolutionFunction2DGaussian::getSigmaY() const

        """
        return _libBornAgainCore.ResolutionFunction2DGaussian_getSigmaY(self)

    __swig_destroy__ = _libBornAgainCore.delete_ResolutionFunction2DGaussian
    __del__ = lambda self: None
ResolutionFunction2DGaussian_swigregister = _libBornAgainCore.ResolutionFunction2DGaussian_swigregister
ResolutionFunction2DGaussian_swigregister(ResolutionFunction2DGaussian)

class SpecularSimulation(ICloneable, IParameterized):
    """


    Main class to run a specular simulation.

    C++ includes: SpecularSimulation.h

    """

    __swig_setmethods__ = {}
    for _s in [ICloneable, IParameterized]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpecularSimulation, name, value)
    __swig_getmethods__ = {}
    for _s in [ICloneable, IParameterized]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpecularSimulation, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SpecularSimulation self) -> SpecularSimulation
        __init__(SpecularSimulation self, ISample sample) -> SpecularSimulation
        __init__(SpecularSimulation self, std::shared_ptr< IMultiLayerBuilder > const sample_builder) -> SpecularSimulation

        SpecularSimulation::SpecularSimulation(const std::shared_ptr< IMultiLayerBuilder > sample_builder)

        """
        this = _libBornAgainCore.new_SpecularSimulation(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_SpecularSimulation
    __del__ = lambda self: None

    def clone(self):
        """
        clone(SpecularSimulation self) -> SpecularSimulation

        SpecularSimulation * SpecularSimulation::clone() const

        """
        return _libBornAgainCore.SpecularSimulation_clone(self)


    def runSimulation(self):
        """
        runSimulation(SpecularSimulation self)

        void SpecularSimulation::runSimulation()

        Run a simulation with the current parameter settings. 

        """
        return _libBornAgainCore.SpecularSimulation_runSimulation(self)


    def setSample(self, sample):
        """
        setSample(SpecularSimulation self, ISample sample)

        void SpecularSimulation::setSample(const ISample &sample)

        Sets the sample to be tested. 

        """
        return _libBornAgainCore.SpecularSimulation_setSample(self, sample)


    def getSample(self):
        """
        getSample(SpecularSimulation self) -> ISample

        ISample* SpecularSimulation::getSample() const

        Returns the sample. 

        """
        return _libBornAgainCore.SpecularSimulation_getSample(self)


    def setSampleBuilderCpp(self, sample_builder):
        """
        setSampleBuilderCpp(SpecularSimulation self, std::shared_ptr< IMultiLayerBuilder > sample_builder)

        void SpecularSimulation::setSampleBuilder(std::shared_ptr< IMultiLayerBuilder > sample_builder)

        Sets the sample builder. 

        """
        return _libBornAgainCore.SpecularSimulation_setSampleBuilderCpp(self, sample_builder)


    def getSampleBuilder(self):
        """
        getSampleBuilder(SpecularSimulation self) -> std::shared_ptr< IMultiLayerBuilder >

        std::shared_ptr<IMultiLayerBuilder> SpecularSimulation::getSampleBuilder() const

        return sample builder 

        """
        return _libBornAgainCore.SpecularSimulation_getSampleBuilder(self)


    def setBeamParameters(self, *args):
        """
        setBeamParameters(SpecularSimulation self, double arg2, IAxis alpha_axis)
        setBeamParameters(SpecularSimulation self, double arg2, int nbins, double alpha_i_min, double alpha_i_max)

        void SpecularSimulation::setBeamParameters(double lambda, int nbins, double alpha_i_min, double alpha_i_max)

        """
        return _libBornAgainCore.SpecularSimulation_setBeamParameters(self, *args)


    def setEvanescentWaveAxis(self, *args):
        """
        setEvanescentWaveAxis(SpecularSimulation self, IAxis z_axis)
        setEvanescentWaveAxis(SpecularSimulation self, int nbins, double z_min, double z_max)

        void SpecularSimulation::setEvanescentWaveAxis(int nbins, double z_min, double z_max)

        """
        return _libBornAgainCore.SpecularSimulation_setEvanescentWaveAxis(self, *args)


    def getAlphaAxis(self):
        """
        getAlphaAxis(SpecularSimulation self) -> IAxis

        const IAxis * SpecularSimulation::getAlphaAxis() const

        returns alpha_i axis 

        """
        return _libBornAgainCore.SpecularSimulation_getAlphaAxis(self)


    def getScalarR(self, i_layer):
        """
        getScalarR(SpecularSimulation self, size_t i_layer) -> vector_complex_t

        std::vector< complex_t > SpecularSimulation::getScalarR(size_t i_layer) const

        returns vector of reflection coefficients for all alpha_i angles for given layer index 

        """
        return _libBornAgainCore.SpecularSimulation_getScalarR(self, i_layer)


    def getScalarT(self, i_layer):
        """
        getScalarT(SpecularSimulation self, size_t i_layer) -> vector_complex_t

        std::vector< complex_t > SpecularSimulation::getScalarT(size_t i_layer) const

        returns vector of transmission coefficients for all alpha_i angles for given layer index 

        """
        return _libBornAgainCore.SpecularSimulation_getScalarT(self, i_layer)


    def getScalarKz(self, i_layer):
        """
        getScalarKz(SpecularSimulation self, size_t i_layer) -> vector_complex_t

        std::vector< complex_t > SpecularSimulation::getScalarKz(size_t i_layer) const

        returns vector of Kz coefficients for all alpha_i angles for given layer index 

        """
        return _libBornAgainCore.SpecularSimulation_getScalarKz(self, i_layer)


    def getLayerRTCoefficients(self, i_alpha, i_layer):
        """
        getLayerRTCoefficients(SpecularSimulation self, size_t i_alpha, size_t i_layer) -> SpecularSimulation::LayerRTCoefficients_t

        SpecularSimulation::LayerRTCoefficients_t SpecularSimulation::getLayerRTCoefficients(size_t i_alpha, size_t i_layer) const

        """
        return _libBornAgainCore.SpecularSimulation_getLayerRTCoefficients(self, i_alpha, i_layer)


    def prepareSimulation(self):
        """
        prepareSimulation(SpecularSimulation self)

        void SpecularSimulation::prepareSimulation()

        Put into a clean state for running a simulation. 

        """
        return _libBornAgainCore.SpecularSimulation_prepareSimulation(self)


    def setSampleBuilder(self, ptr):
        self.samplebuilder = ptr
        self.setSampleBuilderCpp(ptr)

SpecularSimulation_swigregister = _libBornAgainCore.SpecularSimulation_swigregister
SpecularSimulation_swigregister(SpecularSimulation)

class ThreadInfo(_object):
    """


    Information to run simulation with dedicated number of threads.

    C++ includes: ThreadInfo.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThreadInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ThreadInfo, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(ThreadInfo self) -> ThreadInfo

        ThreadInfo::ThreadInfo()

        """
        this = _libBornAgainCore.new_ThreadInfo()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["n_threads"] = _libBornAgainCore.ThreadInfo_n_threads_set
    __swig_getmethods__["n_threads"] = _libBornAgainCore.ThreadInfo_n_threads_get
    if _newclass:
        n_threads = _swig_property(_libBornAgainCore.ThreadInfo_n_threads_get, _libBornAgainCore.ThreadInfo_n_threads_set)
    __swig_setmethods__["current_thread"] = _libBornAgainCore.ThreadInfo_current_thread_set
    __swig_getmethods__["current_thread"] = _libBornAgainCore.ThreadInfo_current_thread_get
    if _newclass:
        current_thread = _swig_property(_libBornAgainCore.ThreadInfo_current_thread_get, _libBornAgainCore.ThreadInfo_current_thread_set)
    __swig_setmethods__["n_batches"] = _libBornAgainCore.ThreadInfo_n_batches_set
    __swig_getmethods__["n_batches"] = _libBornAgainCore.ThreadInfo_n_batches_get
    if _newclass:
        n_batches = _swig_property(_libBornAgainCore.ThreadInfo_n_batches_get, _libBornAgainCore.ThreadInfo_n_batches_set)
    __swig_setmethods__["current_batch"] = _libBornAgainCore.ThreadInfo_current_batch_set
    __swig_getmethods__["current_batch"] = _libBornAgainCore.ThreadInfo_current_batch_get
    if _newclass:
        current_batch = _swig_property(_libBornAgainCore.ThreadInfo_current_batch_get, _libBornAgainCore.ThreadInfo_current_batch_set)
    __swig_destroy__ = _libBornAgainCore.delete_ThreadInfo
    __del__ = lambda self: None
ThreadInfo_swigregister = _libBornAgainCore.ThreadInfo_swigregister
ThreadInfo_swigregister(ThreadInfo)

class SampleBuilderFactoryTemp(_object):
    """


    Base class for all factories.

    C++ includes: IFactory.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SampleBuilderFactoryTemp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SampleBuilderFactoryTemp, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(IFactory<(std::string,IMultiLayerBuilder)> self) -> SampleBuilderFactoryTemp

        IFactory< Key, AbstractProduct >::IFactory()

        """
        this = _libBornAgainCore.new_SampleBuilderFactoryTemp()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def createItem(self, item_key):
        """
        createItem(SampleBuilderFactoryTemp self, std::string const & item_key) -> IMultiLayerBuilder

        AbstractProduct* IFactory< Key, AbstractProduct >::createItem(const Key &item_key)

        Creates object by calling creation function corresponded to given identifier. 

        """
        return _libBornAgainCore.SampleBuilderFactoryTemp_createItem(self, item_key)


    def registerItem(self, *args):
        """
        registerItem(SampleBuilderFactoryTemp self, std::string const & item_key, IFactory< std::string,IMultiLayerBuilder >::CreateItemCallback CreateFn, std::string const & itemDescription) -> bool
        registerItem(SampleBuilderFactoryTemp self, std::string const & item_key, IFactory< std::string,IMultiLayerBuilder >::CreateItemCallback CreateFn) -> bool

        bool IFactory< Key, AbstractProduct >::registerItem(const Key &item_key, CreateItemCallback CreateFn, const std::string &itemDescription="")

        Registers object's creation function and store object description. 

        """
        return _libBornAgainCore.SampleBuilderFactoryTemp_registerItem(self, *args)

    __swig_destroy__ = _libBornAgainCore.delete_SampleBuilderFactoryTemp
    __del__ = lambda self: None

    def getNumberOfRegistered(self):
        """
        getNumberOfRegistered(SampleBuilderFactoryTemp self) -> size_t

        size_t IFactory< Key, AbstractProduct >::getNumberOfRegistered() const

        Returns number of registered objects. 

        """
        return _libBornAgainCore.SampleBuilderFactoryTemp_getNumberOfRegistered(self)


    def begin(self):
        """
        begin(SampleBuilderFactoryTemp self) -> IFactory< std::string,IMultiLayerBuilder >::const_iterator

        const_iterator IFactory< Key, AbstractProduct >::begin() const

        """
        return _libBornAgainCore.SampleBuilderFactoryTemp_begin(self)


    def end(self):
        """
        end(SampleBuilderFactoryTemp self) -> IFactory< std::string,IMultiLayerBuilder >::const_iterator

        const_iterator IFactory< Key, AbstractProduct >::end() const

        """
        return _libBornAgainCore.SampleBuilderFactoryTemp_end(self)

SampleBuilderFactoryTemp_swigregister = _libBornAgainCore.SampleBuilderFactoryTemp_swigregister
SampleBuilderFactoryTemp_swigregister(SampleBuilderFactoryTemp)

class SampleBuilderFactory(SampleBuilderFactoryTemp):
    """


    Factory to create standard pre-defined samples.

    C++ includes: SampleBuilderFactory.h

    """

    __swig_setmethods__ = {}
    for _s in [SampleBuilderFactoryTemp]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SampleBuilderFactory, name, value)
    __swig_getmethods__ = {}
    for _s in [SampleBuilderFactoryTemp]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SampleBuilderFactory, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(SampleBuilderFactory self) -> SampleBuilderFactory

        SampleBuilderFactory::SampleBuilderFactory()

        """
        this = _libBornAgainCore.new_SampleBuilderFactory()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def createSample(self, name):
        """
        createSample(SampleBuilderFactory self, std::string const & name) -> MultiLayer

        MultiLayer * SampleBuilderFactory::createSample(const std::string &name)

        Retrieves a SampleBuilder from the registry, does the build, and returns the result. 

        """
        return _libBornAgainCore.SampleBuilderFactory_createSample(self, name)

    __swig_destroy__ = _libBornAgainCore.delete_SampleBuilderFactory
    __del__ = lambda self: None
SampleBuilderFactory_swigregister = _libBornAgainCore.SampleBuilderFactory_swigregister
SampleBuilderFactory_swigregister(SampleBuilderFactory)

class SimulationFactoryTemp(_object):
    """


    Base class for all factories.

    C++ includes: IFactory.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimulationFactoryTemp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SimulationFactoryTemp, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(IFactory<(std::string,GISASSimulation)> self) -> SimulationFactoryTemp

        IFactory< Key, AbstractProduct >::IFactory()

        """
        this = _libBornAgainCore.new_SimulationFactoryTemp()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def createItem(self, item_key):
        """
        createItem(SimulationFactoryTemp self, std::string const & item_key) -> GISASSimulation

        AbstractProduct* IFactory< Key, AbstractProduct >::createItem(const Key &item_key)

        Creates object by calling creation function corresponded to given identifier. 

        """
        return _libBornAgainCore.SimulationFactoryTemp_createItem(self, item_key)


    def registerItem(self, *args):
        """
        registerItem(SimulationFactoryTemp self, std::string const & item_key, IFactory< std::string,GISASSimulation >::CreateItemCallback CreateFn, std::string const & itemDescription) -> bool
        registerItem(SimulationFactoryTemp self, std::string const & item_key, IFactory< std::string,GISASSimulation >::CreateItemCallback CreateFn) -> bool

        bool IFactory< Key, AbstractProduct >::registerItem(const Key &item_key, CreateItemCallback CreateFn, const std::string &itemDescription="")

        Registers object's creation function and store object description. 

        """
        return _libBornAgainCore.SimulationFactoryTemp_registerItem(self, *args)

    __swig_destroy__ = _libBornAgainCore.delete_SimulationFactoryTemp
    __del__ = lambda self: None

    def getNumberOfRegistered(self):
        """
        getNumberOfRegistered(SimulationFactoryTemp self) -> size_t

        size_t IFactory< Key, AbstractProduct >::getNumberOfRegistered() const

        Returns number of registered objects. 

        """
        return _libBornAgainCore.SimulationFactoryTemp_getNumberOfRegistered(self)


    def begin(self):
        """
        begin(SimulationFactoryTemp self) -> IFactory< std::string,GISASSimulation >::const_iterator

        const_iterator IFactory< Key, AbstractProduct >::begin() const

        """
        return _libBornAgainCore.SimulationFactoryTemp_begin(self)


    def end(self):
        """
        end(SimulationFactoryTemp self) -> IFactory< std::string,GISASSimulation >::const_iterator

        const_iterator IFactory< Key, AbstractProduct >::end() const

        """
        return _libBornAgainCore.SimulationFactoryTemp_end(self)

SimulationFactoryTemp_swigregister = _libBornAgainCore.SimulationFactoryTemp_swigregister
SimulationFactoryTemp_swigregister(SimulationFactoryTemp)

class SimulationFactory(SimulationFactoryTemp):
    """


    Registry to create standard pre-defined simulations. Used in functional tests, performance measurements, etc.

    C++ includes: SimulationFactory.h

    """

    __swig_setmethods__ = {}
    for _s in [SimulationFactoryTemp]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimulationFactory, name, value)
    __swig_getmethods__ = {}
    for _s in [SimulationFactoryTemp]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SimulationFactory, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(SimulationFactory self) -> SimulationFactory

        SimulationFactory::SimulationFactory()

        """
        this = _libBornAgainCore.new_SimulationFactory()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libBornAgainCore.delete_SimulationFactory
    __del__ = lambda self: None
SimulationFactory_swigregister = _libBornAgainCore.SimulationFactory_swigregister
SimulationFactory_swigregister(SimulationFactory)

# This file is compatible with both classic and new-style classes.

