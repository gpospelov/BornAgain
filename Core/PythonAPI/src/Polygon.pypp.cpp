// This file has been generated by Py++.

// ************************************************************************** //
//
//  BornAgain: simulate and fit scattering at grazing incidence
//
//! @file      Automatically generated boost::python code for BornAgain Python bindings
//! @brief     Automatically generated boost::python code for BornAgain Python bindings
//!
//! @homepage  http://bornagainproject.org
//! @license   GNU General Public License v3 or higher (see COPYING)
//! @copyright Forschungszentrum Juelich GmbH 2015
//! @authors   Scientific Computing Group at MLZ Garching
//! @authors   C. Durniak, M. Ganeva, G. Pospelov, W. Van Herck, J. Wuttke
//
// ************************************************************************** //

#include "Macros.h"
GCC_DIAG_OFF(unused-parameter)
GCC_DIAG_OFF(missing-field-initializers)
#include "boost/python.hpp"
GCC_DIAG_ON(unused-parameter)
GCC_DIAG_ON(missing-field-initializers)
#include "PythonCoreList.h"
#include "Polygon.pypp.h"

namespace bp = boost::python;

struct Polygon_wrapper : Geometry::Polygon, bp::wrapper< Geometry::Polygon > {

    Polygon_wrapper(::std::vector< double > x, ::std::vector< double > y )
    : Geometry::Polygon( x, y )
      , bp::wrapper< Geometry::Polygon >(){
        // constructor
    m_pyobj = 0;
    }

    Polygon_wrapper(::std::vector< std::vector< double > > points )
    : Geometry::Polygon( points )
      , bp::wrapper< Geometry::Polygon >(){
        // constructor
    m_pyobj = 0;
    }

    virtual ::Geometry::Polygon * clone(  ) const  {
        if( bp::override func_clone = this->get_override( "clone" ) )
            return func_clone(  );
        else{
            return this->Geometry::Polygon::clone(  );
        }
    }
    
    ::Geometry::Polygon * default_clone(  ) const  {
        return Geometry::Polygon::clone( );
    }

    virtual bool contains( double x, double y ) const  {
        if( bp::override func_contains = this->get_override( "contains" ) )
            return func_contains( x, y );
        else{
            return this->Geometry::Polygon::contains( x, y );
        }
    }
    
    bool default_contains( double x, double y ) const  {
        return Geometry::Polygon::contains( x, y );
    }

    virtual bool contains( ::Bin1D const & binx, ::Bin1D const & biny ) const  {
        if( bp::override func_contains = this->get_override( "contains" ) )
            return func_contains( boost::ref(binx), boost::ref(biny) );
        else{
            return this->Geometry::Polygon::contains( boost::ref(binx), boost::ref(biny) );
        }
    }
    
    bool default_contains( ::Bin1D const & binx, ::Bin1D const & biny ) const  {
        return Geometry::Polygon::contains( boost::ref(binx), boost::ref(biny) );
    }

    virtual void transferToCPP(  ) {
        
        if( !this->m_pyobj) {
            this->m_pyobj = boost::python::detail::wrapper_base_::get_owner(*this);
            Py_INCREF(this->m_pyobj);
        }
        
        if( bp::override func_transferToCPP = this->get_override( "transferToCPP" ) )
            func_transferToCPP(  );
        else{
            this->ICloneable::transferToCPP(  );
        }
    }
    
    void default_transferToCPP(  ) {
        
        if( !this->m_pyobj) {
            this->m_pyobj = boost::python::detail::wrapper_base_::get_owner(*this);
            Py_INCREF(this->m_pyobj);
        }
        
        ICloneable::transferToCPP( );
    }

    PyObject* m_pyobj;

};

void register_Polygon_class(){

    { //::Geometry::Polygon
        typedef bp::class_< Polygon_wrapper, bp::bases< Geometry::IShape2D >, std::auto_ptr< Polygon_wrapper >, boost::noncopyable > Polygon_exposer_t;
        Polygon_exposer_t Polygon_exposer = Polygon_exposer_t( "Polygon", "The polygon in 2D spac.", bp::init< std::vector< double >, std::vector< double > >(( bp::arg("x"), bp::arg("y") ), "Polygon defined by two arrays with x and y coordinates of points. Sizes of arrays should coincide.  If polygon is unclosed (the last point doesn't repeat the first one), it will be closed automatically. @param x Vector of x-coordinates of polygon points. @param x Vector of y-coordinates of polygon points. \n\n:Parameters:\n  - 'x' - Vector of x-coordinates of polygon points.\n  - 'x' - Vector of y-coordinates of polygon points.\n") );
        bp::scope Polygon_scope( Polygon_exposer );
        Polygon_exposer.def( bp::init< std::vector< std::vector< double > > >(( bp::arg("points") ), "Polygon defined by two  dimensional array with (x,y) coordinates of polygon points. The size of second dimension should be 2. If polygon is unclosed (the last point doesn't repeat the first one), it will be closed automatically. @param points Two dimensional vector of (x,y) coordinates of polygon points. \n\n:Parameters:\n  - 'points' - Two dimensional vector of (x,y) coordinates of polygon points.\n") );
        { //::Geometry::Polygon::clone
        
            typedef ::Geometry::Polygon * ( ::Geometry::Polygon::*clone_function_type)(  ) const;
            typedef ::Geometry::Polygon * ( Polygon_wrapper::*default_clone_function_type)(  ) const;
            
            Polygon_exposer.def( 
                "clone"
                , clone_function_type(&::Geometry::Polygon::clone)
                , default_clone_function_type(&Polygon_wrapper::default_clone)
                , bp::return_value_policy< bp::manage_new_object >() );
        
        }
        { //::Geometry::Polygon::contains
        
            typedef bool ( ::Geometry::Polygon::*contains_function_type)( double,double ) const;
            typedef bool ( Polygon_wrapper::*default_contains_function_type)( double,double ) const;
            
            Polygon_exposer.def( 
                "contains"
                , contains_function_type(&::Geometry::Polygon::contains)
                , default_contains_function_type(&Polygon_wrapper::default_contains)
                , ( bp::arg("x"), bp::arg("y") ) );
        
        }
        { //::Geometry::Polygon::contains
        
            typedef bool ( ::Geometry::Polygon::*contains_function_type)( ::Bin1D const &,::Bin1D const & ) const;
            typedef bool ( Polygon_wrapper::*default_contains_function_type)( ::Bin1D const &,::Bin1D const & ) const;
            
            Polygon_exposer.def( 
                "contains"
                , contains_function_type(&::Geometry::Polygon::contains)
                , default_contains_function_type(&Polygon_wrapper::default_contains)
                , ( bp::arg("binx"), bp::arg("biny") ) );
        
        }
        { //::Geometry::Polygon::getArea
        
            typedef double ( ::Geometry::Polygon::*getArea_function_type)(  ) const;
            
            Polygon_exposer.def( 
                "getArea"
                , getArea_function_type( &::Geometry::Polygon::getArea )
                , "Returns true if area defined by two bins is inside or on border of polygon. More precisely, if mid point of two bins satisfy this condition. " );
        
        }
        { //::Geometry::Polygon::getPoints
        
            typedef void ( ::Geometry::Polygon::*getPoints_function_type)( ::std::vector< double > &,::std::vector< double > & ) const;
            
            Polygon_exposer.def( 
                "getPoints"
                , getPoints_function_type( &::Geometry::Polygon::getPoints )
                , ( bp::arg("xpos"), bp::arg("ypos") ) );
        
        }
        { //::ICloneable::transferToCPP
        
            typedef void ( ::ICloneable::*transferToCPP_function_type)(  ) ;
            typedef void ( Polygon_wrapper::*default_transferToCPP_function_type)(  ) ;
            
            Polygon_exposer.def( 
                "transferToCPP"
                , transferToCPP_function_type(&::ICloneable::transferToCPP)
                , default_transferToCPP_function_type(&Polygon_wrapper::default_transferToCPP) );
        
        }
    }

}
